
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model pais
 * 
 */
export type pais = $Result.DefaultSelection<Prisma.$paisPayload>
/**
 * Model estado
 * 
 */
export type estado = $Result.DefaultSelection<Prisma.$estadoPayload>
/**
 * Model cidade
 * 
 */
export type cidade = $Result.DefaultSelection<Prisma.$cidadePayload>
/**
 * Model endereco
 * 
 */
export type endereco = $Result.DefaultSelection<Prisma.$enderecoPayload>
/**
 * Model tipoCarisma
 * 
 */
export type tipoCarisma = $Result.DefaultSelection<Prisma.$tipoCarismaPayload>
/**
 * Model estadoCivil
 * 
 */
export type estadoCivil = $Result.DefaultSelection<Prisma.$estadoCivilPayload>
/**
 * Model escolaridade
 * 
 */
export type escolaridade = $Result.DefaultSelection<Prisma.$escolaridadePayload>
/**
 * Model pessoa
 * 
 */
export type pessoa = $Result.DefaultSelection<Prisma.$pessoaPayload>
/**
 * Model tipoPessoa
 * 
 */
export type tipoPessoa = $Result.DefaultSelection<Prisma.$tipoPessoaPayload>
/**
 * Model pessoaEndereco
 * 
 */
export type pessoaEndereco = $Result.DefaultSelection<Prisma.$pessoaEnderecoPayload>
/**
 * Model pessoaCasal
 * 
 */
export type pessoaCasal = $Result.DefaultSelection<Prisma.$pessoaCasalPayload>
/**
 * Model pessoaCarisma
 * 
 */
export type pessoaCarisma = $Result.DefaultSelection<Prisma.$pessoaCarismaPayload>
/**
 * Model passaportePessoa
 * 
 */
export type passaportePessoa = $Result.DefaultSelection<Prisma.$passaportePessoaPayload>
/**
 * Model pessoaContato
 * 
 */
export type pessoaContato = $Result.DefaultSelection<Prisma.$pessoaContatoPayload>
/**
 * Model tipoDiocese
 * 
 */
export type tipoDiocese = $Result.DefaultSelection<Prisma.$tipoDiocesePayload>
/**
 * Model diocese
 * 
 */
export type diocese = $Result.DefaultSelection<Prisma.$diocesePayload>
/**
 * Model paroquia
 * 
 */
export type paroquia = $Result.DefaultSelection<Prisma.$paroquiaPayload>
/**
 * Model paroquiaPessoas
 * 
 */
export type paroquiaPessoas = $Result.DefaultSelection<Prisma.$paroquiaPessoasPayload>
/**
 * Model etapa
 * 
 */
export type etapa = $Result.DefaultSelection<Prisma.$etapaPayload>
/**
 * Model regiao
 * 
 */
export type regiao = $Result.DefaultSelection<Prisma.$regiaoPayload>
/**
 * Model tipoEquipe
 * 
 */
export type tipoEquipe = $Result.DefaultSelection<Prisma.$tipoEquipePayload>
/**
 * Model equipe
 * 
 */
export type equipe = $Result.DefaultSelection<Prisma.$equipePayload>
/**
 * Model equipeTipoEquipe
 * 
 */
export type equipeTipoEquipe = $Result.DefaultSelection<Prisma.$equipeTipoEquipePayload>
/**
 * Model equipeRegiao
 * 
 */
export type equipeRegiao = $Result.DefaultSelection<Prisma.$equipeRegiaoPayload>
/**
 * Model equipePessoas
 * 
 */
export type equipePessoas = $Result.DefaultSelection<Prisma.$equipePessoasPayload>
/**
 * Model localidade
 * 
 */
export type localidade = $Result.DefaultSelection<Prisma.$localidadePayload>
/**
 * Model localidadeRegiao
 * 
 */
export type localidadeRegiao = $Result.DefaultSelection<Prisma.$localidadeRegiaoPayload>
/**
 * Model tipoLocalidade
 * 
 */
export type tipoLocalidade = $Result.DefaultSelection<Prisma.$tipoLocalidadePayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Sexo: {
  MASCULINO: 'MASCULINO',
  FEMININO: 'FEMININO'
};

export type Sexo = (typeof Sexo)[keyof typeof Sexo]


export const roles: {
  ADMIN: 'ADMIN',
  CATEQUISTA_NACIONAL: 'CATEQUISTA_NACIONAL',
  CATEQUISTA_GRANDE_REGIAO: 'CATEQUISTA_GRANDE_REGIAO',
  CATEQUISTA_REGIAO: 'CATEQUISTA_REGIAO',
  CATEQUISTA_SETOR: 'CATEQUISTA_SETOR',
  CATEQUISTA_PAROQUIA: 'CATEQUISTA_PAROQUIA',
  SECRETARIA_CNC: 'SECRETARIA_CNC',
  SECRETARIA_PAROQUIA: 'SECRETARIA_PAROQUIA',
  NAO_IDENTIFICADO: 'NAO_IDENTIFICADO'
};

export type roles = (typeof roles)[keyof typeof roles]

}

export type Sexo = $Enums.Sexo

export const Sexo: typeof $Enums.Sexo

export type roles = $Enums.roles

export const roles: typeof $Enums.roles

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Pais
 * const pais = await prisma.pais.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Pais
   * const pais = await prisma.pais.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.pais`: Exposes CRUD operations for the **pais** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pais
    * const pais = await prisma.pais.findMany()
    * ```
    */
  get pais(): Prisma.paisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estado`: Exposes CRUD operations for the **estado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Estados
    * const estados = await prisma.estado.findMany()
    * ```
    */
  get estado(): Prisma.estadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cidade`: Exposes CRUD operations for the **cidade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cidades
    * const cidades = await prisma.cidade.findMany()
    * ```
    */
  get cidade(): Prisma.cidadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.endereco`: Exposes CRUD operations for the **endereco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enderecos
    * const enderecos = await prisma.endereco.findMany()
    * ```
    */
  get endereco(): Prisma.enderecoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoCarisma`: Exposes CRUD operations for the **tipoCarisma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoCarismas
    * const tipoCarismas = await prisma.tipoCarisma.findMany()
    * ```
    */
  get tipoCarisma(): Prisma.tipoCarismaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.estadoCivil`: Exposes CRUD operations for the **estadoCivil** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EstadoCivils
    * const estadoCivils = await prisma.estadoCivil.findMany()
    * ```
    */
  get estadoCivil(): Prisma.estadoCivilDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.escolaridade`: Exposes CRUD operations for the **escolaridade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escolaridades
    * const escolaridades = await prisma.escolaridade.findMany()
    * ```
    */
  get escolaridade(): Prisma.escolaridadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pessoa`: Exposes CRUD operations for the **pessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pessoas
    * const pessoas = await prisma.pessoa.findMany()
    * ```
    */
  get pessoa(): Prisma.pessoaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoPessoa`: Exposes CRUD operations for the **tipoPessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoPessoas
    * const tipoPessoas = await prisma.tipoPessoa.findMany()
    * ```
    */
  get tipoPessoa(): Prisma.tipoPessoaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pessoaEndereco`: Exposes CRUD operations for the **pessoaEndereco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PessoaEnderecos
    * const pessoaEnderecos = await prisma.pessoaEndereco.findMany()
    * ```
    */
  get pessoaEndereco(): Prisma.pessoaEnderecoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pessoaCasal`: Exposes CRUD operations for the **pessoaCasal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PessoaCasals
    * const pessoaCasals = await prisma.pessoaCasal.findMany()
    * ```
    */
  get pessoaCasal(): Prisma.pessoaCasalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pessoaCarisma`: Exposes CRUD operations for the **pessoaCarisma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PessoaCarismas
    * const pessoaCarismas = await prisma.pessoaCarisma.findMany()
    * ```
    */
  get pessoaCarisma(): Prisma.pessoaCarismaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passaportePessoa`: Exposes CRUD operations for the **passaportePessoa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PassaportePessoas
    * const passaportePessoas = await prisma.passaportePessoa.findMany()
    * ```
    */
  get passaportePessoa(): Prisma.passaportePessoaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pessoaContato`: Exposes CRUD operations for the **pessoaContato** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PessoaContatoes
    * const pessoaContatoes = await prisma.pessoaContato.findMany()
    * ```
    */
  get pessoaContato(): Prisma.pessoaContatoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoDiocese`: Exposes CRUD operations for the **tipoDiocese** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoDiocese
    * const tipoDiocese = await prisma.tipoDiocese.findMany()
    * ```
    */
  get tipoDiocese(): Prisma.tipoDioceseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.diocese`: Exposes CRUD operations for the **diocese** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diocese
    * const diocese = await prisma.diocese.findMany()
    * ```
    */
  get diocese(): Prisma.dioceseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paroquia`: Exposes CRUD operations for the **paroquia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Paroquias
    * const paroquias = await prisma.paroquia.findMany()
    * ```
    */
  get paroquia(): Prisma.paroquiaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paroquiaPessoas`: Exposes CRUD operations for the **paroquiaPessoas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParoquiaPessoas
    * const paroquiaPessoas = await prisma.paroquiaPessoas.findMany()
    * ```
    */
  get paroquiaPessoas(): Prisma.paroquiaPessoasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.etapa`: Exposes CRUD operations for the **etapa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etapas
    * const etapas = await prisma.etapa.findMany()
    * ```
    */
  get etapa(): Prisma.etapaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regiao`: Exposes CRUD operations for the **regiao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regiaos
    * const regiaos = await prisma.regiao.findMany()
    * ```
    */
  get regiao(): Prisma.regiaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoEquipe`: Exposes CRUD operations for the **tipoEquipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoEquipes
    * const tipoEquipes = await prisma.tipoEquipe.findMany()
    * ```
    */
  get tipoEquipe(): Prisma.tipoEquipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipe`: Exposes CRUD operations for the **equipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipes
    * const equipes = await prisma.equipe.findMany()
    * ```
    */
  get equipe(): Prisma.equipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipeTipoEquipe`: Exposes CRUD operations for the **equipeTipoEquipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipeTipoEquipes
    * const equipeTipoEquipes = await prisma.equipeTipoEquipe.findMany()
    * ```
    */
  get equipeTipoEquipe(): Prisma.equipeTipoEquipeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipeRegiao`: Exposes CRUD operations for the **equipeRegiao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipeRegiaos
    * const equipeRegiaos = await prisma.equipeRegiao.findMany()
    * ```
    */
  get equipeRegiao(): Prisma.equipeRegiaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipePessoas`: Exposes CRUD operations for the **equipePessoas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipePessoas
    * const equipePessoas = await prisma.equipePessoas.findMany()
    * ```
    */
  get equipePessoas(): Prisma.equipePessoasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.localidade`: Exposes CRUD operations for the **localidade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Localidades
    * const localidades = await prisma.localidade.findMany()
    * ```
    */
  get localidade(): Prisma.localidadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.localidadeRegiao`: Exposes CRUD operations for the **localidadeRegiao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalidadeRegiaos
    * const localidadeRegiaos = await prisma.localidadeRegiao.findMany()
    * ```
    */
  get localidadeRegiao(): Prisma.localidadeRegiaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoLocalidade`: Exposes CRUD operations for the **tipoLocalidade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoLocalidades
    * const tipoLocalidades = await prisma.tipoLocalidade.findMany()
    * ```
    */
  get tipoLocalidade(): Prisma.tipoLocalidadeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    pais: 'pais',
    estado: 'estado',
    cidade: 'cidade',
    endereco: 'endereco',
    tipoCarisma: 'tipoCarisma',
    estadoCivil: 'estadoCivil',
    escolaridade: 'escolaridade',
    pessoa: 'pessoa',
    tipoPessoa: 'tipoPessoa',
    pessoaEndereco: 'pessoaEndereco',
    pessoaCasal: 'pessoaCasal',
    pessoaCarisma: 'pessoaCarisma',
    passaportePessoa: 'passaportePessoa',
    pessoaContato: 'pessoaContato',
    tipoDiocese: 'tipoDiocese',
    diocese: 'diocese',
    paroquia: 'paroquia',
    paroquiaPessoas: 'paroquiaPessoas',
    etapa: 'etapa',
    regiao: 'regiao',
    tipoEquipe: 'tipoEquipe',
    equipe: 'equipe',
    equipeTipoEquipe: 'equipeTipoEquipe',
    equipeRegiao: 'equipeRegiao',
    equipePessoas: 'equipePessoas',
    localidade: 'localidade',
    localidadeRegiao: 'localidadeRegiao',
    tipoLocalidade: 'tipoLocalidade',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "pais" | "estado" | "cidade" | "endereco" | "tipoCarisma" | "estadoCivil" | "escolaridade" | "pessoa" | "tipoPessoa" | "pessoaEndereco" | "pessoaCasal" | "pessoaCarisma" | "passaportePessoa" | "pessoaContato" | "tipoDiocese" | "diocese" | "paroquia" | "paroquiaPessoas" | "etapa" | "regiao" | "tipoEquipe" | "equipe" | "equipeTipoEquipe" | "equipeRegiao" | "equipePessoas" | "localidade" | "localidadeRegiao" | "tipoLocalidade" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      pais: {
        payload: Prisma.$paisPayload<ExtArgs>
        fields: Prisma.paisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          findFirst: {
            args: Prisma.paisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          findMany: {
            args: Prisma.paisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>[]
          }
          create: {
            args: Prisma.paisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          createMany: {
            args: Prisma.paisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>[]
          }
          delete: {
            args: Prisma.paisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          update: {
            args: Prisma.paisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          deleteMany: {
            args: Prisma.paisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>[]
          }
          upsert: {
            args: Prisma.paisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paisPayload>
          }
          aggregate: {
            args: Prisma.PaisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePais>
          }
          groupBy: {
            args: Prisma.paisGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaisGroupByOutputType>[]
          }
          count: {
            args: Prisma.paisCountArgs<ExtArgs>
            result: $Utils.Optional<PaisCountAggregateOutputType> | number
          }
        }
      }
      estado: {
        payload: Prisma.$estadoPayload<ExtArgs>
        fields: Prisma.estadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload>
          }
          findFirst: {
            args: Prisma.estadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload>
          }
          findMany: {
            args: Prisma.estadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload>[]
          }
          create: {
            args: Prisma.estadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload>
          }
          createMany: {
            args: Prisma.estadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.estadoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload>[]
          }
          delete: {
            args: Prisma.estadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload>
          }
          update: {
            args: Prisma.estadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload>
          }
          deleteMany: {
            args: Prisma.estadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.estadoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload>[]
          }
          upsert: {
            args: Prisma.estadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoPayload>
          }
          aggregate: {
            args: Prisma.EstadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstado>
          }
          groupBy: {
            args: Prisma.estadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.estadoCountArgs<ExtArgs>
            result: $Utils.Optional<EstadoCountAggregateOutputType> | number
          }
        }
      }
      cidade: {
        payload: Prisma.$cidadePayload<ExtArgs>
        fields: Prisma.cidadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cidadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cidadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>
          }
          findFirst: {
            args: Prisma.cidadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cidadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>
          }
          findMany: {
            args: Prisma.cidadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>[]
          }
          create: {
            args: Prisma.cidadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>
          }
          createMany: {
            args: Prisma.cidadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cidadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>[]
          }
          delete: {
            args: Prisma.cidadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>
          }
          update: {
            args: Prisma.cidadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>
          }
          deleteMany: {
            args: Prisma.cidadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cidadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cidadeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>[]
          }
          upsert: {
            args: Prisma.cidadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cidadePayload>
          }
          aggregate: {
            args: Prisma.CidadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCidade>
          }
          groupBy: {
            args: Prisma.cidadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CidadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.cidadeCountArgs<ExtArgs>
            result: $Utils.Optional<CidadeCountAggregateOutputType> | number
          }
        }
      }
      endereco: {
        payload: Prisma.$enderecoPayload<ExtArgs>
        fields: Prisma.enderecoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.enderecoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.enderecoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          findFirst: {
            args: Prisma.enderecoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.enderecoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          findMany: {
            args: Prisma.enderecoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>[]
          }
          create: {
            args: Prisma.enderecoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          createMany: {
            args: Prisma.enderecoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.enderecoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>[]
          }
          delete: {
            args: Prisma.enderecoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          update: {
            args: Prisma.enderecoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          deleteMany: {
            args: Prisma.enderecoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.enderecoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.enderecoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>[]
          }
          upsert: {
            args: Prisma.enderecoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enderecoPayload>
          }
          aggregate: {
            args: Prisma.EnderecoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEndereco>
          }
          groupBy: {
            args: Prisma.enderecoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnderecoGroupByOutputType>[]
          }
          count: {
            args: Prisma.enderecoCountArgs<ExtArgs>
            result: $Utils.Optional<EnderecoCountAggregateOutputType> | number
          }
        }
      }
      tipoCarisma: {
        payload: Prisma.$tipoCarismaPayload<ExtArgs>
        fields: Prisma.tipoCarismaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipoCarismaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipoCarismaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload>
          }
          findFirst: {
            args: Prisma.tipoCarismaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipoCarismaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload>
          }
          findMany: {
            args: Prisma.tipoCarismaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload>[]
          }
          create: {
            args: Prisma.tipoCarismaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload>
          }
          createMany: {
            args: Prisma.tipoCarismaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tipoCarismaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload>[]
          }
          delete: {
            args: Prisma.tipoCarismaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload>
          }
          update: {
            args: Prisma.tipoCarismaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload>
          }
          deleteMany: {
            args: Prisma.tipoCarismaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipoCarismaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tipoCarismaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload>[]
          }
          upsert: {
            args: Prisma.tipoCarismaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoCarismaPayload>
          }
          aggregate: {
            args: Prisma.TipoCarismaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoCarisma>
          }
          groupBy: {
            args: Prisma.tipoCarismaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoCarismaGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipoCarismaCountArgs<ExtArgs>
            result: $Utils.Optional<TipoCarismaCountAggregateOutputType> | number
          }
        }
      }
      estadoCivil: {
        payload: Prisma.$estadoCivilPayload<ExtArgs>
        fields: Prisma.estadoCivilFieldRefs
        operations: {
          findUnique: {
            args: Prisma.estadoCivilFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.estadoCivilFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload>
          }
          findFirst: {
            args: Prisma.estadoCivilFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.estadoCivilFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload>
          }
          findMany: {
            args: Prisma.estadoCivilFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload>[]
          }
          create: {
            args: Prisma.estadoCivilCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload>
          }
          createMany: {
            args: Prisma.estadoCivilCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.estadoCivilCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload>[]
          }
          delete: {
            args: Prisma.estadoCivilDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload>
          }
          update: {
            args: Prisma.estadoCivilUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload>
          }
          deleteMany: {
            args: Prisma.estadoCivilDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.estadoCivilUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.estadoCivilUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload>[]
          }
          upsert: {
            args: Prisma.estadoCivilUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$estadoCivilPayload>
          }
          aggregate: {
            args: Prisma.EstadoCivilAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEstadoCivil>
          }
          groupBy: {
            args: Prisma.estadoCivilGroupByArgs<ExtArgs>
            result: $Utils.Optional<EstadoCivilGroupByOutputType>[]
          }
          count: {
            args: Prisma.estadoCivilCountArgs<ExtArgs>
            result: $Utils.Optional<EstadoCivilCountAggregateOutputType> | number
          }
        }
      }
      escolaridade: {
        payload: Prisma.$escolaridadePayload<ExtArgs>
        fields: Prisma.escolaridadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.escolaridadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.escolaridadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload>
          }
          findFirst: {
            args: Prisma.escolaridadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.escolaridadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload>
          }
          findMany: {
            args: Prisma.escolaridadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload>[]
          }
          create: {
            args: Prisma.escolaridadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload>
          }
          createMany: {
            args: Prisma.escolaridadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.escolaridadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload>[]
          }
          delete: {
            args: Prisma.escolaridadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload>
          }
          update: {
            args: Prisma.escolaridadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload>
          }
          deleteMany: {
            args: Prisma.escolaridadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.escolaridadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.escolaridadeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload>[]
          }
          upsert: {
            args: Prisma.escolaridadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escolaridadePayload>
          }
          aggregate: {
            args: Prisma.EscolaridadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscolaridade>
          }
          groupBy: {
            args: Prisma.escolaridadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EscolaridadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.escolaridadeCountArgs<ExtArgs>
            result: $Utils.Optional<EscolaridadeCountAggregateOutputType> | number
          }
        }
      }
      pessoa: {
        payload: Prisma.$pessoaPayload<ExtArgs>
        fields: Prisma.pessoaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pessoaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pessoaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          findFirst: {
            args: Prisma.pessoaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pessoaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          findMany: {
            args: Prisma.pessoaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>[]
          }
          create: {
            args: Prisma.pessoaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          createMany: {
            args: Prisma.pessoaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pessoaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>[]
          }
          delete: {
            args: Prisma.pessoaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          update: {
            args: Prisma.pessoaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          deleteMany: {
            args: Prisma.pessoaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pessoaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pessoaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>[]
          }
          upsert: {
            args: Prisma.pessoaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaPayload>
          }
          aggregate: {
            args: Prisma.PessoaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoa>
          }
          groupBy: {
            args: Prisma.pessoaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaGroupByOutputType>[]
          }
          count: {
            args: Prisma.pessoaCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaCountAggregateOutputType> | number
          }
        }
      }
      tipoPessoa: {
        payload: Prisma.$tipoPessoaPayload<ExtArgs>
        fields: Prisma.tipoPessoaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipoPessoaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipoPessoaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload>
          }
          findFirst: {
            args: Prisma.tipoPessoaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipoPessoaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload>
          }
          findMany: {
            args: Prisma.tipoPessoaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload>[]
          }
          create: {
            args: Prisma.tipoPessoaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload>
          }
          createMany: {
            args: Prisma.tipoPessoaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tipoPessoaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload>[]
          }
          delete: {
            args: Prisma.tipoPessoaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload>
          }
          update: {
            args: Prisma.tipoPessoaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload>
          }
          deleteMany: {
            args: Prisma.tipoPessoaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipoPessoaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tipoPessoaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload>[]
          }
          upsert: {
            args: Prisma.tipoPessoaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoPessoaPayload>
          }
          aggregate: {
            args: Prisma.TipoPessoaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoPessoa>
          }
          groupBy: {
            args: Prisma.tipoPessoaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoPessoaGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipoPessoaCountArgs<ExtArgs>
            result: $Utils.Optional<TipoPessoaCountAggregateOutputType> | number
          }
        }
      }
      pessoaEndereco: {
        payload: Prisma.$pessoaEnderecoPayload<ExtArgs>
        fields: Prisma.pessoaEnderecoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pessoaEnderecoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pessoaEnderecoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload>
          }
          findFirst: {
            args: Prisma.pessoaEnderecoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pessoaEnderecoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload>
          }
          findMany: {
            args: Prisma.pessoaEnderecoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload>[]
          }
          create: {
            args: Prisma.pessoaEnderecoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload>
          }
          createMany: {
            args: Prisma.pessoaEnderecoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pessoaEnderecoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload>[]
          }
          delete: {
            args: Prisma.pessoaEnderecoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload>
          }
          update: {
            args: Prisma.pessoaEnderecoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload>
          }
          deleteMany: {
            args: Prisma.pessoaEnderecoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pessoaEnderecoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pessoaEnderecoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload>[]
          }
          upsert: {
            args: Prisma.pessoaEnderecoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaEnderecoPayload>
          }
          aggregate: {
            args: Prisma.PessoaEnderecoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoaEndereco>
          }
          groupBy: {
            args: Prisma.pessoaEnderecoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaEnderecoGroupByOutputType>[]
          }
          count: {
            args: Prisma.pessoaEnderecoCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaEnderecoCountAggregateOutputType> | number
          }
        }
      }
      pessoaCasal: {
        payload: Prisma.$pessoaCasalPayload<ExtArgs>
        fields: Prisma.pessoaCasalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pessoaCasalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pessoaCasalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload>
          }
          findFirst: {
            args: Prisma.pessoaCasalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pessoaCasalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload>
          }
          findMany: {
            args: Prisma.pessoaCasalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload>[]
          }
          create: {
            args: Prisma.pessoaCasalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload>
          }
          createMany: {
            args: Prisma.pessoaCasalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pessoaCasalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload>[]
          }
          delete: {
            args: Prisma.pessoaCasalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload>
          }
          update: {
            args: Prisma.pessoaCasalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload>
          }
          deleteMany: {
            args: Prisma.pessoaCasalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pessoaCasalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pessoaCasalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload>[]
          }
          upsert: {
            args: Prisma.pessoaCasalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCasalPayload>
          }
          aggregate: {
            args: Prisma.PessoaCasalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoaCasal>
          }
          groupBy: {
            args: Prisma.pessoaCasalGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaCasalGroupByOutputType>[]
          }
          count: {
            args: Prisma.pessoaCasalCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaCasalCountAggregateOutputType> | number
          }
        }
      }
      pessoaCarisma: {
        payload: Prisma.$pessoaCarismaPayload<ExtArgs>
        fields: Prisma.pessoaCarismaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pessoaCarismaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pessoaCarismaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload>
          }
          findFirst: {
            args: Prisma.pessoaCarismaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pessoaCarismaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload>
          }
          findMany: {
            args: Prisma.pessoaCarismaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload>[]
          }
          create: {
            args: Prisma.pessoaCarismaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload>
          }
          createMany: {
            args: Prisma.pessoaCarismaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pessoaCarismaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload>[]
          }
          delete: {
            args: Prisma.pessoaCarismaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload>
          }
          update: {
            args: Prisma.pessoaCarismaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload>
          }
          deleteMany: {
            args: Prisma.pessoaCarismaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pessoaCarismaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pessoaCarismaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload>[]
          }
          upsert: {
            args: Prisma.pessoaCarismaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaCarismaPayload>
          }
          aggregate: {
            args: Prisma.PessoaCarismaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoaCarisma>
          }
          groupBy: {
            args: Prisma.pessoaCarismaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaCarismaGroupByOutputType>[]
          }
          count: {
            args: Prisma.pessoaCarismaCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaCarismaCountAggregateOutputType> | number
          }
        }
      }
      passaportePessoa: {
        payload: Prisma.$passaportePessoaPayload<ExtArgs>
        fields: Prisma.passaportePessoaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.passaportePessoaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.passaportePessoaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload>
          }
          findFirst: {
            args: Prisma.passaportePessoaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.passaportePessoaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload>
          }
          findMany: {
            args: Prisma.passaportePessoaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload>[]
          }
          create: {
            args: Prisma.passaportePessoaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload>
          }
          createMany: {
            args: Prisma.passaportePessoaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.passaportePessoaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload>[]
          }
          delete: {
            args: Prisma.passaportePessoaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload>
          }
          update: {
            args: Prisma.passaportePessoaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload>
          }
          deleteMany: {
            args: Prisma.passaportePessoaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.passaportePessoaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.passaportePessoaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload>[]
          }
          upsert: {
            args: Prisma.passaportePessoaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$passaportePessoaPayload>
          }
          aggregate: {
            args: Prisma.PassaportePessoaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassaportePessoa>
          }
          groupBy: {
            args: Prisma.passaportePessoaGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassaportePessoaGroupByOutputType>[]
          }
          count: {
            args: Prisma.passaportePessoaCountArgs<ExtArgs>
            result: $Utils.Optional<PassaportePessoaCountAggregateOutputType> | number
          }
        }
      }
      pessoaContato: {
        payload: Prisma.$pessoaContatoPayload<ExtArgs>
        fields: Prisma.pessoaContatoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.pessoaContatoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.pessoaContatoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload>
          }
          findFirst: {
            args: Prisma.pessoaContatoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.pessoaContatoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload>
          }
          findMany: {
            args: Prisma.pessoaContatoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload>[]
          }
          create: {
            args: Prisma.pessoaContatoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload>
          }
          createMany: {
            args: Prisma.pessoaContatoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.pessoaContatoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload>[]
          }
          delete: {
            args: Prisma.pessoaContatoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload>
          }
          update: {
            args: Prisma.pessoaContatoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload>
          }
          deleteMany: {
            args: Prisma.pessoaContatoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.pessoaContatoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.pessoaContatoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload>[]
          }
          upsert: {
            args: Prisma.pessoaContatoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$pessoaContatoPayload>
          }
          aggregate: {
            args: Prisma.PessoaContatoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePessoaContato>
          }
          groupBy: {
            args: Prisma.pessoaContatoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PessoaContatoGroupByOutputType>[]
          }
          count: {
            args: Prisma.pessoaContatoCountArgs<ExtArgs>
            result: $Utils.Optional<PessoaContatoCountAggregateOutputType> | number
          }
        }
      }
      tipoDiocese: {
        payload: Prisma.$tipoDiocesePayload<ExtArgs>
        fields: Prisma.tipoDioceseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipoDioceseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipoDioceseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload>
          }
          findFirst: {
            args: Prisma.tipoDioceseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipoDioceseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload>
          }
          findMany: {
            args: Prisma.tipoDioceseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload>[]
          }
          create: {
            args: Prisma.tipoDioceseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload>
          }
          createMany: {
            args: Prisma.tipoDioceseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tipoDioceseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload>[]
          }
          delete: {
            args: Prisma.tipoDioceseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload>
          }
          update: {
            args: Prisma.tipoDioceseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload>
          }
          deleteMany: {
            args: Prisma.tipoDioceseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipoDioceseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tipoDioceseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload>[]
          }
          upsert: {
            args: Prisma.tipoDioceseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoDiocesePayload>
          }
          aggregate: {
            args: Prisma.TipoDioceseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoDiocese>
          }
          groupBy: {
            args: Prisma.tipoDioceseGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoDioceseGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipoDioceseCountArgs<ExtArgs>
            result: $Utils.Optional<TipoDioceseCountAggregateOutputType> | number
          }
        }
      }
      diocese: {
        payload: Prisma.$diocesePayload<ExtArgs>
        fields: Prisma.dioceseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dioceseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dioceseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload>
          }
          findFirst: {
            args: Prisma.dioceseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dioceseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload>
          }
          findMany: {
            args: Prisma.dioceseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload>[]
          }
          create: {
            args: Prisma.dioceseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload>
          }
          createMany: {
            args: Prisma.dioceseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.dioceseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload>[]
          }
          delete: {
            args: Prisma.dioceseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload>
          }
          update: {
            args: Prisma.dioceseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload>
          }
          deleteMany: {
            args: Prisma.dioceseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dioceseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.dioceseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload>[]
          }
          upsert: {
            args: Prisma.dioceseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$diocesePayload>
          }
          aggregate: {
            args: Prisma.DioceseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiocese>
          }
          groupBy: {
            args: Prisma.dioceseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DioceseGroupByOutputType>[]
          }
          count: {
            args: Prisma.dioceseCountArgs<ExtArgs>
            result: $Utils.Optional<DioceseCountAggregateOutputType> | number
          }
        }
      }
      paroquia: {
        payload: Prisma.$paroquiaPayload<ExtArgs>
        fields: Prisma.paroquiaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paroquiaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paroquiaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload>
          }
          findFirst: {
            args: Prisma.paroquiaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paroquiaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload>
          }
          findMany: {
            args: Prisma.paroquiaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload>[]
          }
          create: {
            args: Prisma.paroquiaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload>
          }
          createMany: {
            args: Prisma.paroquiaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paroquiaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload>[]
          }
          delete: {
            args: Prisma.paroquiaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload>
          }
          update: {
            args: Prisma.paroquiaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload>
          }
          deleteMany: {
            args: Prisma.paroquiaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paroquiaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paroquiaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload>[]
          }
          upsert: {
            args: Prisma.paroquiaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPayload>
          }
          aggregate: {
            args: Prisma.ParoquiaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParoquia>
          }
          groupBy: {
            args: Prisma.paroquiaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParoquiaGroupByOutputType>[]
          }
          count: {
            args: Prisma.paroquiaCountArgs<ExtArgs>
            result: $Utils.Optional<ParoquiaCountAggregateOutputType> | number
          }
        }
      }
      paroquiaPessoas: {
        payload: Prisma.$paroquiaPessoasPayload<ExtArgs>
        fields: Prisma.paroquiaPessoasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paroquiaPessoasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paroquiaPessoasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload>
          }
          findFirst: {
            args: Prisma.paroquiaPessoasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paroquiaPessoasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload>
          }
          findMany: {
            args: Prisma.paroquiaPessoasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload>[]
          }
          create: {
            args: Prisma.paroquiaPessoasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload>
          }
          createMany: {
            args: Prisma.paroquiaPessoasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paroquiaPessoasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload>[]
          }
          delete: {
            args: Prisma.paroquiaPessoasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload>
          }
          update: {
            args: Prisma.paroquiaPessoasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload>
          }
          deleteMany: {
            args: Prisma.paroquiaPessoasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paroquiaPessoasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paroquiaPessoasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload>[]
          }
          upsert: {
            args: Prisma.paroquiaPessoasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paroquiaPessoasPayload>
          }
          aggregate: {
            args: Prisma.ParoquiaPessoasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParoquiaPessoas>
          }
          groupBy: {
            args: Prisma.paroquiaPessoasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParoquiaPessoasGroupByOutputType>[]
          }
          count: {
            args: Prisma.paroquiaPessoasCountArgs<ExtArgs>
            result: $Utils.Optional<ParoquiaPessoasCountAggregateOutputType> | number
          }
        }
      }
      etapa: {
        payload: Prisma.$etapaPayload<ExtArgs>
        fields: Prisma.etapaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.etapaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.etapaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload>
          }
          findFirst: {
            args: Prisma.etapaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.etapaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload>
          }
          findMany: {
            args: Prisma.etapaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload>[]
          }
          create: {
            args: Prisma.etapaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload>
          }
          createMany: {
            args: Prisma.etapaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.etapaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload>[]
          }
          delete: {
            args: Prisma.etapaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload>
          }
          update: {
            args: Prisma.etapaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload>
          }
          deleteMany: {
            args: Prisma.etapaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.etapaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.etapaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload>[]
          }
          upsert: {
            args: Prisma.etapaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etapaPayload>
          }
          aggregate: {
            args: Prisma.EtapaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtapa>
          }
          groupBy: {
            args: Prisma.etapaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtapaGroupByOutputType>[]
          }
          count: {
            args: Prisma.etapaCountArgs<ExtArgs>
            result: $Utils.Optional<EtapaCountAggregateOutputType> | number
          }
        }
      }
      regiao: {
        payload: Prisma.$regiaoPayload<ExtArgs>
        fields: Prisma.regiaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.regiaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.regiaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload>
          }
          findFirst: {
            args: Prisma.regiaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.regiaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload>
          }
          findMany: {
            args: Prisma.regiaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload>[]
          }
          create: {
            args: Prisma.regiaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload>
          }
          createMany: {
            args: Prisma.regiaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.regiaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload>[]
          }
          delete: {
            args: Prisma.regiaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload>
          }
          update: {
            args: Prisma.regiaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload>
          }
          deleteMany: {
            args: Prisma.regiaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.regiaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.regiaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload>[]
          }
          upsert: {
            args: Prisma.regiaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regiaoPayload>
          }
          aggregate: {
            args: Prisma.RegiaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegiao>
          }
          groupBy: {
            args: Prisma.regiaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegiaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.regiaoCountArgs<ExtArgs>
            result: $Utils.Optional<RegiaoCountAggregateOutputType> | number
          }
        }
      }
      tipoEquipe: {
        payload: Prisma.$tipoEquipePayload<ExtArgs>
        fields: Prisma.tipoEquipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipoEquipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipoEquipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload>
          }
          findFirst: {
            args: Prisma.tipoEquipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipoEquipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload>
          }
          findMany: {
            args: Prisma.tipoEquipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload>[]
          }
          create: {
            args: Prisma.tipoEquipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload>
          }
          createMany: {
            args: Prisma.tipoEquipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tipoEquipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload>[]
          }
          delete: {
            args: Prisma.tipoEquipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload>
          }
          update: {
            args: Prisma.tipoEquipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload>
          }
          deleteMany: {
            args: Prisma.tipoEquipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipoEquipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tipoEquipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload>[]
          }
          upsert: {
            args: Prisma.tipoEquipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoEquipePayload>
          }
          aggregate: {
            args: Prisma.TipoEquipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoEquipe>
          }
          groupBy: {
            args: Prisma.tipoEquipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoEquipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipoEquipeCountArgs<ExtArgs>
            result: $Utils.Optional<TipoEquipeCountAggregateOutputType> | number
          }
        }
      }
      equipe: {
        payload: Prisma.$equipePayload<ExtArgs>
        fields: Prisma.equipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload>
          }
          findFirst: {
            args: Prisma.equipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload>
          }
          findMany: {
            args: Prisma.equipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload>[]
          }
          create: {
            args: Prisma.equipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload>
          }
          createMany: {
            args: Prisma.equipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.equipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload>[]
          }
          delete: {
            args: Prisma.equipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload>
          }
          update: {
            args: Prisma.equipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload>
          }
          deleteMany: {
            args: Prisma.equipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.equipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.equipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload>[]
          }
          upsert: {
            args: Prisma.equipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePayload>
          }
          aggregate: {
            args: Prisma.EquipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipe>
          }
          groupBy: {
            args: Prisma.equipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipeCountArgs<ExtArgs>
            result: $Utils.Optional<EquipeCountAggregateOutputType> | number
          }
        }
      }
      equipeTipoEquipe: {
        payload: Prisma.$equipeTipoEquipePayload<ExtArgs>
        fields: Prisma.equipeTipoEquipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipeTipoEquipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipeTipoEquipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload>
          }
          findFirst: {
            args: Prisma.equipeTipoEquipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipeTipoEquipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload>
          }
          findMany: {
            args: Prisma.equipeTipoEquipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload>[]
          }
          create: {
            args: Prisma.equipeTipoEquipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload>
          }
          createMany: {
            args: Prisma.equipeTipoEquipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.equipeTipoEquipeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload>[]
          }
          delete: {
            args: Prisma.equipeTipoEquipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload>
          }
          update: {
            args: Prisma.equipeTipoEquipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload>
          }
          deleteMany: {
            args: Prisma.equipeTipoEquipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.equipeTipoEquipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.equipeTipoEquipeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload>[]
          }
          upsert: {
            args: Prisma.equipeTipoEquipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeTipoEquipePayload>
          }
          aggregate: {
            args: Prisma.EquipeTipoEquipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipeTipoEquipe>
          }
          groupBy: {
            args: Prisma.equipeTipoEquipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipeTipoEquipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipeTipoEquipeCountArgs<ExtArgs>
            result: $Utils.Optional<EquipeTipoEquipeCountAggregateOutputType> | number
          }
        }
      }
      equipeRegiao: {
        payload: Prisma.$equipeRegiaoPayload<ExtArgs>
        fields: Prisma.equipeRegiaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipeRegiaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipeRegiaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload>
          }
          findFirst: {
            args: Prisma.equipeRegiaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipeRegiaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload>
          }
          findMany: {
            args: Prisma.equipeRegiaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload>[]
          }
          create: {
            args: Prisma.equipeRegiaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload>
          }
          createMany: {
            args: Prisma.equipeRegiaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.equipeRegiaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload>[]
          }
          delete: {
            args: Prisma.equipeRegiaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload>
          }
          update: {
            args: Prisma.equipeRegiaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload>
          }
          deleteMany: {
            args: Prisma.equipeRegiaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.equipeRegiaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.equipeRegiaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload>[]
          }
          upsert: {
            args: Prisma.equipeRegiaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipeRegiaoPayload>
          }
          aggregate: {
            args: Prisma.EquipeRegiaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipeRegiao>
          }
          groupBy: {
            args: Prisma.equipeRegiaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipeRegiaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipeRegiaoCountArgs<ExtArgs>
            result: $Utils.Optional<EquipeRegiaoCountAggregateOutputType> | number
          }
        }
      }
      equipePessoas: {
        payload: Prisma.$equipePessoasPayload<ExtArgs>
        fields: Prisma.equipePessoasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.equipePessoasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.equipePessoasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload>
          }
          findFirst: {
            args: Prisma.equipePessoasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.equipePessoasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload>
          }
          findMany: {
            args: Prisma.equipePessoasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload>[]
          }
          create: {
            args: Prisma.equipePessoasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload>
          }
          createMany: {
            args: Prisma.equipePessoasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.equipePessoasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload>[]
          }
          delete: {
            args: Prisma.equipePessoasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload>
          }
          update: {
            args: Prisma.equipePessoasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload>
          }
          deleteMany: {
            args: Prisma.equipePessoasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.equipePessoasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.equipePessoasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload>[]
          }
          upsert: {
            args: Prisma.equipePessoasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$equipePessoasPayload>
          }
          aggregate: {
            args: Prisma.EquipePessoasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipePessoas>
          }
          groupBy: {
            args: Prisma.equipePessoasGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipePessoasGroupByOutputType>[]
          }
          count: {
            args: Prisma.equipePessoasCountArgs<ExtArgs>
            result: $Utils.Optional<EquipePessoasCountAggregateOutputType> | number
          }
        }
      }
      localidade: {
        payload: Prisma.$localidadePayload<ExtArgs>
        fields: Prisma.localidadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.localidadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.localidadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload>
          }
          findFirst: {
            args: Prisma.localidadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.localidadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload>
          }
          findMany: {
            args: Prisma.localidadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload>[]
          }
          create: {
            args: Prisma.localidadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload>
          }
          createMany: {
            args: Prisma.localidadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.localidadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload>[]
          }
          delete: {
            args: Prisma.localidadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload>
          }
          update: {
            args: Prisma.localidadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload>
          }
          deleteMany: {
            args: Prisma.localidadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.localidadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.localidadeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload>[]
          }
          upsert: {
            args: Prisma.localidadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadePayload>
          }
          aggregate: {
            args: Prisma.LocalidadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalidade>
          }
          groupBy: {
            args: Prisma.localidadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalidadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.localidadeCountArgs<ExtArgs>
            result: $Utils.Optional<LocalidadeCountAggregateOutputType> | number
          }
        }
      }
      localidadeRegiao: {
        payload: Prisma.$localidadeRegiaoPayload<ExtArgs>
        fields: Prisma.localidadeRegiaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.localidadeRegiaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.localidadeRegiaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload>
          }
          findFirst: {
            args: Prisma.localidadeRegiaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.localidadeRegiaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload>
          }
          findMany: {
            args: Prisma.localidadeRegiaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload>[]
          }
          create: {
            args: Prisma.localidadeRegiaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload>
          }
          createMany: {
            args: Prisma.localidadeRegiaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.localidadeRegiaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload>[]
          }
          delete: {
            args: Prisma.localidadeRegiaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload>
          }
          update: {
            args: Prisma.localidadeRegiaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload>
          }
          deleteMany: {
            args: Prisma.localidadeRegiaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.localidadeRegiaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.localidadeRegiaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload>[]
          }
          upsert: {
            args: Prisma.localidadeRegiaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$localidadeRegiaoPayload>
          }
          aggregate: {
            args: Prisma.LocalidadeRegiaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalidadeRegiao>
          }
          groupBy: {
            args: Prisma.localidadeRegiaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalidadeRegiaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.localidadeRegiaoCountArgs<ExtArgs>
            result: $Utils.Optional<LocalidadeRegiaoCountAggregateOutputType> | number
          }
        }
      }
      tipoLocalidade: {
        payload: Prisma.$tipoLocalidadePayload<ExtArgs>
        fields: Prisma.tipoLocalidadeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tipoLocalidadeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tipoLocalidadeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload>
          }
          findFirst: {
            args: Prisma.tipoLocalidadeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tipoLocalidadeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload>
          }
          findMany: {
            args: Prisma.tipoLocalidadeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload>[]
          }
          create: {
            args: Prisma.tipoLocalidadeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload>
          }
          createMany: {
            args: Prisma.tipoLocalidadeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tipoLocalidadeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload>[]
          }
          delete: {
            args: Prisma.tipoLocalidadeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload>
          }
          update: {
            args: Prisma.tipoLocalidadeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload>
          }
          deleteMany: {
            args: Prisma.tipoLocalidadeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tipoLocalidadeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tipoLocalidadeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload>[]
          }
          upsert: {
            args: Prisma.tipoLocalidadeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tipoLocalidadePayload>
          }
          aggregate: {
            args: Prisma.TipoLocalidadeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoLocalidade>
          }
          groupBy: {
            args: Prisma.tipoLocalidadeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoLocalidadeGroupByOutputType>[]
          }
          count: {
            args: Prisma.tipoLocalidadeCountArgs<ExtArgs>
            result: $Utils.Optional<TipoLocalidadeCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    pais?: paisOmit
    estado?: estadoOmit
    cidade?: cidadeOmit
    endereco?: enderecoOmit
    tipoCarisma?: tipoCarismaOmit
    estadoCivil?: estadoCivilOmit
    escolaridade?: escolaridadeOmit
    pessoa?: pessoaOmit
    tipoPessoa?: tipoPessoaOmit
    pessoaEndereco?: pessoaEnderecoOmit
    pessoaCasal?: pessoaCasalOmit
    pessoaCarisma?: pessoaCarismaOmit
    passaportePessoa?: passaportePessoaOmit
    pessoaContato?: pessoaContatoOmit
    tipoDiocese?: tipoDioceseOmit
    diocese?: dioceseOmit
    paroquia?: paroquiaOmit
    paroquiaPessoas?: paroquiaPessoasOmit
    etapa?: etapaOmit
    regiao?: regiaoOmit
    tipoEquipe?: tipoEquipeOmit
    equipe?: equipeOmit
    equipeTipoEquipe?: equipeTipoEquipeOmit
    equipeRegiao?: equipeRegiaoOmit
    equipePessoas?: equipePessoasOmit
    localidade?: localidadeOmit
    localidadeRegiao?: localidadeRegiaoOmit
    tipoLocalidade?: tipoLocalidadeOmit
    user?: userOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PaisCountOutputType
   */

  export type PaisCountOutputType = {
    estado: number
  }

  export type PaisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado?: boolean | PaisCountOutputTypeCountEstadoArgs
  }

  // Custom InputTypes
  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaisCountOutputType
     */
    select?: PaisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaisCountOutputType without action
   */
  export type PaisCountOutputTypeCountEstadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estadoWhereInput
  }


  /**
   * Count Type EstadoCountOutputType
   */

  export type EstadoCountOutputType = {
    cidade: number
  }

  export type EstadoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cidade?: boolean | EstadoCountOutputTypeCountCidadeArgs
  }

  // Custom InputTypes
  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCountOutputType
     */
    select?: EstadoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstadoCountOutputType without action
   */
  export type EstadoCountOutputTypeCountCidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cidadeWhereInput
  }


  /**
   * Count Type EnderecoCountOutputType
   */

  export type EnderecoCountOutputType = {
    paroquias: number
    pessoas: number
    localidade: number
    diocese: number
  }

  export type EnderecoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paroquias?: boolean | EnderecoCountOutputTypeCountParoquiasArgs
    pessoas?: boolean | EnderecoCountOutputTypeCountPessoasArgs
    localidade?: boolean | EnderecoCountOutputTypeCountLocalidadeArgs
    diocese?: boolean | EnderecoCountOutputTypeCountDioceseArgs
  }

  // Custom InputTypes
  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnderecoCountOutputType
     */
    select?: EnderecoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountParoquiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paroquiaWhereInput
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountPessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaEnderecoWhereInput
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountLocalidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localidadeWhereInput
  }

  /**
   * EnderecoCountOutputType without action
   */
  export type EnderecoCountOutputTypeCountDioceseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dioceseWhereInput
  }


  /**
   * Count Type TipoCarismaCountOutputType
   */

  export type TipoCarismaCountOutputType = {
    pessoaCarisma: number
  }

  export type TipoCarismaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoaCarisma?: boolean | TipoCarismaCountOutputTypeCountPessoaCarismaArgs
  }

  // Custom InputTypes
  /**
   * TipoCarismaCountOutputType without action
   */
  export type TipoCarismaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoCarismaCountOutputType
     */
    select?: TipoCarismaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoCarismaCountOutputType without action
   */
  export type TipoCarismaCountOutputTypeCountPessoaCarismaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaCarismaWhereInput
  }


  /**
   * Count Type EstadoCivilCountOutputType
   */

  export type EstadoCivilCountOutputType = {
    pessoas: number
  }

  export type EstadoCivilCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoas?: boolean | EstadoCivilCountOutputTypeCountPessoasArgs
  }

  // Custom InputTypes
  /**
   * EstadoCivilCountOutputType without action
   */
  export type EstadoCivilCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EstadoCivilCountOutputType
     */
    select?: EstadoCivilCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EstadoCivilCountOutputType without action
   */
  export type EstadoCivilCountOutputTypeCountPessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
  }


  /**
   * Count Type EscolaridadeCountOutputType
   */

  export type EscolaridadeCountOutputType = {
    pessoas: number
  }

  export type EscolaridadeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoas?: boolean | EscolaridadeCountOutputTypeCountPessoasArgs
  }

  // Custom InputTypes
  /**
   * EscolaridadeCountOutputType without action
   */
  export type EscolaridadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EscolaridadeCountOutputType
     */
    select?: EscolaridadeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EscolaridadeCountOutputType without action
   */
  export type EscolaridadeCountOutputTypeCountPessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
  }


  /**
   * Count Type PessoaCountOutputType
   */

  export type PessoaCountOutputType = {
    passaportes: number
    contatos: number
    paroquias: number
    casamentosComoMarido: number
    casamentosComoMulher: number
    enderecos: number
    equipes: number
    pessoaCarisma: number
  }

  export type PessoaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passaportes?: boolean | PessoaCountOutputTypeCountPassaportesArgs
    contatos?: boolean | PessoaCountOutputTypeCountContatosArgs
    paroquias?: boolean | PessoaCountOutputTypeCountParoquiasArgs
    casamentosComoMarido?: boolean | PessoaCountOutputTypeCountCasamentosComoMaridoArgs
    casamentosComoMulher?: boolean | PessoaCountOutputTypeCountCasamentosComoMulherArgs
    enderecos?: boolean | PessoaCountOutputTypeCountEnderecosArgs
    equipes?: boolean | PessoaCountOutputTypeCountEquipesArgs
    pessoaCarisma?: boolean | PessoaCountOutputTypeCountPessoaCarismaArgs
  }

  // Custom InputTypes
  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PessoaCountOutputType
     */
    select?: PessoaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountPassaportesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: passaportePessoaWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountContatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaContatoWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountParoquiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paroquiaPessoasWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountCasamentosComoMaridoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaCasalWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountCasamentosComoMulherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaCasalWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountEnderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaEnderecoWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountEquipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipePessoasWhereInput
  }

  /**
   * PessoaCountOutputType without action
   */
  export type PessoaCountOutputTypeCountPessoaCarismaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaCarismaWhereInput
  }


  /**
   * Count Type TipoPessoaCountOutputType
   */

  export type TipoPessoaCountOutputType = {
    pessoa: number
  }

  export type TipoPessoaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | TipoPessoaCountOutputTypeCountPessoaArgs
  }

  // Custom InputTypes
  /**
   * TipoPessoaCountOutputType without action
   */
  export type TipoPessoaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoPessoaCountOutputType
     */
    select?: TipoPessoaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoPessoaCountOutputType without action
   */
  export type TipoPessoaCountOutputTypeCountPessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
  }


  /**
   * Count Type TipoDioceseCountOutputType
   */

  export type TipoDioceseCountOutputType = {
    dioceses: number
  }

  export type TipoDioceseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dioceses?: boolean | TipoDioceseCountOutputTypeCountDiocesesArgs
  }

  // Custom InputTypes
  /**
   * TipoDioceseCountOutputType without action
   */
  export type TipoDioceseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoDioceseCountOutputType
     */
    select?: TipoDioceseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoDioceseCountOutputType without action
   */
  export type TipoDioceseCountOutputTypeCountDiocesesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dioceseWhereInput
  }


  /**
   * Count Type DioceseCountOutputType
   */

  export type DioceseCountOutputType = {
    paroquias: number
    localidade: number
  }

  export type DioceseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paroquias?: boolean | DioceseCountOutputTypeCountParoquiasArgs
    localidade?: boolean | DioceseCountOutputTypeCountLocalidadeArgs
  }

  // Custom InputTypes
  /**
   * DioceseCountOutputType without action
   */
  export type DioceseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DioceseCountOutputType
     */
    select?: DioceseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DioceseCountOutputType without action
   */
  export type DioceseCountOutputTypeCountParoquiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paroquiaWhereInput
  }

  /**
   * DioceseCountOutputType without action
   */
  export type DioceseCountOutputTypeCountLocalidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localidadeWhereInput
  }


  /**
   * Count Type ParoquiaCountOutputType
   */

  export type ParoquiaCountOutputType = {
    pessoas: number
  }

  export type ParoquiaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoas?: boolean | ParoquiaCountOutputTypeCountPessoasArgs
  }

  // Custom InputTypes
  /**
   * ParoquiaCountOutputType without action
   */
  export type ParoquiaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParoquiaCountOutputType
     */
    select?: ParoquiaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParoquiaCountOutputType without action
   */
  export type ParoquiaCountOutputTypeCountPessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paroquiaPessoasWhereInput
  }


  /**
   * Count Type RegiaoCountOutputType
   */

  export type RegiaoCountOutputType = {
    equipes: number
    localidadeRegiao: number
  }

  export type RegiaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipes?: boolean | RegiaoCountOutputTypeCountEquipesArgs
    localidadeRegiao?: boolean | RegiaoCountOutputTypeCountLocalidadeRegiaoArgs
  }

  // Custom InputTypes
  /**
   * RegiaoCountOutputType without action
   */
  export type RegiaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegiaoCountOutputType
     */
    select?: RegiaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegiaoCountOutputType without action
   */
  export type RegiaoCountOutputTypeCountEquipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipeRegiaoWhereInput
  }

  /**
   * RegiaoCountOutputType without action
   */
  export type RegiaoCountOutputTypeCountLocalidadeRegiaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localidadeRegiaoWhereInput
  }


  /**
   * Count Type TipoEquipeCountOutputType
   */

  export type TipoEquipeCountOutputType = {
    equipes: number
  }

  export type TipoEquipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipes?: boolean | TipoEquipeCountOutputTypeCountEquipesArgs
  }

  // Custom InputTypes
  /**
   * TipoEquipeCountOutputType without action
   */
  export type TipoEquipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEquipeCountOutputType
     */
    select?: TipoEquipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoEquipeCountOutputType without action
   */
  export type TipoEquipeCountOutputTypeCountEquipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipeTipoEquipeWhereInput
  }


  /**
   * Count Type EquipeCountOutputType
   */

  export type EquipeCountOutputType = {
    regioes: number
    equipePessoas: number
    tipos: number
  }

  export type EquipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regioes?: boolean | EquipeCountOutputTypeCountRegioesArgs
    equipePessoas?: boolean | EquipeCountOutputTypeCountEquipePessoasArgs
    tipos?: boolean | EquipeCountOutputTypeCountTiposArgs
  }

  // Custom InputTypes
  /**
   * EquipeCountOutputType without action
   */
  export type EquipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipeCountOutputType
     */
    select?: EquipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipeCountOutputType without action
   */
  export type EquipeCountOutputTypeCountRegioesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipeRegiaoWhereInput
  }

  /**
   * EquipeCountOutputType without action
   */
  export type EquipeCountOutputTypeCountEquipePessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipePessoasWhereInput
  }

  /**
   * EquipeCountOutputType without action
   */
  export type EquipeCountOutputTypeCountTiposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipeTipoEquipeWhereInput
  }


  /**
   * Count Type LocalidadeCountOutputType
   */

  export type LocalidadeCountOutputType = {
    localidadeRegiao: number
  }

  export type LocalidadeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localidadeRegiao?: boolean | LocalidadeCountOutputTypeCountLocalidadeRegiaoArgs
  }

  // Custom InputTypes
  /**
   * LocalidadeCountOutputType without action
   */
  export type LocalidadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalidadeCountOutputType
     */
    select?: LocalidadeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocalidadeCountOutputType without action
   */
  export type LocalidadeCountOutputTypeCountLocalidadeRegiaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localidadeRegiaoWhereInput
  }


  /**
   * Count Type TipoLocalidadeCountOutputType
   */

  export type TipoLocalidadeCountOutputType = {
    localidade: number
  }

  export type TipoLocalidadeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localidade?: boolean | TipoLocalidadeCountOutputTypeCountLocalidadeArgs
  }

  // Custom InputTypes
  /**
   * TipoLocalidadeCountOutputType without action
   */
  export type TipoLocalidadeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoLocalidadeCountOutputType
     */
    select?: TipoLocalidadeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoLocalidadeCountOutputType without action
   */
  export type TipoLocalidadeCountOutputTypeCountLocalidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localidadeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model pais
   */

  export type AggregatePais = {
    _count: PaisCountAggregateOutputType | null
    _avg: PaisAvgAggregateOutputType | null
    _sum: PaisSumAggregateOutputType | null
    _min: PaisMinAggregateOutputType | null
    _max: PaisMaxAggregateOutputType | null
  }

  export type PaisAvgAggregateOutputType = {
    id: number | null
  }

  export type PaisSumAggregateOutputType = {
    id: number | null
  }

  export type PaisMinAggregateOutputType = {
    id: number | null
    isoAlpha2: string | null
    nome: string | null
    regiao: string | null
    subRegiao: string | null
    regiaoIntermediaria: string | null
    lingua: string | null
    capital: string | null
  }

  export type PaisMaxAggregateOutputType = {
    id: number | null
    isoAlpha2: string | null
    nome: string | null
    regiao: string | null
    subRegiao: string | null
    regiaoIntermediaria: string | null
    lingua: string | null
    capital: string | null
  }

  export type PaisCountAggregateOutputType = {
    id: number
    isoAlpha2: number
    nome: number
    regiao: number
    subRegiao: number
    regiaoIntermediaria: number
    lingua: number
    capital: number
    _all: number
  }


  export type PaisAvgAggregateInputType = {
    id?: true
  }

  export type PaisSumAggregateInputType = {
    id?: true
  }

  export type PaisMinAggregateInputType = {
    id?: true
    isoAlpha2?: true
    nome?: true
    regiao?: true
    subRegiao?: true
    regiaoIntermediaria?: true
    lingua?: true
    capital?: true
  }

  export type PaisMaxAggregateInputType = {
    id?: true
    isoAlpha2?: true
    nome?: true
    regiao?: true
    subRegiao?: true
    regiaoIntermediaria?: true
    lingua?: true
    capital?: true
  }

  export type PaisCountAggregateInputType = {
    id?: true
    isoAlpha2?: true
    nome?: true
    regiao?: true
    subRegiao?: true
    regiaoIntermediaria?: true
    lingua?: true
    capital?: true
    _all?: true
  }

  export type PaisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pais to aggregate.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pais
    **/
    _count?: true | PaisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaisMaxAggregateInputType
  }

  export type GetPaisAggregateType<T extends PaisAggregateArgs> = {
        [P in keyof T & keyof AggregatePais]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePais[P]>
      : GetScalarType<T[P], AggregatePais[P]>
  }




  export type paisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paisWhereInput
    orderBy?: paisOrderByWithAggregationInput | paisOrderByWithAggregationInput[]
    by: PaisScalarFieldEnum[] | PaisScalarFieldEnum
    having?: paisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaisCountAggregateInputType | true
    _avg?: PaisAvgAggregateInputType
    _sum?: PaisSumAggregateInputType
    _min?: PaisMinAggregateInputType
    _max?: PaisMaxAggregateInputType
  }

  export type PaisGroupByOutputType = {
    id: number
    isoAlpha2: string
    nome: string
    regiao: string
    subRegiao: string
    regiaoIntermediaria: string | null
    lingua: string
    capital: string
    _count: PaisCountAggregateOutputType | null
    _avg: PaisAvgAggregateOutputType | null
    _sum: PaisSumAggregateOutputType | null
    _min: PaisMinAggregateOutputType | null
    _max: PaisMaxAggregateOutputType | null
  }

  type GetPaisGroupByPayload<T extends paisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaisGroupByOutputType[P]>
            : GetScalarType<T[P], PaisGroupByOutputType[P]>
        }
      >
    >


  export type paisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isoAlpha2?: boolean
    nome?: boolean
    regiao?: boolean
    subRegiao?: boolean
    regiaoIntermediaria?: boolean
    lingua?: boolean
    capital?: boolean
    estado?: boolean | pais$estadoArgs<ExtArgs>
    _count?: boolean | PaisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pais"]>

  export type paisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isoAlpha2?: boolean
    nome?: boolean
    regiao?: boolean
    subRegiao?: boolean
    regiaoIntermediaria?: boolean
    lingua?: boolean
    capital?: boolean
  }, ExtArgs["result"]["pais"]>

  export type paisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isoAlpha2?: boolean
    nome?: boolean
    regiao?: boolean
    subRegiao?: boolean
    regiaoIntermediaria?: boolean
    lingua?: boolean
    capital?: boolean
  }, ExtArgs["result"]["pais"]>

  export type paisSelectScalar = {
    id?: boolean
    isoAlpha2?: boolean
    nome?: boolean
    regiao?: boolean
    subRegiao?: boolean
    regiaoIntermediaria?: boolean
    lingua?: boolean
    capital?: boolean
  }

  export type paisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isoAlpha2" | "nome" | "regiao" | "subRegiao" | "regiaoIntermediaria" | "lingua" | "capital", ExtArgs["result"]["pais"]>
  export type paisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado?: boolean | pais$estadoArgs<ExtArgs>
    _count?: boolean | PaisCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type paisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type paisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $paisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pais"
    objects: {
      estado: Prisma.$estadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      isoAlpha2: string
      nome: string
      regiao: string
      subRegiao: string
      regiaoIntermediaria: string | null
      lingua: string
      capital: string
    }, ExtArgs["result"]["pais"]>
    composites: {}
  }

  type paisGetPayload<S extends boolean | null | undefined | paisDefaultArgs> = $Result.GetResult<Prisma.$paisPayload, S>

  type paisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaisCountAggregateInputType | true
    }

  export interface paisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pais'], meta: { name: 'pais' } }
    /**
     * Find zero or one Pais that matches the filter.
     * @param {paisFindUniqueArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paisFindUniqueArgs>(args: SelectSubset<T, paisFindUniqueArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pais that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paisFindUniqueOrThrowArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paisFindUniqueOrThrowArgs>(args: SelectSubset<T, paisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisFindFirstArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paisFindFirstArgs>(args?: SelectSubset<T, paisFindFirstArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pais that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisFindFirstOrThrowArgs} args - Arguments to find a Pais
     * @example
     * // Get one Pais
     * const pais = await prisma.pais.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paisFindFirstOrThrowArgs>(args?: SelectSubset<T, paisFindFirstOrThrowArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pais
     * const pais = await prisma.pais.findMany()
     * 
     * // Get first 10 Pais
     * const pais = await prisma.pais.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paisWithIdOnly = await prisma.pais.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paisFindManyArgs>(args?: SelectSubset<T, paisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pais.
     * @param {paisCreateArgs} args - Arguments to create a Pais.
     * @example
     * // Create one Pais
     * const Pais = await prisma.pais.create({
     *   data: {
     *     // ... data to create a Pais
     *   }
     * })
     * 
     */
    create<T extends paisCreateArgs>(args: SelectSubset<T, paisCreateArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pais.
     * @param {paisCreateManyArgs} args - Arguments to create many Pais.
     * @example
     * // Create many Pais
     * const pais = await prisma.pais.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paisCreateManyArgs>(args?: SelectSubset<T, paisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pais and returns the data saved in the database.
     * @param {paisCreateManyAndReturnArgs} args - Arguments to create many Pais.
     * @example
     * // Create many Pais
     * const pais = await prisma.pais.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pais and only return the `id`
     * const paisWithIdOnly = await prisma.pais.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paisCreateManyAndReturnArgs>(args?: SelectSubset<T, paisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pais.
     * @param {paisDeleteArgs} args - Arguments to delete one Pais.
     * @example
     * // Delete one Pais
     * const Pais = await prisma.pais.delete({
     *   where: {
     *     // ... filter to delete one Pais
     *   }
     * })
     * 
     */
    delete<T extends paisDeleteArgs>(args: SelectSubset<T, paisDeleteArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pais.
     * @param {paisUpdateArgs} args - Arguments to update one Pais.
     * @example
     * // Update one Pais
     * const pais = await prisma.pais.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paisUpdateArgs>(args: SelectSubset<T, paisUpdateArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pais.
     * @param {paisDeleteManyArgs} args - Arguments to filter Pais to delete.
     * @example
     * // Delete a few Pais
     * const { count } = await prisma.pais.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paisDeleteManyArgs>(args?: SelectSubset<T, paisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pais
     * const pais = await prisma.pais.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paisUpdateManyArgs>(args: SelectSubset<T, paisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pais and returns the data updated in the database.
     * @param {paisUpdateManyAndReturnArgs} args - Arguments to update many Pais.
     * @example
     * // Update many Pais
     * const pais = await prisma.pais.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pais and only return the `id`
     * const paisWithIdOnly = await prisma.pais.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paisUpdateManyAndReturnArgs>(args: SelectSubset<T, paisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pais.
     * @param {paisUpsertArgs} args - Arguments to update or create a Pais.
     * @example
     * // Update or create a Pais
     * const pais = await prisma.pais.upsert({
     *   create: {
     *     // ... data to create a Pais
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pais we want to update
     *   }
     * })
     */
    upsert<T extends paisUpsertArgs>(args: SelectSubset<T, paisUpsertArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisCountArgs} args - Arguments to filter Pais to count.
     * @example
     * // Count the number of Pais
     * const count = await prisma.pais.count({
     *   where: {
     *     // ... the filter for the Pais we want to count
     *   }
     * })
    **/
    count<T extends paisCountArgs>(
      args?: Subset<T, paisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaisAggregateArgs>(args: Subset<T, PaisAggregateArgs>): Prisma.PrismaPromise<GetPaisAggregateType<T>>

    /**
     * Group by Pais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paisGroupByArgs['orderBy'] }
        : { orderBy?: paisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pais model
   */
  readonly fields: paisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pais.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estado<T extends pais$estadoArgs<ExtArgs> = {}>(args?: Subset<T, pais$estadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pais model
   */
  interface paisFieldRefs {
    readonly id: FieldRef<"pais", 'Int'>
    readonly isoAlpha2: FieldRef<"pais", 'String'>
    readonly nome: FieldRef<"pais", 'String'>
    readonly regiao: FieldRef<"pais", 'String'>
    readonly subRegiao: FieldRef<"pais", 'String'>
    readonly regiaoIntermediaria: FieldRef<"pais", 'String'>
    readonly lingua: FieldRef<"pais", 'String'>
    readonly capital: FieldRef<"pais", 'String'>
  }
    

  // Custom InputTypes
  /**
   * pais findUnique
   */
  export type paisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais findUniqueOrThrow
   */
  export type paisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais findFirst
   */
  export type paisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pais.
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pais.
     */
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * pais findFirstOrThrow
   */
  export type paisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pais.
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pais.
     */
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * pais findMany
   */
  export type paisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter, which pais to fetch.
     */
    where?: paisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pais to fetch.
     */
    orderBy?: paisOrderByWithRelationInput | paisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pais.
     */
    cursor?: paisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pais.
     */
    skip?: number
    distinct?: PaisScalarFieldEnum | PaisScalarFieldEnum[]
  }

  /**
   * pais create
   */
  export type paisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * The data needed to create a pais.
     */
    data: XOR<paisCreateInput, paisUncheckedCreateInput>
  }

  /**
   * pais createMany
   */
  export type paisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pais.
     */
    data: paisCreateManyInput | paisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pais createManyAndReturn
   */
  export type paisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * The data used to create many pais.
     */
    data: paisCreateManyInput | paisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pais update
   */
  export type paisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * The data needed to update a pais.
     */
    data: XOR<paisUpdateInput, paisUncheckedUpdateInput>
    /**
     * Choose, which pais to update.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais updateMany
   */
  export type paisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pais.
     */
    data: XOR<paisUpdateManyMutationInput, paisUncheckedUpdateManyInput>
    /**
     * Filter which pais to update
     */
    where?: paisWhereInput
    /**
     * Limit how many pais to update.
     */
    limit?: number
  }

  /**
   * pais updateManyAndReturn
   */
  export type paisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * The data used to update pais.
     */
    data: XOR<paisUpdateManyMutationInput, paisUncheckedUpdateManyInput>
    /**
     * Filter which pais to update
     */
    where?: paisWhereInput
    /**
     * Limit how many pais to update.
     */
    limit?: number
  }

  /**
   * pais upsert
   */
  export type paisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * The filter to search for the pais to update in case it exists.
     */
    where: paisWhereUniqueInput
    /**
     * In case the pais found by the `where` argument doesn't exist, create a new pais with this data.
     */
    create: XOR<paisCreateInput, paisUncheckedCreateInput>
    /**
     * In case the pais was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paisUpdateInput, paisUncheckedUpdateInput>
  }

  /**
   * pais delete
   */
  export type paisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
    /**
     * Filter which pais to delete.
     */
    where: paisWhereUniqueInput
  }

  /**
   * pais deleteMany
   */
  export type paisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pais to delete
     */
    where?: paisWhereInput
    /**
     * Limit how many pais to delete.
     */
    limit?: number
  }

  /**
   * pais.estado
   */
  export type pais$estadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    where?: estadoWhereInput
    orderBy?: estadoOrderByWithRelationInput | estadoOrderByWithRelationInput[]
    cursor?: estadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }

  /**
   * pais without action
   */
  export type paisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pais
     */
    select?: paisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pais
     */
    omit?: paisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paisInclude<ExtArgs> | null
  }


  /**
   * Model estado
   */

  export type AggregateEstado = {
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  export type EstadoAvgAggregateOutputType = {
    id: number | null
    paisId: number | null
  }

  export type EstadoSumAggregateOutputType = {
    id: number | null
    paisId: number | null
  }

  export type EstadoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    sigla: string | null
    ativo: boolean | null
    paisId: number | null
  }

  export type EstadoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    sigla: string | null
    ativo: boolean | null
    paisId: number | null
  }

  export type EstadoCountAggregateOutputType = {
    id: number
    nome: number
    sigla: number
    ativo: number
    paisId: number
    _all: number
  }


  export type EstadoAvgAggregateInputType = {
    id?: true
    paisId?: true
  }

  export type EstadoSumAggregateInputType = {
    id?: true
    paisId?: true
  }

  export type EstadoMinAggregateInputType = {
    id?: true
    nome?: true
    sigla?: true
    ativo?: true
    paisId?: true
  }

  export type EstadoMaxAggregateInputType = {
    id?: true
    nome?: true
    sigla?: true
    ativo?: true
    paisId?: true
  }

  export type EstadoCountAggregateInputType = {
    id?: true
    nome?: true
    sigla?: true
    ativo?: true
    paisId?: true
    _all?: true
  }

  export type EstadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estado to aggregate.
     */
    where?: estadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadoOrderByWithRelationInput | estadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estados
    **/
    _count?: true | EstadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoMaxAggregateInputType
  }

  export type GetEstadoAggregateType<T extends EstadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEstado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstado[P]>
      : GetScalarType<T[P], AggregateEstado[P]>
  }




  export type estadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estadoWhereInput
    orderBy?: estadoOrderByWithAggregationInput | estadoOrderByWithAggregationInput[]
    by: EstadoScalarFieldEnum[] | EstadoScalarFieldEnum
    having?: estadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoCountAggregateInputType | true
    _avg?: EstadoAvgAggregateInputType
    _sum?: EstadoSumAggregateInputType
    _min?: EstadoMinAggregateInputType
    _max?: EstadoMaxAggregateInputType
  }

  export type EstadoGroupByOutputType = {
    id: number
    nome: string
    sigla: string
    ativo: boolean
    paisId: number
    _count: EstadoCountAggregateOutputType | null
    _avg: EstadoAvgAggregateOutputType | null
    _sum: EstadoSumAggregateOutputType | null
    _min: EstadoMinAggregateOutputType | null
    _max: EstadoMaxAggregateOutputType | null
  }

  type GetEstadoGroupByPayload<T extends estadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoGroupByOutputType[P]>
        }
      >
    >


  export type estadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sigla?: boolean
    ativo?: boolean
    paisId?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
    cidade?: boolean | estado$cidadeArgs<ExtArgs>
    _count?: boolean | EstadoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estado"]>

  export type estadoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sigla?: boolean
    ativo?: boolean
    paisId?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estado"]>

  export type estadoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    sigla?: boolean
    ativo?: boolean
    paisId?: boolean
    pais?: boolean | paisDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estado"]>

  export type estadoSelectScalar = {
    id?: boolean
    nome?: boolean
    sigla?: boolean
    ativo?: boolean
    paisId?: boolean
  }

  export type estadoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "sigla" | "ativo" | "paisId", ExtArgs["result"]["estado"]>
  export type estadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
    cidade?: boolean | estado$cidadeArgs<ExtArgs>
    _count?: boolean | EstadoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type estadoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
  }
  export type estadoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pais?: boolean | paisDefaultArgs<ExtArgs>
  }

  export type $estadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estado"
    objects: {
      pais: Prisma.$paisPayload<ExtArgs>
      cidade: Prisma.$cidadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      sigla: string
      ativo: boolean
      paisId: number
    }, ExtArgs["result"]["estado"]>
    composites: {}
  }

  type estadoGetPayload<S extends boolean | null | undefined | estadoDefaultArgs> = $Result.GetResult<Prisma.$estadoPayload, S>

  type estadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstadoCountAggregateInputType | true
    }

  export interface estadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estado'], meta: { name: 'estado' } }
    /**
     * Find zero or one Estado that matches the filter.
     * @param {estadoFindUniqueArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estadoFindUniqueArgs>(args: SelectSubset<T, estadoFindUniqueArgs<ExtArgs>>): Prisma__estadoClient<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Estado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estadoFindUniqueOrThrowArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estadoFindUniqueOrThrowArgs>(args: SelectSubset<T, estadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estadoClient<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoFindFirstArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estadoFindFirstArgs>(args?: SelectSubset<T, estadoFindFirstArgs<ExtArgs>>): Prisma__estadoClient<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Estado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoFindFirstOrThrowArgs} args - Arguments to find a Estado
     * @example
     * // Get one Estado
     * const estado = await prisma.estado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estadoFindFirstOrThrowArgs>(args?: SelectSubset<T, estadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__estadoClient<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Estados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Estados
     * const estados = await prisma.estado.findMany()
     * 
     * // Get first 10 Estados
     * const estados = await prisma.estado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estadoWithIdOnly = await prisma.estado.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estadoFindManyArgs>(args?: SelectSubset<T, estadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Estado.
     * @param {estadoCreateArgs} args - Arguments to create a Estado.
     * @example
     * // Create one Estado
     * const Estado = await prisma.estado.create({
     *   data: {
     *     // ... data to create a Estado
     *   }
     * })
     * 
     */
    create<T extends estadoCreateArgs>(args: SelectSubset<T, estadoCreateArgs<ExtArgs>>): Prisma__estadoClient<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Estados.
     * @param {estadoCreateManyArgs} args - Arguments to create many Estados.
     * @example
     * // Create many Estados
     * const estado = await prisma.estado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estadoCreateManyArgs>(args?: SelectSubset<T, estadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Estados and returns the data saved in the database.
     * @param {estadoCreateManyAndReturnArgs} args - Arguments to create many Estados.
     * @example
     * // Create many Estados
     * const estado = await prisma.estado.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Estados and only return the `id`
     * const estadoWithIdOnly = await prisma.estado.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends estadoCreateManyAndReturnArgs>(args?: SelectSubset<T, estadoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Estado.
     * @param {estadoDeleteArgs} args - Arguments to delete one Estado.
     * @example
     * // Delete one Estado
     * const Estado = await prisma.estado.delete({
     *   where: {
     *     // ... filter to delete one Estado
     *   }
     * })
     * 
     */
    delete<T extends estadoDeleteArgs>(args: SelectSubset<T, estadoDeleteArgs<ExtArgs>>): Prisma__estadoClient<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Estado.
     * @param {estadoUpdateArgs} args - Arguments to update one Estado.
     * @example
     * // Update one Estado
     * const estado = await prisma.estado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estadoUpdateArgs>(args: SelectSubset<T, estadoUpdateArgs<ExtArgs>>): Prisma__estadoClient<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Estados.
     * @param {estadoDeleteManyArgs} args - Arguments to filter Estados to delete.
     * @example
     * // Delete a few Estados
     * const { count } = await prisma.estado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estadoDeleteManyArgs>(args?: SelectSubset<T, estadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Estados
     * const estado = await prisma.estado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estadoUpdateManyArgs>(args: SelectSubset<T, estadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Estados and returns the data updated in the database.
     * @param {estadoUpdateManyAndReturnArgs} args - Arguments to update many Estados.
     * @example
     * // Update many Estados
     * const estado = await prisma.estado.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Estados and only return the `id`
     * const estadoWithIdOnly = await prisma.estado.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends estadoUpdateManyAndReturnArgs>(args: SelectSubset<T, estadoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Estado.
     * @param {estadoUpsertArgs} args - Arguments to update or create a Estado.
     * @example
     * // Update or create a Estado
     * const estado = await prisma.estado.upsert({
     *   create: {
     *     // ... data to create a Estado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Estado we want to update
     *   }
     * })
     */
    upsert<T extends estadoUpsertArgs>(args: SelectSubset<T, estadoUpsertArgs<ExtArgs>>): Prisma__estadoClient<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Estados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoCountArgs} args - Arguments to filter Estados to count.
     * @example
     * // Count the number of Estados
     * const count = await prisma.estado.count({
     *   where: {
     *     // ... the filter for the Estados we want to count
     *   }
     * })
    **/
    count<T extends estadoCountArgs>(
      args?: Subset<T, estadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoAggregateArgs>(args: Subset<T, EstadoAggregateArgs>): Prisma.PrismaPromise<GetEstadoAggregateType<T>>

    /**
     * Group by Estado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estadoGroupByArgs['orderBy'] }
        : { orderBy?: estadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estado model
   */
  readonly fields: estadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pais<T extends paisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paisDefaultArgs<ExtArgs>>): Prisma__paisClient<$Result.GetResult<Prisma.$paisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cidade<T extends estado$cidadeArgs<ExtArgs> = {}>(args?: Subset<T, estado$cidadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estado model
   */
  interface estadoFieldRefs {
    readonly id: FieldRef<"estado", 'Int'>
    readonly nome: FieldRef<"estado", 'String'>
    readonly sigla: FieldRef<"estado", 'String'>
    readonly ativo: FieldRef<"estado", 'Boolean'>
    readonly paisId: FieldRef<"estado", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * estado findUnique
   */
  export type estadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    /**
     * Filter, which estado to fetch.
     */
    where: estadoWhereUniqueInput
  }

  /**
   * estado findUniqueOrThrow
   */
  export type estadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    /**
     * Filter, which estado to fetch.
     */
    where: estadoWhereUniqueInput
  }

  /**
   * estado findFirst
   */
  export type estadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    /**
     * Filter, which estado to fetch.
     */
    where?: estadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadoOrderByWithRelationInput | estadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estados.
     */
    cursor?: estadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estados.
     */
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }

  /**
   * estado findFirstOrThrow
   */
  export type estadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    /**
     * Filter, which estado to fetch.
     */
    where?: estadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadoOrderByWithRelationInput | estadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estados.
     */
    cursor?: estadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estados.
     */
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }

  /**
   * estado findMany
   */
  export type estadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    /**
     * Filter, which estados to fetch.
     */
    where?: estadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estados to fetch.
     */
    orderBy?: estadoOrderByWithRelationInput | estadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estados.
     */
    cursor?: estadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estados.
     */
    skip?: number
    distinct?: EstadoScalarFieldEnum | EstadoScalarFieldEnum[]
  }

  /**
   * estado create
   */
  export type estadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    /**
     * The data needed to create a estado.
     */
    data: XOR<estadoCreateInput, estadoUncheckedCreateInput>
  }

  /**
   * estado createMany
   */
  export type estadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estados.
     */
    data: estadoCreateManyInput | estadoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estado createManyAndReturn
   */
  export type estadoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * The data used to create many estados.
     */
    data: estadoCreateManyInput | estadoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * estado update
   */
  export type estadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    /**
     * The data needed to update a estado.
     */
    data: XOR<estadoUpdateInput, estadoUncheckedUpdateInput>
    /**
     * Choose, which estado to update.
     */
    where: estadoWhereUniqueInput
  }

  /**
   * estado updateMany
   */
  export type estadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estados.
     */
    data: XOR<estadoUpdateManyMutationInput, estadoUncheckedUpdateManyInput>
    /**
     * Filter which estados to update
     */
    where?: estadoWhereInput
    /**
     * Limit how many estados to update.
     */
    limit?: number
  }

  /**
   * estado updateManyAndReturn
   */
  export type estadoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * The data used to update estados.
     */
    data: XOR<estadoUpdateManyMutationInput, estadoUncheckedUpdateManyInput>
    /**
     * Filter which estados to update
     */
    where?: estadoWhereInput
    /**
     * Limit how many estados to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * estado upsert
   */
  export type estadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    /**
     * The filter to search for the estado to update in case it exists.
     */
    where: estadoWhereUniqueInput
    /**
     * In case the estado found by the `where` argument doesn't exist, create a new estado with this data.
     */
    create: XOR<estadoCreateInput, estadoUncheckedCreateInput>
    /**
     * In case the estado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estadoUpdateInput, estadoUncheckedUpdateInput>
  }

  /**
   * estado delete
   */
  export type estadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
    /**
     * Filter which estado to delete.
     */
    where: estadoWhereUniqueInput
  }

  /**
   * estado deleteMany
   */
  export type estadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estados to delete
     */
    where?: estadoWhereInput
    /**
     * Limit how many estados to delete.
     */
    limit?: number
  }

  /**
   * estado.cidade
   */
  export type estado$cidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    where?: cidadeWhereInput
    orderBy?: cidadeOrderByWithRelationInput | cidadeOrderByWithRelationInput[]
    cursor?: cidadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[]
  }

  /**
   * estado without action
   */
  export type estadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estado
     */
    select?: estadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estado
     */
    omit?: estadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoInclude<ExtArgs> | null
  }


  /**
   * Model cidade
   */

  export type AggregateCidade = {
    _count: CidadeCountAggregateOutputType | null
    _avg: CidadeAvgAggregateOutputType | null
    _sum: CidadeSumAggregateOutputType | null
    _min: CidadeMinAggregateOutputType | null
    _max: CidadeMaxAggregateOutputType | null
  }

  export type CidadeAvgAggregateOutputType = {
    id: number | null
    estadoId: number | null
  }

  export type CidadeSumAggregateOutputType = {
    id: number | null
    estadoId: number | null
  }

  export type CidadeMinAggregateOutputType = {
    id: number | null
    nome: string | null
    estadoId: number | null
    ativo: boolean | null
  }

  export type CidadeMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    estadoId: number | null
    ativo: boolean | null
  }

  export type CidadeCountAggregateOutputType = {
    id: number
    nome: number
    estadoId: number
    ativo: number
    _all: number
  }


  export type CidadeAvgAggregateInputType = {
    id?: true
    estadoId?: true
  }

  export type CidadeSumAggregateInputType = {
    id?: true
    estadoId?: true
  }

  export type CidadeMinAggregateInputType = {
    id?: true
    nome?: true
    estadoId?: true
    ativo?: true
  }

  export type CidadeMaxAggregateInputType = {
    id?: true
    nome?: true
    estadoId?: true
    ativo?: true
  }

  export type CidadeCountAggregateInputType = {
    id?: true
    nome?: true
    estadoId?: true
    ativo?: true
    _all?: true
  }

  export type CidadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cidade to aggregate.
     */
    where?: cidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cidades to fetch.
     */
    orderBy?: cidadeOrderByWithRelationInput | cidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cidades
    **/
    _count?: true | CidadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CidadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CidadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CidadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CidadeMaxAggregateInputType
  }

  export type GetCidadeAggregateType<T extends CidadeAggregateArgs> = {
        [P in keyof T & keyof AggregateCidade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCidade[P]>
      : GetScalarType<T[P], AggregateCidade[P]>
  }




  export type cidadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cidadeWhereInput
    orderBy?: cidadeOrderByWithAggregationInput | cidadeOrderByWithAggregationInput[]
    by: CidadeScalarFieldEnum[] | CidadeScalarFieldEnum
    having?: cidadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CidadeCountAggregateInputType | true
    _avg?: CidadeAvgAggregateInputType
    _sum?: CidadeSumAggregateInputType
    _min?: CidadeMinAggregateInputType
    _max?: CidadeMaxAggregateInputType
  }

  export type CidadeGroupByOutputType = {
    id: number
    nome: string
    estadoId: number
    ativo: boolean
    _count: CidadeCountAggregateOutputType | null
    _avg: CidadeAvgAggregateOutputType | null
    _sum: CidadeSumAggregateOutputType | null
    _min: CidadeMinAggregateOutputType | null
    _max: CidadeMaxAggregateOutputType | null
  }

  type GetCidadeGroupByPayload<T extends cidadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CidadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CidadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CidadeGroupByOutputType[P]>
            : GetScalarType<T[P], CidadeGroupByOutputType[P]>
        }
      >
    >


  export type cidadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    estadoId?: boolean
    ativo?: boolean
    estado?: boolean | estadoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cidade"]>

  export type cidadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    estadoId?: boolean
    ativo?: boolean
    estado?: boolean | estadoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cidade"]>

  export type cidadeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    estadoId?: boolean
    ativo?: boolean
    estado?: boolean | estadoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cidade"]>

  export type cidadeSelectScalar = {
    id?: boolean
    nome?: boolean
    estadoId?: boolean
    ativo?: boolean
  }

  export type cidadeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "estadoId" | "ativo", ExtArgs["result"]["cidade"]>
  export type cidadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado?: boolean | estadoDefaultArgs<ExtArgs>
  }
  export type cidadeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado?: boolean | estadoDefaultArgs<ExtArgs>
  }
  export type cidadeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estado?: boolean | estadoDefaultArgs<ExtArgs>
  }

  export type $cidadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cidade"
    objects: {
      estado: Prisma.$estadoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      estadoId: number
      ativo: boolean
    }, ExtArgs["result"]["cidade"]>
    composites: {}
  }

  type cidadeGetPayload<S extends boolean | null | undefined | cidadeDefaultArgs> = $Result.GetResult<Prisma.$cidadePayload, S>

  type cidadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cidadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CidadeCountAggregateInputType | true
    }

  export interface cidadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cidade'], meta: { name: 'cidade' } }
    /**
     * Find zero or one Cidade that matches the filter.
     * @param {cidadeFindUniqueArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cidadeFindUniqueArgs>(args: SelectSubset<T, cidadeFindUniqueArgs<ExtArgs>>): Prisma__cidadeClient<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cidade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cidadeFindUniqueOrThrowArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cidadeFindUniqueOrThrowArgs>(args: SelectSubset<T, cidadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cidadeClient<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cidade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeFindFirstArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cidadeFindFirstArgs>(args?: SelectSubset<T, cidadeFindFirstArgs<ExtArgs>>): Prisma__cidadeClient<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cidade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeFindFirstOrThrowArgs} args - Arguments to find a Cidade
     * @example
     * // Get one Cidade
     * const cidade = await prisma.cidade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cidadeFindFirstOrThrowArgs>(args?: SelectSubset<T, cidadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__cidadeClient<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cidades
     * const cidades = await prisma.cidade.findMany()
     * 
     * // Get first 10 Cidades
     * const cidades = await prisma.cidade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cidadeWithIdOnly = await prisma.cidade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cidadeFindManyArgs>(args?: SelectSubset<T, cidadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cidade.
     * @param {cidadeCreateArgs} args - Arguments to create a Cidade.
     * @example
     * // Create one Cidade
     * const Cidade = await prisma.cidade.create({
     *   data: {
     *     // ... data to create a Cidade
     *   }
     * })
     * 
     */
    create<T extends cidadeCreateArgs>(args: SelectSubset<T, cidadeCreateArgs<ExtArgs>>): Prisma__cidadeClient<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cidades.
     * @param {cidadeCreateManyArgs} args - Arguments to create many Cidades.
     * @example
     * // Create many Cidades
     * const cidade = await prisma.cidade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cidadeCreateManyArgs>(args?: SelectSubset<T, cidadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cidades and returns the data saved in the database.
     * @param {cidadeCreateManyAndReturnArgs} args - Arguments to create many Cidades.
     * @example
     * // Create many Cidades
     * const cidade = await prisma.cidade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cidades and only return the `id`
     * const cidadeWithIdOnly = await prisma.cidade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cidadeCreateManyAndReturnArgs>(args?: SelectSubset<T, cidadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cidade.
     * @param {cidadeDeleteArgs} args - Arguments to delete one Cidade.
     * @example
     * // Delete one Cidade
     * const Cidade = await prisma.cidade.delete({
     *   where: {
     *     // ... filter to delete one Cidade
     *   }
     * })
     * 
     */
    delete<T extends cidadeDeleteArgs>(args: SelectSubset<T, cidadeDeleteArgs<ExtArgs>>): Prisma__cidadeClient<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cidade.
     * @param {cidadeUpdateArgs} args - Arguments to update one Cidade.
     * @example
     * // Update one Cidade
     * const cidade = await prisma.cidade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cidadeUpdateArgs>(args: SelectSubset<T, cidadeUpdateArgs<ExtArgs>>): Prisma__cidadeClient<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cidades.
     * @param {cidadeDeleteManyArgs} args - Arguments to filter Cidades to delete.
     * @example
     * // Delete a few Cidades
     * const { count } = await prisma.cidade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cidadeDeleteManyArgs>(args?: SelectSubset<T, cidadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cidades
     * const cidade = await prisma.cidade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cidadeUpdateManyArgs>(args: SelectSubset<T, cidadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cidades and returns the data updated in the database.
     * @param {cidadeUpdateManyAndReturnArgs} args - Arguments to update many Cidades.
     * @example
     * // Update many Cidades
     * const cidade = await prisma.cidade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cidades and only return the `id`
     * const cidadeWithIdOnly = await prisma.cidade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cidadeUpdateManyAndReturnArgs>(args: SelectSubset<T, cidadeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cidade.
     * @param {cidadeUpsertArgs} args - Arguments to update or create a Cidade.
     * @example
     * // Update or create a Cidade
     * const cidade = await prisma.cidade.upsert({
     *   create: {
     *     // ... data to create a Cidade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cidade we want to update
     *   }
     * })
     */
    upsert<T extends cidadeUpsertArgs>(args: SelectSubset<T, cidadeUpsertArgs<ExtArgs>>): Prisma__cidadeClient<$Result.GetResult<Prisma.$cidadePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeCountArgs} args - Arguments to filter Cidades to count.
     * @example
     * // Count the number of Cidades
     * const count = await prisma.cidade.count({
     *   where: {
     *     // ... the filter for the Cidades we want to count
     *   }
     * })
    **/
    count<T extends cidadeCountArgs>(
      args?: Subset<T, cidadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CidadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CidadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CidadeAggregateArgs>(args: Subset<T, CidadeAggregateArgs>): Prisma.PrismaPromise<GetCidadeAggregateType<T>>

    /**
     * Group by Cidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cidadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cidadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cidadeGroupByArgs['orderBy'] }
        : { orderBy?: cidadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cidadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCidadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cidade model
   */
  readonly fields: cidadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cidade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cidadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estado<T extends estadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estadoDefaultArgs<ExtArgs>>): Prisma__estadoClient<$Result.GetResult<Prisma.$estadoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cidade model
   */
  interface cidadeFieldRefs {
    readonly id: FieldRef<"cidade", 'Int'>
    readonly nome: FieldRef<"cidade", 'String'>
    readonly estadoId: FieldRef<"cidade", 'Int'>
    readonly ativo: FieldRef<"cidade", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * cidade findUnique
   */
  export type cidadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    /**
     * Filter, which cidade to fetch.
     */
    where: cidadeWhereUniqueInput
  }

  /**
   * cidade findUniqueOrThrow
   */
  export type cidadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    /**
     * Filter, which cidade to fetch.
     */
    where: cidadeWhereUniqueInput
  }

  /**
   * cidade findFirst
   */
  export type cidadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    /**
     * Filter, which cidade to fetch.
     */
    where?: cidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cidades to fetch.
     */
    orderBy?: cidadeOrderByWithRelationInput | cidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cidades.
     */
    cursor?: cidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cidades.
     */
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[]
  }

  /**
   * cidade findFirstOrThrow
   */
  export type cidadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    /**
     * Filter, which cidade to fetch.
     */
    where?: cidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cidades to fetch.
     */
    orderBy?: cidadeOrderByWithRelationInput | cidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cidades.
     */
    cursor?: cidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cidades.
     */
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[]
  }

  /**
   * cidade findMany
   */
  export type cidadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    /**
     * Filter, which cidades to fetch.
     */
    where?: cidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cidades to fetch.
     */
    orderBy?: cidadeOrderByWithRelationInput | cidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cidades.
     */
    cursor?: cidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cidades.
     */
    skip?: number
    distinct?: CidadeScalarFieldEnum | CidadeScalarFieldEnum[]
  }

  /**
   * cidade create
   */
  export type cidadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    /**
     * The data needed to create a cidade.
     */
    data: XOR<cidadeCreateInput, cidadeUncheckedCreateInput>
  }

  /**
   * cidade createMany
   */
  export type cidadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cidades.
     */
    data: cidadeCreateManyInput | cidadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cidade createManyAndReturn
   */
  export type cidadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * The data used to create many cidades.
     */
    data: cidadeCreateManyInput | cidadeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * cidade update
   */
  export type cidadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    /**
     * The data needed to update a cidade.
     */
    data: XOR<cidadeUpdateInput, cidadeUncheckedUpdateInput>
    /**
     * Choose, which cidade to update.
     */
    where: cidadeWhereUniqueInput
  }

  /**
   * cidade updateMany
   */
  export type cidadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cidades.
     */
    data: XOR<cidadeUpdateManyMutationInput, cidadeUncheckedUpdateManyInput>
    /**
     * Filter which cidades to update
     */
    where?: cidadeWhereInput
    /**
     * Limit how many cidades to update.
     */
    limit?: number
  }

  /**
   * cidade updateManyAndReturn
   */
  export type cidadeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * The data used to update cidades.
     */
    data: XOR<cidadeUpdateManyMutationInput, cidadeUncheckedUpdateManyInput>
    /**
     * Filter which cidades to update
     */
    where?: cidadeWhereInput
    /**
     * Limit how many cidades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * cidade upsert
   */
  export type cidadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    /**
     * The filter to search for the cidade to update in case it exists.
     */
    where: cidadeWhereUniqueInput
    /**
     * In case the cidade found by the `where` argument doesn't exist, create a new cidade with this data.
     */
    create: XOR<cidadeCreateInput, cidadeUncheckedCreateInput>
    /**
     * In case the cidade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cidadeUpdateInput, cidadeUncheckedUpdateInput>
  }

  /**
   * cidade delete
   */
  export type cidadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
    /**
     * Filter which cidade to delete.
     */
    where: cidadeWhereUniqueInput
  }

  /**
   * cidade deleteMany
   */
  export type cidadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cidades to delete
     */
    where?: cidadeWhereInput
    /**
     * Limit how many cidades to delete.
     */
    limit?: number
  }

  /**
   * cidade without action
   */
  export type cidadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cidade
     */
    select?: cidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cidade
     */
    omit?: cidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cidadeInclude<ExtArgs> | null
  }


  /**
   * Model endereco
   */

  export type AggregateEndereco = {
    _count: EnderecoCountAggregateOutputType | null
    _avg: EnderecoAvgAggregateOutputType | null
    _sum: EnderecoSumAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  export type EnderecoAvgAggregateOutputType = {
    id: number | null
  }

  export type EnderecoSumAggregateOutputType = {
    id: number | null
  }

  export type EnderecoMinAggregateOutputType = {
    id: number | null
    cep: string | null
    logradouro: string | null
    cidade: string | null
    bairro: string | null
    numero: string | null
    UF: string | null
    pais: string | null
    observacao: string | null
  }

  export type EnderecoMaxAggregateOutputType = {
    id: number | null
    cep: string | null
    logradouro: string | null
    cidade: string | null
    bairro: string | null
    numero: string | null
    UF: string | null
    pais: string | null
    observacao: string | null
  }

  export type EnderecoCountAggregateOutputType = {
    id: number
    cep: number
    logradouro: number
    cidade: number
    bairro: number
    numero: number
    UF: number
    pais: number
    observacao: number
    _all: number
  }


  export type EnderecoAvgAggregateInputType = {
    id?: true
  }

  export type EnderecoSumAggregateInputType = {
    id?: true
  }

  export type EnderecoMinAggregateInputType = {
    id?: true
    cep?: true
    logradouro?: true
    cidade?: true
    bairro?: true
    numero?: true
    UF?: true
    pais?: true
    observacao?: true
  }

  export type EnderecoMaxAggregateInputType = {
    id?: true
    cep?: true
    logradouro?: true
    cidade?: true
    bairro?: true
    numero?: true
    UF?: true
    pais?: true
    observacao?: true
  }

  export type EnderecoCountAggregateInputType = {
    id?: true
    cep?: true
    logradouro?: true
    cidade?: true
    bairro?: true
    numero?: true
    UF?: true
    pais?: true
    observacao?: true
    _all?: true
  }

  export type EnderecoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which endereco to aggregate.
     */
    where?: enderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enderecos to fetch.
     */
    orderBy?: enderecoOrderByWithRelationInput | enderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: enderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned enderecos
    **/
    _count?: true | EnderecoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnderecoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnderecoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnderecoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnderecoMaxAggregateInputType
  }

  export type GetEnderecoAggregateType<T extends EnderecoAggregateArgs> = {
        [P in keyof T & keyof AggregateEndereco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEndereco[P]>
      : GetScalarType<T[P], AggregateEndereco[P]>
  }




  export type enderecoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enderecoWhereInput
    orderBy?: enderecoOrderByWithAggregationInput | enderecoOrderByWithAggregationInput[]
    by: EnderecoScalarFieldEnum[] | EnderecoScalarFieldEnum
    having?: enderecoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnderecoCountAggregateInputType | true
    _avg?: EnderecoAvgAggregateInputType
    _sum?: EnderecoSumAggregateInputType
    _min?: EnderecoMinAggregateInputType
    _max?: EnderecoMaxAggregateInputType
  }

  export type EnderecoGroupByOutputType = {
    id: number
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais: string
    observacao: string | null
    _count: EnderecoCountAggregateOutputType | null
    _avg: EnderecoAvgAggregateOutputType | null
    _sum: EnderecoSumAggregateOutputType | null
    _min: EnderecoMinAggregateOutputType | null
    _max: EnderecoMaxAggregateOutputType | null
  }

  type GetEnderecoGroupByPayload<T extends enderecoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnderecoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnderecoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
            : GetScalarType<T[P], EnderecoGroupByOutputType[P]>
        }
      >
    >


  export type enderecoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cep?: boolean
    logradouro?: boolean
    cidade?: boolean
    bairro?: boolean
    numero?: boolean
    UF?: boolean
    pais?: boolean
    observacao?: boolean
    paroquias?: boolean | endereco$paroquiasArgs<ExtArgs>
    pessoas?: boolean | endereco$pessoasArgs<ExtArgs>
    localidade?: boolean | endereco$localidadeArgs<ExtArgs>
    diocese?: boolean | endereco$dioceseArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["endereco"]>

  export type enderecoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cep?: boolean
    logradouro?: boolean
    cidade?: boolean
    bairro?: boolean
    numero?: boolean
    UF?: boolean
    pais?: boolean
    observacao?: boolean
  }, ExtArgs["result"]["endereco"]>

  export type enderecoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cep?: boolean
    logradouro?: boolean
    cidade?: boolean
    bairro?: boolean
    numero?: boolean
    UF?: boolean
    pais?: boolean
    observacao?: boolean
  }, ExtArgs["result"]["endereco"]>

  export type enderecoSelectScalar = {
    id?: boolean
    cep?: boolean
    logradouro?: boolean
    cidade?: boolean
    bairro?: boolean
    numero?: boolean
    UF?: boolean
    pais?: boolean
    observacao?: boolean
  }

  export type enderecoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cep" | "logradouro" | "cidade" | "bairro" | "numero" | "UF" | "pais" | "observacao", ExtArgs["result"]["endereco"]>
  export type enderecoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paroquias?: boolean | endereco$paroquiasArgs<ExtArgs>
    pessoas?: boolean | endereco$pessoasArgs<ExtArgs>
    localidade?: boolean | endereco$localidadeArgs<ExtArgs>
    diocese?: boolean | endereco$dioceseArgs<ExtArgs>
    _count?: boolean | EnderecoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type enderecoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type enderecoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $enderecoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "endereco"
    objects: {
      paroquias: Prisma.$paroquiaPayload<ExtArgs>[]
      pessoas: Prisma.$pessoaEnderecoPayload<ExtArgs>[]
      localidade: Prisma.$localidadePayload<ExtArgs>[]
      diocese: Prisma.$diocesePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cep: string
      logradouro: string
      cidade: string
      bairro: string
      numero: string
      UF: string
      pais: string
      observacao: string | null
    }, ExtArgs["result"]["endereco"]>
    composites: {}
  }

  type enderecoGetPayload<S extends boolean | null | undefined | enderecoDefaultArgs> = $Result.GetResult<Prisma.$enderecoPayload, S>

  type enderecoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<enderecoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnderecoCountAggregateInputType | true
    }

  export interface enderecoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['endereco'], meta: { name: 'endereco' } }
    /**
     * Find zero or one Endereco that matches the filter.
     * @param {enderecoFindUniqueArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends enderecoFindUniqueArgs>(args: SelectSubset<T, enderecoFindUniqueArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Endereco that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {enderecoFindUniqueOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends enderecoFindUniqueOrThrowArgs>(args: SelectSubset<T, enderecoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endereco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoFindFirstArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends enderecoFindFirstArgs>(args?: SelectSubset<T, enderecoFindFirstArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Endereco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoFindFirstOrThrowArgs} args - Arguments to find a Endereco
     * @example
     * // Get one Endereco
     * const endereco = await prisma.endereco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends enderecoFindFirstOrThrowArgs>(args?: SelectSubset<T, enderecoFindFirstOrThrowArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enderecos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enderecos
     * const enderecos = await prisma.endereco.findMany()
     * 
     * // Get first 10 Enderecos
     * const enderecos = await prisma.endereco.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enderecoWithIdOnly = await prisma.endereco.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends enderecoFindManyArgs>(args?: SelectSubset<T, enderecoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Endereco.
     * @param {enderecoCreateArgs} args - Arguments to create a Endereco.
     * @example
     * // Create one Endereco
     * const Endereco = await prisma.endereco.create({
     *   data: {
     *     // ... data to create a Endereco
     *   }
     * })
     * 
     */
    create<T extends enderecoCreateArgs>(args: SelectSubset<T, enderecoCreateArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enderecos.
     * @param {enderecoCreateManyArgs} args - Arguments to create many Enderecos.
     * @example
     * // Create many Enderecos
     * const endereco = await prisma.endereco.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends enderecoCreateManyArgs>(args?: SelectSubset<T, enderecoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enderecos and returns the data saved in the database.
     * @param {enderecoCreateManyAndReturnArgs} args - Arguments to create many Enderecos.
     * @example
     * // Create many Enderecos
     * const endereco = await prisma.endereco.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enderecos and only return the `id`
     * const enderecoWithIdOnly = await prisma.endereco.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends enderecoCreateManyAndReturnArgs>(args?: SelectSubset<T, enderecoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Endereco.
     * @param {enderecoDeleteArgs} args - Arguments to delete one Endereco.
     * @example
     * // Delete one Endereco
     * const Endereco = await prisma.endereco.delete({
     *   where: {
     *     // ... filter to delete one Endereco
     *   }
     * })
     * 
     */
    delete<T extends enderecoDeleteArgs>(args: SelectSubset<T, enderecoDeleteArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Endereco.
     * @param {enderecoUpdateArgs} args - Arguments to update one Endereco.
     * @example
     * // Update one Endereco
     * const endereco = await prisma.endereco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends enderecoUpdateArgs>(args: SelectSubset<T, enderecoUpdateArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enderecos.
     * @param {enderecoDeleteManyArgs} args - Arguments to filter Enderecos to delete.
     * @example
     * // Delete a few Enderecos
     * const { count } = await prisma.endereco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends enderecoDeleteManyArgs>(args?: SelectSubset<T, enderecoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends enderecoUpdateManyArgs>(args: SelectSubset<T, enderecoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enderecos and returns the data updated in the database.
     * @param {enderecoUpdateManyAndReturnArgs} args - Arguments to update many Enderecos.
     * @example
     * // Update many Enderecos
     * const endereco = await prisma.endereco.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enderecos and only return the `id`
     * const enderecoWithIdOnly = await prisma.endereco.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends enderecoUpdateManyAndReturnArgs>(args: SelectSubset<T, enderecoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Endereco.
     * @param {enderecoUpsertArgs} args - Arguments to update or create a Endereco.
     * @example
     * // Update or create a Endereco
     * const endereco = await prisma.endereco.upsert({
     *   create: {
     *     // ... data to create a Endereco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Endereco we want to update
     *   }
     * })
     */
    upsert<T extends enderecoUpsertArgs>(args: SelectSubset<T, enderecoUpsertArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoCountArgs} args - Arguments to filter Enderecos to count.
     * @example
     * // Count the number of Enderecos
     * const count = await prisma.endereco.count({
     *   where: {
     *     // ... the filter for the Enderecos we want to count
     *   }
     * })
    **/
    count<T extends enderecoCountArgs>(
      args?: Subset<T, enderecoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnderecoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnderecoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnderecoAggregateArgs>(args: Subset<T, EnderecoAggregateArgs>): Prisma.PrismaPromise<GetEnderecoAggregateType<T>>

    /**
     * Group by Endereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enderecoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends enderecoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: enderecoGroupByArgs['orderBy'] }
        : { orderBy?: enderecoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, enderecoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnderecoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the endereco model
   */
  readonly fields: enderecoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for endereco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__enderecoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    paroquias<T extends endereco$paroquiasArgs<ExtArgs> = {}>(args?: Subset<T, endereco$paroquiasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pessoas<T extends endereco$pessoasArgs<ExtArgs> = {}>(args?: Subset<T, endereco$pessoasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    localidade<T extends endereco$localidadeArgs<ExtArgs> = {}>(args?: Subset<T, endereco$localidadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    diocese<T extends endereco$dioceseArgs<ExtArgs> = {}>(args?: Subset<T, endereco$dioceseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the endereco model
   */
  interface enderecoFieldRefs {
    readonly id: FieldRef<"endereco", 'Int'>
    readonly cep: FieldRef<"endereco", 'String'>
    readonly logradouro: FieldRef<"endereco", 'String'>
    readonly cidade: FieldRef<"endereco", 'String'>
    readonly bairro: FieldRef<"endereco", 'String'>
    readonly numero: FieldRef<"endereco", 'String'>
    readonly UF: FieldRef<"endereco", 'String'>
    readonly pais: FieldRef<"endereco", 'String'>
    readonly observacao: FieldRef<"endereco", 'String'>
  }
    

  // Custom InputTypes
  /**
   * endereco findUnique
   */
  export type enderecoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which endereco to fetch.
     */
    where: enderecoWhereUniqueInput
  }

  /**
   * endereco findUniqueOrThrow
   */
  export type enderecoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which endereco to fetch.
     */
    where: enderecoWhereUniqueInput
  }

  /**
   * endereco findFirst
   */
  export type enderecoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which endereco to fetch.
     */
    where?: enderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enderecos to fetch.
     */
    orderBy?: enderecoOrderByWithRelationInput | enderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enderecos.
     */
    cursor?: enderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * endereco findFirstOrThrow
   */
  export type enderecoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which endereco to fetch.
     */
    where?: enderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enderecos to fetch.
     */
    orderBy?: enderecoOrderByWithRelationInput | enderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enderecos.
     */
    cursor?: enderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enderecos.
     */
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * endereco findMany
   */
  export type enderecoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter, which enderecos to fetch.
     */
    where?: enderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enderecos to fetch.
     */
    orderBy?: enderecoOrderByWithRelationInput | enderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing enderecos.
     */
    cursor?: enderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enderecos.
     */
    skip?: number
    distinct?: EnderecoScalarFieldEnum | EnderecoScalarFieldEnum[]
  }

  /**
   * endereco create
   */
  export type enderecoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * The data needed to create a endereco.
     */
    data: XOR<enderecoCreateInput, enderecoUncheckedCreateInput>
  }

  /**
   * endereco createMany
   */
  export type enderecoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many enderecos.
     */
    data: enderecoCreateManyInput | enderecoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * endereco createManyAndReturn
   */
  export type enderecoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * The data used to create many enderecos.
     */
    data: enderecoCreateManyInput | enderecoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * endereco update
   */
  export type enderecoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * The data needed to update a endereco.
     */
    data: XOR<enderecoUpdateInput, enderecoUncheckedUpdateInput>
    /**
     * Choose, which endereco to update.
     */
    where: enderecoWhereUniqueInput
  }

  /**
   * endereco updateMany
   */
  export type enderecoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update enderecos.
     */
    data: XOR<enderecoUpdateManyMutationInput, enderecoUncheckedUpdateManyInput>
    /**
     * Filter which enderecos to update
     */
    where?: enderecoWhereInput
    /**
     * Limit how many enderecos to update.
     */
    limit?: number
  }

  /**
   * endereco updateManyAndReturn
   */
  export type enderecoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * The data used to update enderecos.
     */
    data: XOR<enderecoUpdateManyMutationInput, enderecoUncheckedUpdateManyInput>
    /**
     * Filter which enderecos to update
     */
    where?: enderecoWhereInput
    /**
     * Limit how many enderecos to update.
     */
    limit?: number
  }

  /**
   * endereco upsert
   */
  export type enderecoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * The filter to search for the endereco to update in case it exists.
     */
    where: enderecoWhereUniqueInput
    /**
     * In case the endereco found by the `where` argument doesn't exist, create a new endereco with this data.
     */
    create: XOR<enderecoCreateInput, enderecoUncheckedCreateInput>
    /**
     * In case the endereco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<enderecoUpdateInput, enderecoUncheckedUpdateInput>
  }

  /**
   * endereco delete
   */
  export type enderecoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
    /**
     * Filter which endereco to delete.
     */
    where: enderecoWhereUniqueInput
  }

  /**
   * endereco deleteMany
   */
  export type enderecoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enderecos to delete
     */
    where?: enderecoWhereInput
    /**
     * Limit how many enderecos to delete.
     */
    limit?: number
  }

  /**
   * endereco.paroquias
   */
  export type endereco$paroquiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    where?: paroquiaWhereInput
    orderBy?: paroquiaOrderByWithRelationInput | paroquiaOrderByWithRelationInput[]
    cursor?: paroquiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParoquiaScalarFieldEnum | ParoquiaScalarFieldEnum[]
  }

  /**
   * endereco.pessoas
   */
  export type endereco$pessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    where?: pessoaEnderecoWhereInput
    orderBy?: pessoaEnderecoOrderByWithRelationInput | pessoaEnderecoOrderByWithRelationInput[]
    cursor?: pessoaEnderecoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaEnderecoScalarFieldEnum | PessoaEnderecoScalarFieldEnum[]
  }

  /**
   * endereco.localidade
   */
  export type endereco$localidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    where?: localidadeWhereInput
    orderBy?: localidadeOrderByWithRelationInput | localidadeOrderByWithRelationInput[]
    cursor?: localidadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalidadeScalarFieldEnum | LocalidadeScalarFieldEnum[]
  }

  /**
   * endereco.diocese
   */
  export type endereco$dioceseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    where?: dioceseWhereInput
    orderBy?: dioceseOrderByWithRelationInput | dioceseOrderByWithRelationInput[]
    cursor?: dioceseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DioceseScalarFieldEnum | DioceseScalarFieldEnum[]
  }

  /**
   * endereco without action
   */
  export type enderecoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the endereco
     */
    select?: enderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the endereco
     */
    omit?: enderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enderecoInclude<ExtArgs> | null
  }


  /**
   * Model tipoCarisma
   */

  export type AggregateTipoCarisma = {
    _count: TipoCarismaCountAggregateOutputType | null
    _avg: TipoCarismaAvgAggregateOutputType | null
    _sum: TipoCarismaSumAggregateOutputType | null
    _min: TipoCarismaMinAggregateOutputType | null
    _max: TipoCarismaMaxAggregateOutputType | null
  }

  export type TipoCarismaAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoCarismaSumAggregateOutputType = {
    id: number | null
  }

  export type TipoCarismaMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoCarismaMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoCarismaCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type TipoCarismaAvgAggregateInputType = {
    id?: true
  }

  export type TipoCarismaSumAggregateInputType = {
    id?: true
  }

  export type TipoCarismaMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoCarismaMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoCarismaCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type TipoCarismaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoCarisma to aggregate.
     */
    where?: tipoCarismaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoCarismas to fetch.
     */
    orderBy?: tipoCarismaOrderByWithRelationInput | tipoCarismaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipoCarismaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoCarismas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoCarismas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipoCarismas
    **/
    _count?: true | TipoCarismaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoCarismaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoCarismaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoCarismaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoCarismaMaxAggregateInputType
  }

  export type GetTipoCarismaAggregateType<T extends TipoCarismaAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoCarisma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoCarisma[P]>
      : GetScalarType<T[P], AggregateTipoCarisma[P]>
  }




  export type tipoCarismaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipoCarismaWhereInput
    orderBy?: tipoCarismaOrderByWithAggregationInput | tipoCarismaOrderByWithAggregationInput[]
    by: TipoCarismaScalarFieldEnum[] | TipoCarismaScalarFieldEnum
    having?: tipoCarismaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoCarismaCountAggregateInputType | true
    _avg?: TipoCarismaAvgAggregateInputType
    _sum?: TipoCarismaSumAggregateInputType
    _min?: TipoCarismaMinAggregateInputType
    _max?: TipoCarismaMaxAggregateInputType
  }

  export type TipoCarismaGroupByOutputType = {
    id: number
    descricao: string
    _count: TipoCarismaCountAggregateOutputType | null
    _avg: TipoCarismaAvgAggregateOutputType | null
    _sum: TipoCarismaSumAggregateOutputType | null
    _min: TipoCarismaMinAggregateOutputType | null
    _max: TipoCarismaMaxAggregateOutputType | null
  }

  type GetTipoCarismaGroupByPayload<T extends tipoCarismaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoCarismaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoCarismaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoCarismaGroupByOutputType[P]>
            : GetScalarType<T[P], TipoCarismaGroupByOutputType[P]>
        }
      >
    >


  export type tipoCarismaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    pessoaCarisma?: boolean | tipoCarisma$pessoaCarismaArgs<ExtArgs>
    _count?: boolean | TipoCarismaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoCarisma"]>

  export type tipoCarismaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoCarisma"]>

  export type tipoCarismaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoCarisma"]>

  export type tipoCarismaSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type tipoCarismaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["tipoCarisma"]>
  export type tipoCarismaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoaCarisma?: boolean | tipoCarisma$pessoaCarismaArgs<ExtArgs>
    _count?: boolean | TipoCarismaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tipoCarismaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tipoCarismaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tipoCarismaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipoCarisma"
    objects: {
      pessoaCarisma: Prisma.$pessoaCarismaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["tipoCarisma"]>
    composites: {}
  }

  type tipoCarismaGetPayload<S extends boolean | null | undefined | tipoCarismaDefaultArgs> = $Result.GetResult<Prisma.$tipoCarismaPayload, S>

  type tipoCarismaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipoCarismaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoCarismaCountAggregateInputType | true
    }

  export interface tipoCarismaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipoCarisma'], meta: { name: 'tipoCarisma' } }
    /**
     * Find zero or one TipoCarisma that matches the filter.
     * @param {tipoCarismaFindUniqueArgs} args - Arguments to find a TipoCarisma
     * @example
     * // Get one TipoCarisma
     * const tipoCarisma = await prisma.tipoCarisma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipoCarismaFindUniqueArgs>(args: SelectSubset<T, tipoCarismaFindUniqueArgs<ExtArgs>>): Prisma__tipoCarismaClient<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoCarisma that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipoCarismaFindUniqueOrThrowArgs} args - Arguments to find a TipoCarisma
     * @example
     * // Get one TipoCarisma
     * const tipoCarisma = await prisma.tipoCarisma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipoCarismaFindUniqueOrThrowArgs>(args: SelectSubset<T, tipoCarismaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipoCarismaClient<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoCarisma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoCarismaFindFirstArgs} args - Arguments to find a TipoCarisma
     * @example
     * // Get one TipoCarisma
     * const tipoCarisma = await prisma.tipoCarisma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipoCarismaFindFirstArgs>(args?: SelectSubset<T, tipoCarismaFindFirstArgs<ExtArgs>>): Prisma__tipoCarismaClient<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoCarisma that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoCarismaFindFirstOrThrowArgs} args - Arguments to find a TipoCarisma
     * @example
     * // Get one TipoCarisma
     * const tipoCarisma = await prisma.tipoCarisma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipoCarismaFindFirstOrThrowArgs>(args?: SelectSubset<T, tipoCarismaFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipoCarismaClient<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoCarismas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoCarismaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoCarismas
     * const tipoCarismas = await prisma.tipoCarisma.findMany()
     * 
     * // Get first 10 TipoCarismas
     * const tipoCarismas = await prisma.tipoCarisma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoCarismaWithIdOnly = await prisma.tipoCarisma.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tipoCarismaFindManyArgs>(args?: SelectSubset<T, tipoCarismaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoCarisma.
     * @param {tipoCarismaCreateArgs} args - Arguments to create a TipoCarisma.
     * @example
     * // Create one TipoCarisma
     * const TipoCarisma = await prisma.tipoCarisma.create({
     *   data: {
     *     // ... data to create a TipoCarisma
     *   }
     * })
     * 
     */
    create<T extends tipoCarismaCreateArgs>(args: SelectSubset<T, tipoCarismaCreateArgs<ExtArgs>>): Prisma__tipoCarismaClient<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoCarismas.
     * @param {tipoCarismaCreateManyArgs} args - Arguments to create many TipoCarismas.
     * @example
     * // Create many TipoCarismas
     * const tipoCarisma = await prisma.tipoCarisma.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipoCarismaCreateManyArgs>(args?: SelectSubset<T, tipoCarismaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoCarismas and returns the data saved in the database.
     * @param {tipoCarismaCreateManyAndReturnArgs} args - Arguments to create many TipoCarismas.
     * @example
     * // Create many TipoCarismas
     * const tipoCarisma = await prisma.tipoCarisma.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoCarismas and only return the `id`
     * const tipoCarismaWithIdOnly = await prisma.tipoCarisma.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tipoCarismaCreateManyAndReturnArgs>(args?: SelectSubset<T, tipoCarismaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoCarisma.
     * @param {tipoCarismaDeleteArgs} args - Arguments to delete one TipoCarisma.
     * @example
     * // Delete one TipoCarisma
     * const TipoCarisma = await prisma.tipoCarisma.delete({
     *   where: {
     *     // ... filter to delete one TipoCarisma
     *   }
     * })
     * 
     */
    delete<T extends tipoCarismaDeleteArgs>(args: SelectSubset<T, tipoCarismaDeleteArgs<ExtArgs>>): Prisma__tipoCarismaClient<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoCarisma.
     * @param {tipoCarismaUpdateArgs} args - Arguments to update one TipoCarisma.
     * @example
     * // Update one TipoCarisma
     * const tipoCarisma = await prisma.tipoCarisma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipoCarismaUpdateArgs>(args: SelectSubset<T, tipoCarismaUpdateArgs<ExtArgs>>): Prisma__tipoCarismaClient<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoCarismas.
     * @param {tipoCarismaDeleteManyArgs} args - Arguments to filter TipoCarismas to delete.
     * @example
     * // Delete a few TipoCarismas
     * const { count } = await prisma.tipoCarisma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipoCarismaDeleteManyArgs>(args?: SelectSubset<T, tipoCarismaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoCarismas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoCarismaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoCarismas
     * const tipoCarisma = await prisma.tipoCarisma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipoCarismaUpdateManyArgs>(args: SelectSubset<T, tipoCarismaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoCarismas and returns the data updated in the database.
     * @param {tipoCarismaUpdateManyAndReturnArgs} args - Arguments to update many TipoCarismas.
     * @example
     * // Update many TipoCarismas
     * const tipoCarisma = await prisma.tipoCarisma.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoCarismas and only return the `id`
     * const tipoCarismaWithIdOnly = await prisma.tipoCarisma.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tipoCarismaUpdateManyAndReturnArgs>(args: SelectSubset<T, tipoCarismaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoCarisma.
     * @param {tipoCarismaUpsertArgs} args - Arguments to update or create a TipoCarisma.
     * @example
     * // Update or create a TipoCarisma
     * const tipoCarisma = await prisma.tipoCarisma.upsert({
     *   create: {
     *     // ... data to create a TipoCarisma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoCarisma we want to update
     *   }
     * })
     */
    upsert<T extends tipoCarismaUpsertArgs>(args: SelectSubset<T, tipoCarismaUpsertArgs<ExtArgs>>): Prisma__tipoCarismaClient<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoCarismas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoCarismaCountArgs} args - Arguments to filter TipoCarismas to count.
     * @example
     * // Count the number of TipoCarismas
     * const count = await prisma.tipoCarisma.count({
     *   where: {
     *     // ... the filter for the TipoCarismas we want to count
     *   }
     * })
    **/
    count<T extends tipoCarismaCountArgs>(
      args?: Subset<T, tipoCarismaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoCarismaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoCarisma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoCarismaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoCarismaAggregateArgs>(args: Subset<T, TipoCarismaAggregateArgs>): Prisma.PrismaPromise<GetTipoCarismaAggregateType<T>>

    /**
     * Group by TipoCarisma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoCarismaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipoCarismaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipoCarismaGroupByArgs['orderBy'] }
        : { orderBy?: tipoCarismaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipoCarismaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoCarismaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipoCarisma model
   */
  readonly fields: tipoCarismaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipoCarisma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipoCarismaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoaCarisma<T extends tipoCarisma$pessoaCarismaArgs<ExtArgs> = {}>(args?: Subset<T, tipoCarisma$pessoaCarismaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipoCarisma model
   */
  interface tipoCarismaFieldRefs {
    readonly id: FieldRef<"tipoCarisma", 'Int'>
    readonly descricao: FieldRef<"tipoCarisma", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tipoCarisma findUnique
   */
  export type tipoCarismaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
    /**
     * Filter, which tipoCarisma to fetch.
     */
    where: tipoCarismaWhereUniqueInput
  }

  /**
   * tipoCarisma findUniqueOrThrow
   */
  export type tipoCarismaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
    /**
     * Filter, which tipoCarisma to fetch.
     */
    where: tipoCarismaWhereUniqueInput
  }

  /**
   * tipoCarisma findFirst
   */
  export type tipoCarismaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
    /**
     * Filter, which tipoCarisma to fetch.
     */
    where?: tipoCarismaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoCarismas to fetch.
     */
    orderBy?: tipoCarismaOrderByWithRelationInput | tipoCarismaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoCarismas.
     */
    cursor?: tipoCarismaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoCarismas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoCarismas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoCarismas.
     */
    distinct?: TipoCarismaScalarFieldEnum | TipoCarismaScalarFieldEnum[]
  }

  /**
   * tipoCarisma findFirstOrThrow
   */
  export type tipoCarismaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
    /**
     * Filter, which tipoCarisma to fetch.
     */
    where?: tipoCarismaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoCarismas to fetch.
     */
    orderBy?: tipoCarismaOrderByWithRelationInput | tipoCarismaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoCarismas.
     */
    cursor?: tipoCarismaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoCarismas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoCarismas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoCarismas.
     */
    distinct?: TipoCarismaScalarFieldEnum | TipoCarismaScalarFieldEnum[]
  }

  /**
   * tipoCarisma findMany
   */
  export type tipoCarismaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
    /**
     * Filter, which tipoCarismas to fetch.
     */
    where?: tipoCarismaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoCarismas to fetch.
     */
    orderBy?: tipoCarismaOrderByWithRelationInput | tipoCarismaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipoCarismas.
     */
    cursor?: tipoCarismaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoCarismas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoCarismas.
     */
    skip?: number
    distinct?: TipoCarismaScalarFieldEnum | TipoCarismaScalarFieldEnum[]
  }

  /**
   * tipoCarisma create
   */
  export type tipoCarismaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
    /**
     * The data needed to create a tipoCarisma.
     */
    data: XOR<tipoCarismaCreateInput, tipoCarismaUncheckedCreateInput>
  }

  /**
   * tipoCarisma createMany
   */
  export type tipoCarismaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipoCarismas.
     */
    data: tipoCarismaCreateManyInput | tipoCarismaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoCarisma createManyAndReturn
   */
  export type tipoCarismaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * The data used to create many tipoCarismas.
     */
    data: tipoCarismaCreateManyInput | tipoCarismaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoCarisma update
   */
  export type tipoCarismaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
    /**
     * The data needed to update a tipoCarisma.
     */
    data: XOR<tipoCarismaUpdateInput, tipoCarismaUncheckedUpdateInput>
    /**
     * Choose, which tipoCarisma to update.
     */
    where: tipoCarismaWhereUniqueInput
  }

  /**
   * tipoCarisma updateMany
   */
  export type tipoCarismaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipoCarismas.
     */
    data: XOR<tipoCarismaUpdateManyMutationInput, tipoCarismaUncheckedUpdateManyInput>
    /**
     * Filter which tipoCarismas to update
     */
    where?: tipoCarismaWhereInput
    /**
     * Limit how many tipoCarismas to update.
     */
    limit?: number
  }

  /**
   * tipoCarisma updateManyAndReturn
   */
  export type tipoCarismaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * The data used to update tipoCarismas.
     */
    data: XOR<tipoCarismaUpdateManyMutationInput, tipoCarismaUncheckedUpdateManyInput>
    /**
     * Filter which tipoCarismas to update
     */
    where?: tipoCarismaWhereInput
    /**
     * Limit how many tipoCarismas to update.
     */
    limit?: number
  }

  /**
   * tipoCarisma upsert
   */
  export type tipoCarismaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
    /**
     * The filter to search for the tipoCarisma to update in case it exists.
     */
    where: tipoCarismaWhereUniqueInput
    /**
     * In case the tipoCarisma found by the `where` argument doesn't exist, create a new tipoCarisma with this data.
     */
    create: XOR<tipoCarismaCreateInput, tipoCarismaUncheckedCreateInput>
    /**
     * In case the tipoCarisma was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipoCarismaUpdateInput, tipoCarismaUncheckedUpdateInput>
  }

  /**
   * tipoCarisma delete
   */
  export type tipoCarismaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
    /**
     * Filter which tipoCarisma to delete.
     */
    where: tipoCarismaWhereUniqueInput
  }

  /**
   * tipoCarisma deleteMany
   */
  export type tipoCarismaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoCarismas to delete
     */
    where?: tipoCarismaWhereInput
    /**
     * Limit how many tipoCarismas to delete.
     */
    limit?: number
  }

  /**
   * tipoCarisma.pessoaCarisma
   */
  export type tipoCarisma$pessoaCarismaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    where?: pessoaCarismaWhereInput
    orderBy?: pessoaCarismaOrderByWithRelationInput | pessoaCarismaOrderByWithRelationInput[]
    cursor?: pessoaCarismaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaCarismaScalarFieldEnum | PessoaCarismaScalarFieldEnum[]
  }

  /**
   * tipoCarisma without action
   */
  export type tipoCarismaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoCarisma
     */
    select?: tipoCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoCarisma
     */
    omit?: tipoCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoCarismaInclude<ExtArgs> | null
  }


  /**
   * Model estadoCivil
   */

  export type AggregateEstadoCivil = {
    _count: EstadoCivilCountAggregateOutputType | null
    _avg: EstadoCivilAvgAggregateOutputType | null
    _sum: EstadoCivilSumAggregateOutputType | null
    _min: EstadoCivilMinAggregateOutputType | null
    _max: EstadoCivilMaxAggregateOutputType | null
  }

  export type EstadoCivilAvgAggregateOutputType = {
    id: number | null
  }

  export type EstadoCivilSumAggregateOutputType = {
    id: number | null
  }

  export type EstadoCivilMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type EstadoCivilMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type EstadoCivilCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type EstadoCivilAvgAggregateInputType = {
    id?: true
  }

  export type EstadoCivilSumAggregateInputType = {
    id?: true
  }

  export type EstadoCivilMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type EstadoCivilMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type EstadoCivilCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type EstadoCivilAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estadoCivil to aggregate.
     */
    where?: estadoCivilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estadoCivils to fetch.
     */
    orderBy?: estadoCivilOrderByWithRelationInput | estadoCivilOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: estadoCivilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estadoCivils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estadoCivils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned estadoCivils
    **/
    _count?: true | EstadoCivilCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EstadoCivilAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EstadoCivilSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EstadoCivilMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EstadoCivilMaxAggregateInputType
  }

  export type GetEstadoCivilAggregateType<T extends EstadoCivilAggregateArgs> = {
        [P in keyof T & keyof AggregateEstadoCivil]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEstadoCivil[P]>
      : GetScalarType<T[P], AggregateEstadoCivil[P]>
  }




  export type estadoCivilGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: estadoCivilWhereInput
    orderBy?: estadoCivilOrderByWithAggregationInput | estadoCivilOrderByWithAggregationInput[]
    by: EstadoCivilScalarFieldEnum[] | EstadoCivilScalarFieldEnum
    having?: estadoCivilScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EstadoCivilCountAggregateInputType | true
    _avg?: EstadoCivilAvgAggregateInputType
    _sum?: EstadoCivilSumAggregateInputType
    _min?: EstadoCivilMinAggregateInputType
    _max?: EstadoCivilMaxAggregateInputType
  }

  export type EstadoCivilGroupByOutputType = {
    id: number
    descricao: string
    _count: EstadoCivilCountAggregateOutputType | null
    _avg: EstadoCivilAvgAggregateOutputType | null
    _sum: EstadoCivilSumAggregateOutputType | null
    _min: EstadoCivilMinAggregateOutputType | null
    _max: EstadoCivilMaxAggregateOutputType | null
  }

  type GetEstadoCivilGroupByPayload<T extends estadoCivilGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EstadoCivilGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EstadoCivilGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EstadoCivilGroupByOutputType[P]>
            : GetScalarType<T[P], EstadoCivilGroupByOutputType[P]>
        }
      >
    >


  export type estadoCivilSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    pessoas?: boolean | estadoCivil$pessoasArgs<ExtArgs>
    _count?: boolean | EstadoCivilCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["estadoCivil"]>

  export type estadoCivilSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["estadoCivil"]>

  export type estadoCivilSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["estadoCivil"]>

  export type estadoCivilSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type estadoCivilOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["estadoCivil"]>
  export type estadoCivilInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoas?: boolean | estadoCivil$pessoasArgs<ExtArgs>
    _count?: boolean | EstadoCivilCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type estadoCivilIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type estadoCivilIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $estadoCivilPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "estadoCivil"
    objects: {
      pessoas: Prisma.$pessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["estadoCivil"]>
    composites: {}
  }

  type estadoCivilGetPayload<S extends boolean | null | undefined | estadoCivilDefaultArgs> = $Result.GetResult<Prisma.$estadoCivilPayload, S>

  type estadoCivilCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<estadoCivilFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EstadoCivilCountAggregateInputType | true
    }

  export interface estadoCivilDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['estadoCivil'], meta: { name: 'estadoCivil' } }
    /**
     * Find zero or one EstadoCivil that matches the filter.
     * @param {estadoCivilFindUniqueArgs} args - Arguments to find a EstadoCivil
     * @example
     * // Get one EstadoCivil
     * const estadoCivil = await prisma.estadoCivil.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends estadoCivilFindUniqueArgs>(args: SelectSubset<T, estadoCivilFindUniqueArgs<ExtArgs>>): Prisma__estadoCivilClient<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EstadoCivil that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {estadoCivilFindUniqueOrThrowArgs} args - Arguments to find a EstadoCivil
     * @example
     * // Get one EstadoCivil
     * const estadoCivil = await prisma.estadoCivil.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends estadoCivilFindUniqueOrThrowArgs>(args: SelectSubset<T, estadoCivilFindUniqueOrThrowArgs<ExtArgs>>): Prisma__estadoCivilClient<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EstadoCivil that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoCivilFindFirstArgs} args - Arguments to find a EstadoCivil
     * @example
     * // Get one EstadoCivil
     * const estadoCivil = await prisma.estadoCivil.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends estadoCivilFindFirstArgs>(args?: SelectSubset<T, estadoCivilFindFirstArgs<ExtArgs>>): Prisma__estadoCivilClient<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EstadoCivil that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoCivilFindFirstOrThrowArgs} args - Arguments to find a EstadoCivil
     * @example
     * // Get one EstadoCivil
     * const estadoCivil = await prisma.estadoCivil.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends estadoCivilFindFirstOrThrowArgs>(args?: SelectSubset<T, estadoCivilFindFirstOrThrowArgs<ExtArgs>>): Prisma__estadoCivilClient<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EstadoCivils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoCivilFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EstadoCivils
     * const estadoCivils = await prisma.estadoCivil.findMany()
     * 
     * // Get first 10 EstadoCivils
     * const estadoCivils = await prisma.estadoCivil.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const estadoCivilWithIdOnly = await prisma.estadoCivil.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends estadoCivilFindManyArgs>(args?: SelectSubset<T, estadoCivilFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EstadoCivil.
     * @param {estadoCivilCreateArgs} args - Arguments to create a EstadoCivil.
     * @example
     * // Create one EstadoCivil
     * const EstadoCivil = await prisma.estadoCivil.create({
     *   data: {
     *     // ... data to create a EstadoCivil
     *   }
     * })
     * 
     */
    create<T extends estadoCivilCreateArgs>(args: SelectSubset<T, estadoCivilCreateArgs<ExtArgs>>): Prisma__estadoCivilClient<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EstadoCivils.
     * @param {estadoCivilCreateManyArgs} args - Arguments to create many EstadoCivils.
     * @example
     * // Create many EstadoCivils
     * const estadoCivil = await prisma.estadoCivil.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends estadoCivilCreateManyArgs>(args?: SelectSubset<T, estadoCivilCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EstadoCivils and returns the data saved in the database.
     * @param {estadoCivilCreateManyAndReturnArgs} args - Arguments to create many EstadoCivils.
     * @example
     * // Create many EstadoCivils
     * const estadoCivil = await prisma.estadoCivil.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EstadoCivils and only return the `id`
     * const estadoCivilWithIdOnly = await prisma.estadoCivil.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends estadoCivilCreateManyAndReturnArgs>(args?: SelectSubset<T, estadoCivilCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EstadoCivil.
     * @param {estadoCivilDeleteArgs} args - Arguments to delete one EstadoCivil.
     * @example
     * // Delete one EstadoCivil
     * const EstadoCivil = await prisma.estadoCivil.delete({
     *   where: {
     *     // ... filter to delete one EstadoCivil
     *   }
     * })
     * 
     */
    delete<T extends estadoCivilDeleteArgs>(args: SelectSubset<T, estadoCivilDeleteArgs<ExtArgs>>): Prisma__estadoCivilClient<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EstadoCivil.
     * @param {estadoCivilUpdateArgs} args - Arguments to update one EstadoCivil.
     * @example
     * // Update one EstadoCivil
     * const estadoCivil = await prisma.estadoCivil.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends estadoCivilUpdateArgs>(args: SelectSubset<T, estadoCivilUpdateArgs<ExtArgs>>): Prisma__estadoCivilClient<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EstadoCivils.
     * @param {estadoCivilDeleteManyArgs} args - Arguments to filter EstadoCivils to delete.
     * @example
     * // Delete a few EstadoCivils
     * const { count } = await prisma.estadoCivil.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends estadoCivilDeleteManyArgs>(args?: SelectSubset<T, estadoCivilDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstadoCivils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoCivilUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EstadoCivils
     * const estadoCivil = await prisma.estadoCivil.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends estadoCivilUpdateManyArgs>(args: SelectSubset<T, estadoCivilUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EstadoCivils and returns the data updated in the database.
     * @param {estadoCivilUpdateManyAndReturnArgs} args - Arguments to update many EstadoCivils.
     * @example
     * // Update many EstadoCivils
     * const estadoCivil = await prisma.estadoCivil.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EstadoCivils and only return the `id`
     * const estadoCivilWithIdOnly = await prisma.estadoCivil.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends estadoCivilUpdateManyAndReturnArgs>(args: SelectSubset<T, estadoCivilUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EstadoCivil.
     * @param {estadoCivilUpsertArgs} args - Arguments to update or create a EstadoCivil.
     * @example
     * // Update or create a EstadoCivil
     * const estadoCivil = await prisma.estadoCivil.upsert({
     *   create: {
     *     // ... data to create a EstadoCivil
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EstadoCivil we want to update
     *   }
     * })
     */
    upsert<T extends estadoCivilUpsertArgs>(args: SelectSubset<T, estadoCivilUpsertArgs<ExtArgs>>): Prisma__estadoCivilClient<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EstadoCivils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoCivilCountArgs} args - Arguments to filter EstadoCivils to count.
     * @example
     * // Count the number of EstadoCivils
     * const count = await prisma.estadoCivil.count({
     *   where: {
     *     // ... the filter for the EstadoCivils we want to count
     *   }
     * })
    **/
    count<T extends estadoCivilCountArgs>(
      args?: Subset<T, estadoCivilCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EstadoCivilCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EstadoCivil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EstadoCivilAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EstadoCivilAggregateArgs>(args: Subset<T, EstadoCivilAggregateArgs>): Prisma.PrismaPromise<GetEstadoCivilAggregateType<T>>

    /**
     * Group by EstadoCivil.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {estadoCivilGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends estadoCivilGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: estadoCivilGroupByArgs['orderBy'] }
        : { orderBy?: estadoCivilGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, estadoCivilGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEstadoCivilGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the estadoCivil model
   */
  readonly fields: estadoCivilFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for estadoCivil.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__estadoCivilClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoas<T extends estadoCivil$pessoasArgs<ExtArgs> = {}>(args?: Subset<T, estadoCivil$pessoasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the estadoCivil model
   */
  interface estadoCivilFieldRefs {
    readonly id: FieldRef<"estadoCivil", 'Int'>
    readonly descricao: FieldRef<"estadoCivil", 'String'>
  }
    

  // Custom InputTypes
  /**
   * estadoCivil findUnique
   */
  export type estadoCivilFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
    /**
     * Filter, which estadoCivil to fetch.
     */
    where: estadoCivilWhereUniqueInput
  }

  /**
   * estadoCivil findUniqueOrThrow
   */
  export type estadoCivilFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
    /**
     * Filter, which estadoCivil to fetch.
     */
    where: estadoCivilWhereUniqueInput
  }

  /**
   * estadoCivil findFirst
   */
  export type estadoCivilFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
    /**
     * Filter, which estadoCivil to fetch.
     */
    where?: estadoCivilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estadoCivils to fetch.
     */
    orderBy?: estadoCivilOrderByWithRelationInput | estadoCivilOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estadoCivils.
     */
    cursor?: estadoCivilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estadoCivils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estadoCivils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estadoCivils.
     */
    distinct?: EstadoCivilScalarFieldEnum | EstadoCivilScalarFieldEnum[]
  }

  /**
   * estadoCivil findFirstOrThrow
   */
  export type estadoCivilFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
    /**
     * Filter, which estadoCivil to fetch.
     */
    where?: estadoCivilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estadoCivils to fetch.
     */
    orderBy?: estadoCivilOrderByWithRelationInput | estadoCivilOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for estadoCivils.
     */
    cursor?: estadoCivilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estadoCivils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estadoCivils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of estadoCivils.
     */
    distinct?: EstadoCivilScalarFieldEnum | EstadoCivilScalarFieldEnum[]
  }

  /**
   * estadoCivil findMany
   */
  export type estadoCivilFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
    /**
     * Filter, which estadoCivils to fetch.
     */
    where?: estadoCivilWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of estadoCivils to fetch.
     */
    orderBy?: estadoCivilOrderByWithRelationInput | estadoCivilOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing estadoCivils.
     */
    cursor?: estadoCivilWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` estadoCivils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` estadoCivils.
     */
    skip?: number
    distinct?: EstadoCivilScalarFieldEnum | EstadoCivilScalarFieldEnum[]
  }

  /**
   * estadoCivil create
   */
  export type estadoCivilCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
    /**
     * The data needed to create a estadoCivil.
     */
    data: XOR<estadoCivilCreateInput, estadoCivilUncheckedCreateInput>
  }

  /**
   * estadoCivil createMany
   */
  export type estadoCivilCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many estadoCivils.
     */
    data: estadoCivilCreateManyInput | estadoCivilCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estadoCivil createManyAndReturn
   */
  export type estadoCivilCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * The data used to create many estadoCivils.
     */
    data: estadoCivilCreateManyInput | estadoCivilCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * estadoCivil update
   */
  export type estadoCivilUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
    /**
     * The data needed to update a estadoCivil.
     */
    data: XOR<estadoCivilUpdateInput, estadoCivilUncheckedUpdateInput>
    /**
     * Choose, which estadoCivil to update.
     */
    where: estadoCivilWhereUniqueInput
  }

  /**
   * estadoCivil updateMany
   */
  export type estadoCivilUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update estadoCivils.
     */
    data: XOR<estadoCivilUpdateManyMutationInput, estadoCivilUncheckedUpdateManyInput>
    /**
     * Filter which estadoCivils to update
     */
    where?: estadoCivilWhereInput
    /**
     * Limit how many estadoCivils to update.
     */
    limit?: number
  }

  /**
   * estadoCivil updateManyAndReturn
   */
  export type estadoCivilUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * The data used to update estadoCivils.
     */
    data: XOR<estadoCivilUpdateManyMutationInput, estadoCivilUncheckedUpdateManyInput>
    /**
     * Filter which estadoCivils to update
     */
    where?: estadoCivilWhereInput
    /**
     * Limit how many estadoCivils to update.
     */
    limit?: number
  }

  /**
   * estadoCivil upsert
   */
  export type estadoCivilUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
    /**
     * The filter to search for the estadoCivil to update in case it exists.
     */
    where: estadoCivilWhereUniqueInput
    /**
     * In case the estadoCivil found by the `where` argument doesn't exist, create a new estadoCivil with this data.
     */
    create: XOR<estadoCivilCreateInput, estadoCivilUncheckedCreateInput>
    /**
     * In case the estadoCivil was found with the provided `where` argument, update it with this data.
     */
    update: XOR<estadoCivilUpdateInput, estadoCivilUncheckedUpdateInput>
  }

  /**
   * estadoCivil delete
   */
  export type estadoCivilDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
    /**
     * Filter which estadoCivil to delete.
     */
    where: estadoCivilWhereUniqueInput
  }

  /**
   * estadoCivil deleteMany
   */
  export type estadoCivilDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which estadoCivils to delete
     */
    where?: estadoCivilWhereInput
    /**
     * Limit how many estadoCivils to delete.
     */
    limit?: number
  }

  /**
   * estadoCivil.pessoas
   */
  export type estadoCivil$pessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    cursor?: pessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * estadoCivil without action
   */
  export type estadoCivilDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the estadoCivil
     */
    select?: estadoCivilSelect<ExtArgs> | null
    /**
     * Omit specific fields from the estadoCivil
     */
    omit?: estadoCivilOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: estadoCivilInclude<ExtArgs> | null
  }


  /**
   * Model escolaridade
   */

  export type AggregateEscolaridade = {
    _count: EscolaridadeCountAggregateOutputType | null
    _avg: EscolaridadeAvgAggregateOutputType | null
    _sum: EscolaridadeSumAggregateOutputType | null
    _min: EscolaridadeMinAggregateOutputType | null
    _max: EscolaridadeMaxAggregateOutputType | null
  }

  export type EscolaridadeAvgAggregateOutputType = {
    id: number | null
  }

  export type EscolaridadeSumAggregateOutputType = {
    id: number | null
  }

  export type EscolaridadeMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type EscolaridadeMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type EscolaridadeCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type EscolaridadeAvgAggregateInputType = {
    id?: true
  }

  export type EscolaridadeSumAggregateInputType = {
    id?: true
  }

  export type EscolaridadeMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type EscolaridadeMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type EscolaridadeCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type EscolaridadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escolaridade to aggregate.
     */
    where?: escolaridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escolaridades to fetch.
     */
    orderBy?: escolaridadeOrderByWithRelationInput | escolaridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: escolaridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escolaridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escolaridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned escolaridades
    **/
    _count?: true | EscolaridadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EscolaridadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EscolaridadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EscolaridadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EscolaridadeMaxAggregateInputType
  }

  export type GetEscolaridadeAggregateType<T extends EscolaridadeAggregateArgs> = {
        [P in keyof T & keyof AggregateEscolaridade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscolaridade[P]>
      : GetScalarType<T[P], AggregateEscolaridade[P]>
  }




  export type escolaridadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: escolaridadeWhereInput
    orderBy?: escolaridadeOrderByWithAggregationInput | escolaridadeOrderByWithAggregationInput[]
    by: EscolaridadeScalarFieldEnum[] | EscolaridadeScalarFieldEnum
    having?: escolaridadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EscolaridadeCountAggregateInputType | true
    _avg?: EscolaridadeAvgAggregateInputType
    _sum?: EscolaridadeSumAggregateInputType
    _min?: EscolaridadeMinAggregateInputType
    _max?: EscolaridadeMaxAggregateInputType
  }

  export type EscolaridadeGroupByOutputType = {
    id: number
    descricao: string
    _count: EscolaridadeCountAggregateOutputType | null
    _avg: EscolaridadeAvgAggregateOutputType | null
    _sum: EscolaridadeSumAggregateOutputType | null
    _min: EscolaridadeMinAggregateOutputType | null
    _max: EscolaridadeMaxAggregateOutputType | null
  }

  type GetEscolaridadeGroupByPayload<T extends escolaridadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EscolaridadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EscolaridadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EscolaridadeGroupByOutputType[P]>
            : GetScalarType<T[P], EscolaridadeGroupByOutputType[P]>
        }
      >
    >


  export type escolaridadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    pessoas?: boolean | escolaridade$pessoasArgs<ExtArgs>
    _count?: boolean | EscolaridadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["escolaridade"]>

  export type escolaridadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["escolaridade"]>

  export type escolaridadeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["escolaridade"]>

  export type escolaridadeSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type escolaridadeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["escolaridade"]>
  export type escolaridadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoas?: boolean | escolaridade$pessoasArgs<ExtArgs>
    _count?: boolean | EscolaridadeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type escolaridadeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type escolaridadeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $escolaridadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "escolaridade"
    objects: {
      pessoas: Prisma.$pessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["escolaridade"]>
    composites: {}
  }

  type escolaridadeGetPayload<S extends boolean | null | undefined | escolaridadeDefaultArgs> = $Result.GetResult<Prisma.$escolaridadePayload, S>

  type escolaridadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<escolaridadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EscolaridadeCountAggregateInputType | true
    }

  export interface escolaridadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['escolaridade'], meta: { name: 'escolaridade' } }
    /**
     * Find zero or one Escolaridade that matches the filter.
     * @param {escolaridadeFindUniqueArgs} args - Arguments to find a Escolaridade
     * @example
     * // Get one Escolaridade
     * const escolaridade = await prisma.escolaridade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends escolaridadeFindUniqueArgs>(args: SelectSubset<T, escolaridadeFindUniqueArgs<ExtArgs>>): Prisma__escolaridadeClient<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Escolaridade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {escolaridadeFindUniqueOrThrowArgs} args - Arguments to find a Escolaridade
     * @example
     * // Get one Escolaridade
     * const escolaridade = await prisma.escolaridade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends escolaridadeFindUniqueOrThrowArgs>(args: SelectSubset<T, escolaridadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__escolaridadeClient<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escolaridade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escolaridadeFindFirstArgs} args - Arguments to find a Escolaridade
     * @example
     * // Get one Escolaridade
     * const escolaridade = await prisma.escolaridade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends escolaridadeFindFirstArgs>(args?: SelectSubset<T, escolaridadeFindFirstArgs<ExtArgs>>): Prisma__escolaridadeClient<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Escolaridade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escolaridadeFindFirstOrThrowArgs} args - Arguments to find a Escolaridade
     * @example
     * // Get one Escolaridade
     * const escolaridade = await prisma.escolaridade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends escolaridadeFindFirstOrThrowArgs>(args?: SelectSubset<T, escolaridadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__escolaridadeClient<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Escolaridades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escolaridadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escolaridades
     * const escolaridades = await prisma.escolaridade.findMany()
     * 
     * // Get first 10 Escolaridades
     * const escolaridades = await prisma.escolaridade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escolaridadeWithIdOnly = await prisma.escolaridade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends escolaridadeFindManyArgs>(args?: SelectSubset<T, escolaridadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Escolaridade.
     * @param {escolaridadeCreateArgs} args - Arguments to create a Escolaridade.
     * @example
     * // Create one Escolaridade
     * const Escolaridade = await prisma.escolaridade.create({
     *   data: {
     *     // ... data to create a Escolaridade
     *   }
     * })
     * 
     */
    create<T extends escolaridadeCreateArgs>(args: SelectSubset<T, escolaridadeCreateArgs<ExtArgs>>): Prisma__escolaridadeClient<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Escolaridades.
     * @param {escolaridadeCreateManyArgs} args - Arguments to create many Escolaridades.
     * @example
     * // Create many Escolaridades
     * const escolaridade = await prisma.escolaridade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends escolaridadeCreateManyArgs>(args?: SelectSubset<T, escolaridadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Escolaridades and returns the data saved in the database.
     * @param {escolaridadeCreateManyAndReturnArgs} args - Arguments to create many Escolaridades.
     * @example
     * // Create many Escolaridades
     * const escolaridade = await prisma.escolaridade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Escolaridades and only return the `id`
     * const escolaridadeWithIdOnly = await prisma.escolaridade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends escolaridadeCreateManyAndReturnArgs>(args?: SelectSubset<T, escolaridadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Escolaridade.
     * @param {escolaridadeDeleteArgs} args - Arguments to delete one Escolaridade.
     * @example
     * // Delete one Escolaridade
     * const Escolaridade = await prisma.escolaridade.delete({
     *   where: {
     *     // ... filter to delete one Escolaridade
     *   }
     * })
     * 
     */
    delete<T extends escolaridadeDeleteArgs>(args: SelectSubset<T, escolaridadeDeleteArgs<ExtArgs>>): Prisma__escolaridadeClient<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Escolaridade.
     * @param {escolaridadeUpdateArgs} args - Arguments to update one Escolaridade.
     * @example
     * // Update one Escolaridade
     * const escolaridade = await prisma.escolaridade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends escolaridadeUpdateArgs>(args: SelectSubset<T, escolaridadeUpdateArgs<ExtArgs>>): Prisma__escolaridadeClient<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Escolaridades.
     * @param {escolaridadeDeleteManyArgs} args - Arguments to filter Escolaridades to delete.
     * @example
     * // Delete a few Escolaridades
     * const { count } = await prisma.escolaridade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends escolaridadeDeleteManyArgs>(args?: SelectSubset<T, escolaridadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escolaridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escolaridadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escolaridades
     * const escolaridade = await prisma.escolaridade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends escolaridadeUpdateManyArgs>(args: SelectSubset<T, escolaridadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escolaridades and returns the data updated in the database.
     * @param {escolaridadeUpdateManyAndReturnArgs} args - Arguments to update many Escolaridades.
     * @example
     * // Update many Escolaridades
     * const escolaridade = await prisma.escolaridade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Escolaridades and only return the `id`
     * const escolaridadeWithIdOnly = await prisma.escolaridade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends escolaridadeUpdateManyAndReturnArgs>(args: SelectSubset<T, escolaridadeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Escolaridade.
     * @param {escolaridadeUpsertArgs} args - Arguments to update or create a Escolaridade.
     * @example
     * // Update or create a Escolaridade
     * const escolaridade = await prisma.escolaridade.upsert({
     *   create: {
     *     // ... data to create a Escolaridade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escolaridade we want to update
     *   }
     * })
     */
    upsert<T extends escolaridadeUpsertArgs>(args: SelectSubset<T, escolaridadeUpsertArgs<ExtArgs>>): Prisma__escolaridadeClient<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Escolaridades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escolaridadeCountArgs} args - Arguments to filter Escolaridades to count.
     * @example
     * // Count the number of Escolaridades
     * const count = await prisma.escolaridade.count({
     *   where: {
     *     // ... the filter for the Escolaridades we want to count
     *   }
     * })
    **/
    count<T extends escolaridadeCountArgs>(
      args?: Subset<T, escolaridadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EscolaridadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escolaridade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EscolaridadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EscolaridadeAggregateArgs>(args: Subset<T, EscolaridadeAggregateArgs>): Prisma.PrismaPromise<GetEscolaridadeAggregateType<T>>

    /**
     * Group by Escolaridade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escolaridadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends escolaridadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: escolaridadeGroupByArgs['orderBy'] }
        : { orderBy?: escolaridadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, escolaridadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscolaridadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the escolaridade model
   */
  readonly fields: escolaridadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for escolaridade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__escolaridadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoas<T extends escolaridade$pessoasArgs<ExtArgs> = {}>(args?: Subset<T, escolaridade$pessoasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the escolaridade model
   */
  interface escolaridadeFieldRefs {
    readonly id: FieldRef<"escolaridade", 'Int'>
    readonly descricao: FieldRef<"escolaridade", 'String'>
  }
    

  // Custom InputTypes
  /**
   * escolaridade findUnique
   */
  export type escolaridadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which escolaridade to fetch.
     */
    where: escolaridadeWhereUniqueInput
  }

  /**
   * escolaridade findUniqueOrThrow
   */
  export type escolaridadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which escolaridade to fetch.
     */
    where: escolaridadeWhereUniqueInput
  }

  /**
   * escolaridade findFirst
   */
  export type escolaridadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which escolaridade to fetch.
     */
    where?: escolaridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escolaridades to fetch.
     */
    orderBy?: escolaridadeOrderByWithRelationInput | escolaridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escolaridades.
     */
    cursor?: escolaridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escolaridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escolaridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escolaridades.
     */
    distinct?: EscolaridadeScalarFieldEnum | EscolaridadeScalarFieldEnum[]
  }

  /**
   * escolaridade findFirstOrThrow
   */
  export type escolaridadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which escolaridade to fetch.
     */
    where?: escolaridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escolaridades to fetch.
     */
    orderBy?: escolaridadeOrderByWithRelationInput | escolaridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escolaridades.
     */
    cursor?: escolaridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escolaridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escolaridades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escolaridades.
     */
    distinct?: EscolaridadeScalarFieldEnum | EscolaridadeScalarFieldEnum[]
  }

  /**
   * escolaridade findMany
   */
  export type escolaridadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    /**
     * Filter, which escolaridades to fetch.
     */
    where?: escolaridadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escolaridades to fetch.
     */
    orderBy?: escolaridadeOrderByWithRelationInput | escolaridadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing escolaridades.
     */
    cursor?: escolaridadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escolaridades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escolaridades.
     */
    skip?: number
    distinct?: EscolaridadeScalarFieldEnum | EscolaridadeScalarFieldEnum[]
  }

  /**
   * escolaridade create
   */
  export type escolaridadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    /**
     * The data needed to create a escolaridade.
     */
    data: XOR<escolaridadeCreateInput, escolaridadeUncheckedCreateInput>
  }

  /**
   * escolaridade createMany
   */
  export type escolaridadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many escolaridades.
     */
    data: escolaridadeCreateManyInput | escolaridadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * escolaridade createManyAndReturn
   */
  export type escolaridadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * The data used to create many escolaridades.
     */
    data: escolaridadeCreateManyInput | escolaridadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * escolaridade update
   */
  export type escolaridadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    /**
     * The data needed to update a escolaridade.
     */
    data: XOR<escolaridadeUpdateInput, escolaridadeUncheckedUpdateInput>
    /**
     * Choose, which escolaridade to update.
     */
    where: escolaridadeWhereUniqueInput
  }

  /**
   * escolaridade updateMany
   */
  export type escolaridadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update escolaridades.
     */
    data: XOR<escolaridadeUpdateManyMutationInput, escolaridadeUncheckedUpdateManyInput>
    /**
     * Filter which escolaridades to update
     */
    where?: escolaridadeWhereInput
    /**
     * Limit how many escolaridades to update.
     */
    limit?: number
  }

  /**
   * escolaridade updateManyAndReturn
   */
  export type escolaridadeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * The data used to update escolaridades.
     */
    data: XOR<escolaridadeUpdateManyMutationInput, escolaridadeUncheckedUpdateManyInput>
    /**
     * Filter which escolaridades to update
     */
    where?: escolaridadeWhereInput
    /**
     * Limit how many escolaridades to update.
     */
    limit?: number
  }

  /**
   * escolaridade upsert
   */
  export type escolaridadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    /**
     * The filter to search for the escolaridade to update in case it exists.
     */
    where: escolaridadeWhereUniqueInput
    /**
     * In case the escolaridade found by the `where` argument doesn't exist, create a new escolaridade with this data.
     */
    create: XOR<escolaridadeCreateInput, escolaridadeUncheckedCreateInput>
    /**
     * In case the escolaridade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<escolaridadeUpdateInput, escolaridadeUncheckedUpdateInput>
  }

  /**
   * escolaridade delete
   */
  export type escolaridadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    /**
     * Filter which escolaridade to delete.
     */
    where: escolaridadeWhereUniqueInput
  }

  /**
   * escolaridade deleteMany
   */
  export type escolaridadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escolaridades to delete
     */
    where?: escolaridadeWhereInput
    /**
     * Limit how many escolaridades to delete.
     */
    limit?: number
  }

  /**
   * escolaridade.pessoas
   */
  export type escolaridade$pessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    cursor?: pessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * escolaridade without action
   */
  export type escolaridadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
  }


  /**
   * Model pessoa
   */

  export type AggregatePessoa = {
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  export type PessoaAvgAggregateOutputType = {
    id: number | null
    estadoCivilId: number | null
    escolaridadeId: number | null
    tipoPessoaId: number | null
  }

  export type PessoaSumAggregateOutputType = {
    id: number | null
    estadoCivilId: number | null
    escolaridadeId: number | null
    tipoPessoaId: number | null
  }

  export type PessoaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    conhecidoPor: string | null
    sexo: $Enums.Sexo | null
    cpf: string | null
    nacionalidade: string | null
    dataNascimento: Date | null
    estadoCivilId: number | null
    foto: string | null
    escolaridadeId: number | null
    ativo: boolean | null
    tipoPessoaId: number | null
  }

  export type PessoaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    conhecidoPor: string | null
    sexo: $Enums.Sexo | null
    cpf: string | null
    nacionalidade: string | null
    dataNascimento: Date | null
    estadoCivilId: number | null
    foto: string | null
    escolaridadeId: number | null
    ativo: boolean | null
    tipoPessoaId: number | null
  }

  export type PessoaCountAggregateOutputType = {
    id: number
    nome: number
    conhecidoPor: number
    sexo: number
    cpf: number
    nacionalidade: number
    dataNascimento: number
    estadoCivilId: number
    foto: number
    escolaridadeId: number
    ativo: number
    tipoPessoaId: number
    _all: number
  }


  export type PessoaAvgAggregateInputType = {
    id?: true
    estadoCivilId?: true
    escolaridadeId?: true
    tipoPessoaId?: true
  }

  export type PessoaSumAggregateInputType = {
    id?: true
    estadoCivilId?: true
    escolaridadeId?: true
    tipoPessoaId?: true
  }

  export type PessoaMinAggregateInputType = {
    id?: true
    nome?: true
    conhecidoPor?: true
    sexo?: true
    cpf?: true
    nacionalidade?: true
    dataNascimento?: true
    estadoCivilId?: true
    foto?: true
    escolaridadeId?: true
    ativo?: true
    tipoPessoaId?: true
  }

  export type PessoaMaxAggregateInputType = {
    id?: true
    nome?: true
    conhecidoPor?: true
    sexo?: true
    cpf?: true
    nacionalidade?: true
    dataNascimento?: true
    estadoCivilId?: true
    foto?: true
    escolaridadeId?: true
    ativo?: true
    tipoPessoaId?: true
  }

  export type PessoaCountAggregateInputType = {
    id?: true
    nome?: true
    conhecidoPor?: true
    sexo?: true
    cpf?: true
    nacionalidade?: true
    dataNascimento?: true
    estadoCivilId?: true
    foto?: true
    escolaridadeId?: true
    ativo?: true
    tipoPessoaId?: true
    _all?: true
  }

  export type PessoaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoa to aggregate.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pessoas
    **/
    _count?: true | PessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaMaxAggregateInputType
  }

  export type GetPessoaAggregateType<T extends PessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoa[P]>
      : GetScalarType<T[P], AggregatePessoa[P]>
  }




  export type pessoaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithAggregationInput | pessoaOrderByWithAggregationInput[]
    by: PessoaScalarFieldEnum[] | PessoaScalarFieldEnum
    having?: pessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCountAggregateInputType | true
    _avg?: PessoaAvgAggregateInputType
    _sum?: PessoaSumAggregateInputType
    _min?: PessoaMinAggregateInputType
    _max?: PessoaMaxAggregateInputType
  }

  export type PessoaGroupByOutputType = {
    id: number
    nome: string
    conhecidoPor: string | null
    sexo: $Enums.Sexo
    cpf: string | null
    nacionalidade: string
    dataNascimento: Date | null
    estadoCivilId: number
    foto: string | null
    escolaridadeId: number | null
    ativo: boolean
    tipoPessoaId: number
    _count: PessoaCountAggregateOutputType | null
    _avg: PessoaAvgAggregateOutputType | null
    _sum: PessoaSumAggregateOutputType | null
    _min: PessoaMinAggregateOutputType | null
    _max: PessoaMaxAggregateOutputType | null
  }

  type GetPessoaGroupByPayload<T extends pessoaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaGroupByOutputType[P]>
        }
      >
    >


  export type pessoaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    conhecidoPor?: boolean
    sexo?: boolean
    cpf?: boolean
    nacionalidade?: boolean
    dataNascimento?: boolean
    estadoCivilId?: boolean
    foto?: boolean
    escolaridadeId?: boolean
    ativo?: boolean
    tipoPessoaId?: boolean
    estadoCivil?: boolean | estadoCivilDefaultArgs<ExtArgs>
    escolaridade?: boolean | pessoa$escolaridadeArgs<ExtArgs>
    tipoPessoa?: boolean | tipoPessoaDefaultArgs<ExtArgs>
    passaportes?: boolean | pessoa$passaportesArgs<ExtArgs>
    contatos?: boolean | pessoa$contatosArgs<ExtArgs>
    paroquias?: boolean | pessoa$paroquiasArgs<ExtArgs>
    casamentosComoMarido?: boolean | pessoa$casamentosComoMaridoArgs<ExtArgs>
    casamentosComoMulher?: boolean | pessoa$casamentosComoMulherArgs<ExtArgs>
    enderecos?: boolean | pessoa$enderecosArgs<ExtArgs>
    equipes?: boolean | pessoa$equipesArgs<ExtArgs>
    pessoaCarisma?: boolean | pessoa$pessoaCarismaArgs<ExtArgs>
    _count?: boolean | PessoaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoa"]>

  export type pessoaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    conhecidoPor?: boolean
    sexo?: boolean
    cpf?: boolean
    nacionalidade?: boolean
    dataNascimento?: boolean
    estadoCivilId?: boolean
    foto?: boolean
    escolaridadeId?: boolean
    ativo?: boolean
    tipoPessoaId?: boolean
    estadoCivil?: boolean | estadoCivilDefaultArgs<ExtArgs>
    escolaridade?: boolean | pessoa$escolaridadeArgs<ExtArgs>
    tipoPessoa?: boolean | tipoPessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoa"]>

  export type pessoaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    conhecidoPor?: boolean
    sexo?: boolean
    cpf?: boolean
    nacionalidade?: boolean
    dataNascimento?: boolean
    estadoCivilId?: boolean
    foto?: boolean
    escolaridadeId?: boolean
    ativo?: boolean
    tipoPessoaId?: boolean
    estadoCivil?: boolean | estadoCivilDefaultArgs<ExtArgs>
    escolaridade?: boolean | pessoa$escolaridadeArgs<ExtArgs>
    tipoPessoa?: boolean | tipoPessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoa"]>

  export type pessoaSelectScalar = {
    id?: boolean
    nome?: boolean
    conhecidoPor?: boolean
    sexo?: boolean
    cpf?: boolean
    nacionalidade?: boolean
    dataNascimento?: boolean
    estadoCivilId?: boolean
    foto?: boolean
    escolaridadeId?: boolean
    ativo?: boolean
    tipoPessoaId?: boolean
  }

  export type pessoaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "conhecidoPor" | "sexo" | "cpf" | "nacionalidade" | "dataNascimento" | "estadoCivilId" | "foto" | "escolaridadeId" | "ativo" | "tipoPessoaId", ExtArgs["result"]["pessoa"]>
  export type pessoaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estadoCivil?: boolean | estadoCivilDefaultArgs<ExtArgs>
    escolaridade?: boolean | pessoa$escolaridadeArgs<ExtArgs>
    tipoPessoa?: boolean | tipoPessoaDefaultArgs<ExtArgs>
    passaportes?: boolean | pessoa$passaportesArgs<ExtArgs>
    contatos?: boolean | pessoa$contatosArgs<ExtArgs>
    paroquias?: boolean | pessoa$paroquiasArgs<ExtArgs>
    casamentosComoMarido?: boolean | pessoa$casamentosComoMaridoArgs<ExtArgs>
    casamentosComoMulher?: boolean | pessoa$casamentosComoMulherArgs<ExtArgs>
    enderecos?: boolean | pessoa$enderecosArgs<ExtArgs>
    equipes?: boolean | pessoa$equipesArgs<ExtArgs>
    pessoaCarisma?: boolean | pessoa$pessoaCarismaArgs<ExtArgs>
    _count?: boolean | PessoaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type pessoaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estadoCivil?: boolean | estadoCivilDefaultArgs<ExtArgs>
    escolaridade?: boolean | pessoa$escolaridadeArgs<ExtArgs>
    tipoPessoa?: boolean | tipoPessoaDefaultArgs<ExtArgs>
  }
  export type pessoaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    estadoCivil?: boolean | estadoCivilDefaultArgs<ExtArgs>
    escolaridade?: boolean | pessoa$escolaridadeArgs<ExtArgs>
    tipoPessoa?: boolean | tipoPessoaDefaultArgs<ExtArgs>
  }

  export type $pessoaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pessoa"
    objects: {
      estadoCivil: Prisma.$estadoCivilPayload<ExtArgs>
      escolaridade: Prisma.$escolaridadePayload<ExtArgs> | null
      tipoPessoa: Prisma.$tipoPessoaPayload<ExtArgs>
      passaportes: Prisma.$passaportePessoaPayload<ExtArgs>[]
      contatos: Prisma.$pessoaContatoPayload<ExtArgs>[]
      paroquias: Prisma.$paroquiaPessoasPayload<ExtArgs>[]
      casamentosComoMarido: Prisma.$pessoaCasalPayload<ExtArgs>[]
      casamentosComoMulher: Prisma.$pessoaCasalPayload<ExtArgs>[]
      enderecos: Prisma.$pessoaEnderecoPayload<ExtArgs>[]
      equipes: Prisma.$equipePessoasPayload<ExtArgs>[]
      pessoaCarisma: Prisma.$pessoaCarismaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      conhecidoPor: string | null
      sexo: $Enums.Sexo
      cpf: string | null
      nacionalidade: string
      dataNascimento: Date | null
      estadoCivilId: number
      foto: string | null
      escolaridadeId: number | null
      ativo: boolean
      tipoPessoaId: number
    }, ExtArgs["result"]["pessoa"]>
    composites: {}
  }

  type pessoaGetPayload<S extends boolean | null | undefined | pessoaDefaultArgs> = $Result.GetResult<Prisma.$pessoaPayload, S>

  type pessoaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pessoaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PessoaCountAggregateInputType | true
    }

  export interface pessoaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pessoa'], meta: { name: 'pessoa' } }
    /**
     * Find zero or one Pessoa that matches the filter.
     * @param {pessoaFindUniqueArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pessoaFindUniqueArgs>(args: SelectSubset<T, pessoaFindUniqueArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pessoa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pessoaFindUniqueOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pessoaFindUniqueOrThrowArgs>(args: SelectSubset<T, pessoaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pessoaFindFirstArgs>(args?: SelectSubset<T, pessoaFindFirstArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pessoa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindFirstOrThrowArgs} args - Arguments to find a Pessoa
     * @example
     * // Get one Pessoa
     * const pessoa = await prisma.pessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pessoaFindFirstOrThrowArgs>(args?: SelectSubset<T, pessoaFindFirstOrThrowArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pessoas
     * const pessoas = await prisma.pessoa.findMany()
     * 
     * // Get first 10 Pessoas
     * const pessoas = await prisma.pessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pessoaFindManyArgs>(args?: SelectSubset<T, pessoaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pessoa.
     * @param {pessoaCreateArgs} args - Arguments to create a Pessoa.
     * @example
     * // Create one Pessoa
     * const Pessoa = await prisma.pessoa.create({
     *   data: {
     *     // ... data to create a Pessoa
     *   }
     * })
     * 
     */
    create<T extends pessoaCreateArgs>(args: SelectSubset<T, pessoaCreateArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pessoas.
     * @param {pessoaCreateManyArgs} args - Arguments to create many Pessoas.
     * @example
     * // Create many Pessoas
     * const pessoa = await prisma.pessoa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pessoaCreateManyArgs>(args?: SelectSubset<T, pessoaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pessoas and returns the data saved in the database.
     * @param {pessoaCreateManyAndReturnArgs} args - Arguments to create many Pessoas.
     * @example
     * // Create many Pessoas
     * const pessoa = await prisma.pessoa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pessoas and only return the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pessoaCreateManyAndReturnArgs>(args?: SelectSubset<T, pessoaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pessoa.
     * @param {pessoaDeleteArgs} args - Arguments to delete one Pessoa.
     * @example
     * // Delete one Pessoa
     * const Pessoa = await prisma.pessoa.delete({
     *   where: {
     *     // ... filter to delete one Pessoa
     *   }
     * })
     * 
     */
    delete<T extends pessoaDeleteArgs>(args: SelectSubset<T, pessoaDeleteArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pessoa.
     * @param {pessoaUpdateArgs} args - Arguments to update one Pessoa.
     * @example
     * // Update one Pessoa
     * const pessoa = await prisma.pessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pessoaUpdateArgs>(args: SelectSubset<T, pessoaUpdateArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pessoas.
     * @param {pessoaDeleteManyArgs} args - Arguments to filter Pessoas to delete.
     * @example
     * // Delete a few Pessoas
     * const { count } = await prisma.pessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pessoaDeleteManyArgs>(args?: SelectSubset<T, pessoaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pessoaUpdateManyArgs>(args: SelectSubset<T, pessoaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pessoas and returns the data updated in the database.
     * @param {pessoaUpdateManyAndReturnArgs} args - Arguments to update many Pessoas.
     * @example
     * // Update many Pessoas
     * const pessoa = await prisma.pessoa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pessoas and only return the `id`
     * const pessoaWithIdOnly = await prisma.pessoa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pessoaUpdateManyAndReturnArgs>(args: SelectSubset<T, pessoaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pessoa.
     * @param {pessoaUpsertArgs} args - Arguments to update or create a Pessoa.
     * @example
     * // Update or create a Pessoa
     * const pessoa = await prisma.pessoa.upsert({
     *   create: {
     *     // ... data to create a Pessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pessoa we want to update
     *   }
     * })
     */
    upsert<T extends pessoaUpsertArgs>(args: SelectSubset<T, pessoaUpsertArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCountArgs} args - Arguments to filter Pessoas to count.
     * @example
     * // Count the number of Pessoas
     * const count = await prisma.pessoa.count({
     *   where: {
     *     // ... the filter for the Pessoas we want to count
     *   }
     * })
    **/
    count<T extends pessoaCountArgs>(
      args?: Subset<T, pessoaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaAggregateArgs>(args: Subset<T, PessoaAggregateArgs>): Prisma.PrismaPromise<GetPessoaAggregateType<T>>

    /**
     * Group by Pessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pessoaGroupByArgs['orderBy'] }
        : { orderBy?: pessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pessoa model
   */
  readonly fields: pessoaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pessoaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    estadoCivil<T extends estadoCivilDefaultArgs<ExtArgs> = {}>(args?: Subset<T, estadoCivilDefaultArgs<ExtArgs>>): Prisma__estadoCivilClient<$Result.GetResult<Prisma.$estadoCivilPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    escolaridade<T extends pessoa$escolaridadeArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$escolaridadeArgs<ExtArgs>>): Prisma__escolaridadeClient<$Result.GetResult<Prisma.$escolaridadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tipoPessoa<T extends tipoPessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipoPessoaDefaultArgs<ExtArgs>>): Prisma__tipoPessoaClient<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    passaportes<T extends pessoa$passaportesArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$passaportesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contatos<T extends pessoa$contatosArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$contatosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paroquias<T extends pessoa$paroquiasArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$paroquiasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    casamentosComoMarido<T extends pessoa$casamentosComoMaridoArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$casamentosComoMaridoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    casamentosComoMulher<T extends pessoa$casamentosComoMulherArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$casamentosComoMulherArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enderecos<T extends pessoa$enderecosArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$enderecosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipes<T extends pessoa$equipesArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$equipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pessoaCarisma<T extends pessoa$pessoaCarismaArgs<ExtArgs> = {}>(args?: Subset<T, pessoa$pessoaCarismaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pessoa model
   */
  interface pessoaFieldRefs {
    readonly id: FieldRef<"pessoa", 'Int'>
    readonly nome: FieldRef<"pessoa", 'String'>
    readonly conhecidoPor: FieldRef<"pessoa", 'String'>
    readonly sexo: FieldRef<"pessoa", 'Sexo'>
    readonly cpf: FieldRef<"pessoa", 'String'>
    readonly nacionalidade: FieldRef<"pessoa", 'String'>
    readonly dataNascimento: FieldRef<"pessoa", 'DateTime'>
    readonly estadoCivilId: FieldRef<"pessoa", 'Int'>
    readonly foto: FieldRef<"pessoa", 'String'>
    readonly escolaridadeId: FieldRef<"pessoa", 'Int'>
    readonly ativo: FieldRef<"pessoa", 'Boolean'>
    readonly tipoPessoaId: FieldRef<"pessoa", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pessoa findUnique
   */
  export type pessoaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa findUniqueOrThrow
   */
  export type pessoaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa findFirst
   */
  export type pessoaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoas.
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pessoa findFirstOrThrow
   */
  export type pessoaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoa to fetch.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoas.
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoas.
     */
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pessoa findMany
   */
  export type pessoaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter, which pessoas to fetch.
     */
    where?: pessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoas to fetch.
     */
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pessoas.
     */
    cursor?: pessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoas.
     */
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * pessoa create
   */
  export type pessoaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * The data needed to create a pessoa.
     */
    data: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
  }

  /**
   * pessoa createMany
   */
  export type pessoaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pessoas.
     */
    data: pessoaCreateManyInput | pessoaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pessoa createManyAndReturn
   */
  export type pessoaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * The data used to create many pessoas.
     */
    data: pessoaCreateManyInput | pessoaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoa update
   */
  export type pessoaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * The data needed to update a pessoa.
     */
    data: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
    /**
     * Choose, which pessoa to update.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa updateMany
   */
  export type pessoaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pessoas.
     */
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyInput>
    /**
     * Filter which pessoas to update
     */
    where?: pessoaWhereInput
    /**
     * Limit how many pessoas to update.
     */
    limit?: number
  }

  /**
   * pessoa updateManyAndReturn
   */
  export type pessoaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * The data used to update pessoas.
     */
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyInput>
    /**
     * Filter which pessoas to update
     */
    where?: pessoaWhereInput
    /**
     * Limit how many pessoas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoa upsert
   */
  export type pessoaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * The filter to search for the pessoa to update in case it exists.
     */
    where: pessoaWhereUniqueInput
    /**
     * In case the pessoa found by the `where` argument doesn't exist, create a new pessoa with this data.
     */
    create: XOR<pessoaCreateInput, pessoaUncheckedCreateInput>
    /**
     * In case the pessoa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pessoaUpdateInput, pessoaUncheckedUpdateInput>
  }

  /**
   * pessoa delete
   */
  export type pessoaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    /**
     * Filter which pessoa to delete.
     */
    where: pessoaWhereUniqueInput
  }

  /**
   * pessoa deleteMany
   */
  export type pessoaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoas to delete
     */
    where?: pessoaWhereInput
    /**
     * Limit how many pessoas to delete.
     */
    limit?: number
  }

  /**
   * pessoa.escolaridade
   */
  export type pessoa$escolaridadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escolaridade
     */
    select?: escolaridadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the escolaridade
     */
    omit?: escolaridadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escolaridadeInclude<ExtArgs> | null
    where?: escolaridadeWhereInput
  }

  /**
   * pessoa.passaportes
   */
  export type pessoa$passaportesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    where?: passaportePessoaWhereInput
    orderBy?: passaportePessoaOrderByWithRelationInput | passaportePessoaOrderByWithRelationInput[]
    cursor?: passaportePessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PassaportePessoaScalarFieldEnum | PassaportePessoaScalarFieldEnum[]
  }

  /**
   * pessoa.contatos
   */
  export type pessoa$contatosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    where?: pessoaContatoWhereInput
    orderBy?: pessoaContatoOrderByWithRelationInput | pessoaContatoOrderByWithRelationInput[]
    cursor?: pessoaContatoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaContatoScalarFieldEnum | PessoaContatoScalarFieldEnum[]
  }

  /**
   * pessoa.paroquias
   */
  export type pessoa$paroquiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    where?: paroquiaPessoasWhereInput
    orderBy?: paroquiaPessoasOrderByWithRelationInput | paroquiaPessoasOrderByWithRelationInput[]
    cursor?: paroquiaPessoasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParoquiaPessoasScalarFieldEnum | ParoquiaPessoasScalarFieldEnum[]
  }

  /**
   * pessoa.casamentosComoMarido
   */
  export type pessoa$casamentosComoMaridoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    where?: pessoaCasalWhereInput
    orderBy?: pessoaCasalOrderByWithRelationInput | pessoaCasalOrderByWithRelationInput[]
    cursor?: pessoaCasalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaCasalScalarFieldEnum | PessoaCasalScalarFieldEnum[]
  }

  /**
   * pessoa.casamentosComoMulher
   */
  export type pessoa$casamentosComoMulherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    where?: pessoaCasalWhereInput
    orderBy?: pessoaCasalOrderByWithRelationInput | pessoaCasalOrderByWithRelationInput[]
    cursor?: pessoaCasalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaCasalScalarFieldEnum | PessoaCasalScalarFieldEnum[]
  }

  /**
   * pessoa.enderecos
   */
  export type pessoa$enderecosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    where?: pessoaEnderecoWhereInput
    orderBy?: pessoaEnderecoOrderByWithRelationInput | pessoaEnderecoOrderByWithRelationInput[]
    cursor?: pessoaEnderecoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaEnderecoScalarFieldEnum | PessoaEnderecoScalarFieldEnum[]
  }

  /**
   * pessoa.equipes
   */
  export type pessoa$equipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    where?: equipePessoasWhereInput
    orderBy?: equipePessoasOrderByWithRelationInput | equipePessoasOrderByWithRelationInput[]
    cursor?: equipePessoasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipePessoasScalarFieldEnum | EquipePessoasScalarFieldEnum[]
  }

  /**
   * pessoa.pessoaCarisma
   */
  export type pessoa$pessoaCarismaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    where?: pessoaCarismaWhereInput
    orderBy?: pessoaCarismaOrderByWithRelationInput | pessoaCarismaOrderByWithRelationInput[]
    cursor?: pessoaCarismaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaCarismaScalarFieldEnum | PessoaCarismaScalarFieldEnum[]
  }

  /**
   * pessoa without action
   */
  export type pessoaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
  }


  /**
   * Model tipoPessoa
   */

  export type AggregateTipoPessoa = {
    _count: TipoPessoaCountAggregateOutputType | null
    _avg: TipoPessoaAvgAggregateOutputType | null
    _sum: TipoPessoaSumAggregateOutputType | null
    _min: TipoPessoaMinAggregateOutputType | null
    _max: TipoPessoaMaxAggregateOutputType | null
  }

  export type TipoPessoaAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoPessoaSumAggregateOutputType = {
    id: number | null
  }

  export type TipoPessoaMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoPessoaMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoPessoaCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type TipoPessoaAvgAggregateInputType = {
    id?: true
  }

  export type TipoPessoaSumAggregateInputType = {
    id?: true
  }

  export type TipoPessoaMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoPessoaMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoPessoaCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type TipoPessoaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoPessoa to aggregate.
     */
    where?: tipoPessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoPessoas to fetch.
     */
    orderBy?: tipoPessoaOrderByWithRelationInput | tipoPessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipoPessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoPessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoPessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipoPessoas
    **/
    _count?: true | TipoPessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoPessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoPessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoPessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoPessoaMaxAggregateInputType
  }

  export type GetTipoPessoaAggregateType<T extends TipoPessoaAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoPessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoPessoa[P]>
      : GetScalarType<T[P], AggregateTipoPessoa[P]>
  }




  export type tipoPessoaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipoPessoaWhereInput
    orderBy?: tipoPessoaOrderByWithAggregationInput | tipoPessoaOrderByWithAggregationInput[]
    by: TipoPessoaScalarFieldEnum[] | TipoPessoaScalarFieldEnum
    having?: tipoPessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoPessoaCountAggregateInputType | true
    _avg?: TipoPessoaAvgAggregateInputType
    _sum?: TipoPessoaSumAggregateInputType
    _min?: TipoPessoaMinAggregateInputType
    _max?: TipoPessoaMaxAggregateInputType
  }

  export type TipoPessoaGroupByOutputType = {
    id: number
    descricao: string
    _count: TipoPessoaCountAggregateOutputType | null
    _avg: TipoPessoaAvgAggregateOutputType | null
    _sum: TipoPessoaSumAggregateOutputType | null
    _min: TipoPessoaMinAggregateOutputType | null
    _max: TipoPessoaMaxAggregateOutputType | null
  }

  type GetTipoPessoaGroupByPayload<T extends tipoPessoaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoPessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoPessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoPessoaGroupByOutputType[P]>
            : GetScalarType<T[P], TipoPessoaGroupByOutputType[P]>
        }
      >
    >


  export type tipoPessoaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    pessoa?: boolean | tipoPessoa$pessoaArgs<ExtArgs>
    _count?: boolean | TipoPessoaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoPessoa"]>

  export type tipoPessoaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoPessoa"]>

  export type tipoPessoaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoPessoa"]>

  export type tipoPessoaSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type tipoPessoaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["tipoPessoa"]>
  export type tipoPessoaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | tipoPessoa$pessoaArgs<ExtArgs>
    _count?: boolean | TipoPessoaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tipoPessoaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tipoPessoaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tipoPessoaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipoPessoa"
    objects: {
      pessoa: Prisma.$pessoaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["tipoPessoa"]>
    composites: {}
  }

  type tipoPessoaGetPayload<S extends boolean | null | undefined | tipoPessoaDefaultArgs> = $Result.GetResult<Prisma.$tipoPessoaPayload, S>

  type tipoPessoaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipoPessoaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoPessoaCountAggregateInputType | true
    }

  export interface tipoPessoaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipoPessoa'], meta: { name: 'tipoPessoa' } }
    /**
     * Find zero or one TipoPessoa that matches the filter.
     * @param {tipoPessoaFindUniqueArgs} args - Arguments to find a TipoPessoa
     * @example
     * // Get one TipoPessoa
     * const tipoPessoa = await prisma.tipoPessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipoPessoaFindUniqueArgs>(args: SelectSubset<T, tipoPessoaFindUniqueArgs<ExtArgs>>): Prisma__tipoPessoaClient<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoPessoa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipoPessoaFindUniqueOrThrowArgs} args - Arguments to find a TipoPessoa
     * @example
     * // Get one TipoPessoa
     * const tipoPessoa = await prisma.tipoPessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipoPessoaFindUniqueOrThrowArgs>(args: SelectSubset<T, tipoPessoaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipoPessoaClient<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoPessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoPessoaFindFirstArgs} args - Arguments to find a TipoPessoa
     * @example
     * // Get one TipoPessoa
     * const tipoPessoa = await prisma.tipoPessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipoPessoaFindFirstArgs>(args?: SelectSubset<T, tipoPessoaFindFirstArgs<ExtArgs>>): Prisma__tipoPessoaClient<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoPessoa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoPessoaFindFirstOrThrowArgs} args - Arguments to find a TipoPessoa
     * @example
     * // Get one TipoPessoa
     * const tipoPessoa = await prisma.tipoPessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipoPessoaFindFirstOrThrowArgs>(args?: SelectSubset<T, tipoPessoaFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipoPessoaClient<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoPessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoPessoaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoPessoas
     * const tipoPessoas = await prisma.tipoPessoa.findMany()
     * 
     * // Get first 10 TipoPessoas
     * const tipoPessoas = await prisma.tipoPessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoPessoaWithIdOnly = await prisma.tipoPessoa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tipoPessoaFindManyArgs>(args?: SelectSubset<T, tipoPessoaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoPessoa.
     * @param {tipoPessoaCreateArgs} args - Arguments to create a TipoPessoa.
     * @example
     * // Create one TipoPessoa
     * const TipoPessoa = await prisma.tipoPessoa.create({
     *   data: {
     *     // ... data to create a TipoPessoa
     *   }
     * })
     * 
     */
    create<T extends tipoPessoaCreateArgs>(args: SelectSubset<T, tipoPessoaCreateArgs<ExtArgs>>): Prisma__tipoPessoaClient<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoPessoas.
     * @param {tipoPessoaCreateManyArgs} args - Arguments to create many TipoPessoas.
     * @example
     * // Create many TipoPessoas
     * const tipoPessoa = await prisma.tipoPessoa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipoPessoaCreateManyArgs>(args?: SelectSubset<T, tipoPessoaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoPessoas and returns the data saved in the database.
     * @param {tipoPessoaCreateManyAndReturnArgs} args - Arguments to create many TipoPessoas.
     * @example
     * // Create many TipoPessoas
     * const tipoPessoa = await prisma.tipoPessoa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoPessoas and only return the `id`
     * const tipoPessoaWithIdOnly = await prisma.tipoPessoa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tipoPessoaCreateManyAndReturnArgs>(args?: SelectSubset<T, tipoPessoaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoPessoa.
     * @param {tipoPessoaDeleteArgs} args - Arguments to delete one TipoPessoa.
     * @example
     * // Delete one TipoPessoa
     * const TipoPessoa = await prisma.tipoPessoa.delete({
     *   where: {
     *     // ... filter to delete one TipoPessoa
     *   }
     * })
     * 
     */
    delete<T extends tipoPessoaDeleteArgs>(args: SelectSubset<T, tipoPessoaDeleteArgs<ExtArgs>>): Prisma__tipoPessoaClient<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoPessoa.
     * @param {tipoPessoaUpdateArgs} args - Arguments to update one TipoPessoa.
     * @example
     * // Update one TipoPessoa
     * const tipoPessoa = await prisma.tipoPessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipoPessoaUpdateArgs>(args: SelectSubset<T, tipoPessoaUpdateArgs<ExtArgs>>): Prisma__tipoPessoaClient<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoPessoas.
     * @param {tipoPessoaDeleteManyArgs} args - Arguments to filter TipoPessoas to delete.
     * @example
     * // Delete a few TipoPessoas
     * const { count } = await prisma.tipoPessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipoPessoaDeleteManyArgs>(args?: SelectSubset<T, tipoPessoaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoPessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoPessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoPessoas
     * const tipoPessoa = await prisma.tipoPessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipoPessoaUpdateManyArgs>(args: SelectSubset<T, tipoPessoaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoPessoas and returns the data updated in the database.
     * @param {tipoPessoaUpdateManyAndReturnArgs} args - Arguments to update many TipoPessoas.
     * @example
     * // Update many TipoPessoas
     * const tipoPessoa = await prisma.tipoPessoa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoPessoas and only return the `id`
     * const tipoPessoaWithIdOnly = await prisma.tipoPessoa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tipoPessoaUpdateManyAndReturnArgs>(args: SelectSubset<T, tipoPessoaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoPessoa.
     * @param {tipoPessoaUpsertArgs} args - Arguments to update or create a TipoPessoa.
     * @example
     * // Update or create a TipoPessoa
     * const tipoPessoa = await prisma.tipoPessoa.upsert({
     *   create: {
     *     // ... data to create a TipoPessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoPessoa we want to update
     *   }
     * })
     */
    upsert<T extends tipoPessoaUpsertArgs>(args: SelectSubset<T, tipoPessoaUpsertArgs<ExtArgs>>): Prisma__tipoPessoaClient<$Result.GetResult<Prisma.$tipoPessoaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoPessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoPessoaCountArgs} args - Arguments to filter TipoPessoas to count.
     * @example
     * // Count the number of TipoPessoas
     * const count = await prisma.tipoPessoa.count({
     *   where: {
     *     // ... the filter for the TipoPessoas we want to count
     *   }
     * })
    **/
    count<T extends tipoPessoaCountArgs>(
      args?: Subset<T, tipoPessoaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoPessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoPessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoPessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoPessoaAggregateArgs>(args: Subset<T, TipoPessoaAggregateArgs>): Prisma.PrismaPromise<GetTipoPessoaAggregateType<T>>

    /**
     * Group by TipoPessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoPessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipoPessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipoPessoaGroupByArgs['orderBy'] }
        : { orderBy?: tipoPessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipoPessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoPessoaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipoPessoa model
   */
  readonly fields: tipoPessoaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipoPessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipoPessoaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends tipoPessoa$pessoaArgs<ExtArgs> = {}>(args?: Subset<T, tipoPessoa$pessoaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipoPessoa model
   */
  interface tipoPessoaFieldRefs {
    readonly id: FieldRef<"tipoPessoa", 'Int'>
    readonly descricao: FieldRef<"tipoPessoa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tipoPessoa findUnique
   */
  export type tipoPessoaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
    /**
     * Filter, which tipoPessoa to fetch.
     */
    where: tipoPessoaWhereUniqueInput
  }

  /**
   * tipoPessoa findUniqueOrThrow
   */
  export type tipoPessoaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
    /**
     * Filter, which tipoPessoa to fetch.
     */
    where: tipoPessoaWhereUniqueInput
  }

  /**
   * tipoPessoa findFirst
   */
  export type tipoPessoaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
    /**
     * Filter, which tipoPessoa to fetch.
     */
    where?: tipoPessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoPessoas to fetch.
     */
    orderBy?: tipoPessoaOrderByWithRelationInput | tipoPessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoPessoas.
     */
    cursor?: tipoPessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoPessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoPessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoPessoas.
     */
    distinct?: TipoPessoaScalarFieldEnum | TipoPessoaScalarFieldEnum[]
  }

  /**
   * tipoPessoa findFirstOrThrow
   */
  export type tipoPessoaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
    /**
     * Filter, which tipoPessoa to fetch.
     */
    where?: tipoPessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoPessoas to fetch.
     */
    orderBy?: tipoPessoaOrderByWithRelationInput | tipoPessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoPessoas.
     */
    cursor?: tipoPessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoPessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoPessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoPessoas.
     */
    distinct?: TipoPessoaScalarFieldEnum | TipoPessoaScalarFieldEnum[]
  }

  /**
   * tipoPessoa findMany
   */
  export type tipoPessoaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
    /**
     * Filter, which tipoPessoas to fetch.
     */
    where?: tipoPessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoPessoas to fetch.
     */
    orderBy?: tipoPessoaOrderByWithRelationInput | tipoPessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipoPessoas.
     */
    cursor?: tipoPessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoPessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoPessoas.
     */
    skip?: number
    distinct?: TipoPessoaScalarFieldEnum | TipoPessoaScalarFieldEnum[]
  }

  /**
   * tipoPessoa create
   */
  export type tipoPessoaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
    /**
     * The data needed to create a tipoPessoa.
     */
    data: XOR<tipoPessoaCreateInput, tipoPessoaUncheckedCreateInput>
  }

  /**
   * tipoPessoa createMany
   */
  export type tipoPessoaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipoPessoas.
     */
    data: tipoPessoaCreateManyInput | tipoPessoaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoPessoa createManyAndReturn
   */
  export type tipoPessoaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * The data used to create many tipoPessoas.
     */
    data: tipoPessoaCreateManyInput | tipoPessoaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoPessoa update
   */
  export type tipoPessoaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
    /**
     * The data needed to update a tipoPessoa.
     */
    data: XOR<tipoPessoaUpdateInput, tipoPessoaUncheckedUpdateInput>
    /**
     * Choose, which tipoPessoa to update.
     */
    where: tipoPessoaWhereUniqueInput
  }

  /**
   * tipoPessoa updateMany
   */
  export type tipoPessoaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipoPessoas.
     */
    data: XOR<tipoPessoaUpdateManyMutationInput, tipoPessoaUncheckedUpdateManyInput>
    /**
     * Filter which tipoPessoas to update
     */
    where?: tipoPessoaWhereInput
    /**
     * Limit how many tipoPessoas to update.
     */
    limit?: number
  }

  /**
   * tipoPessoa updateManyAndReturn
   */
  export type tipoPessoaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * The data used to update tipoPessoas.
     */
    data: XOR<tipoPessoaUpdateManyMutationInput, tipoPessoaUncheckedUpdateManyInput>
    /**
     * Filter which tipoPessoas to update
     */
    where?: tipoPessoaWhereInput
    /**
     * Limit how many tipoPessoas to update.
     */
    limit?: number
  }

  /**
   * tipoPessoa upsert
   */
  export type tipoPessoaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
    /**
     * The filter to search for the tipoPessoa to update in case it exists.
     */
    where: tipoPessoaWhereUniqueInput
    /**
     * In case the tipoPessoa found by the `where` argument doesn't exist, create a new tipoPessoa with this data.
     */
    create: XOR<tipoPessoaCreateInput, tipoPessoaUncheckedCreateInput>
    /**
     * In case the tipoPessoa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipoPessoaUpdateInput, tipoPessoaUncheckedUpdateInput>
  }

  /**
   * tipoPessoa delete
   */
  export type tipoPessoaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
    /**
     * Filter which tipoPessoa to delete.
     */
    where: tipoPessoaWhereUniqueInput
  }

  /**
   * tipoPessoa deleteMany
   */
  export type tipoPessoaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoPessoas to delete
     */
    where?: tipoPessoaWhereInput
    /**
     * Limit how many tipoPessoas to delete.
     */
    limit?: number
  }

  /**
   * tipoPessoa.pessoa
   */
  export type tipoPessoa$pessoaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoa
     */
    select?: pessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoa
     */
    omit?: pessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaInclude<ExtArgs> | null
    where?: pessoaWhereInput
    orderBy?: pessoaOrderByWithRelationInput | pessoaOrderByWithRelationInput[]
    cursor?: pessoaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PessoaScalarFieldEnum | PessoaScalarFieldEnum[]
  }

  /**
   * tipoPessoa without action
   */
  export type tipoPessoaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoPessoa
     */
    select?: tipoPessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoPessoa
     */
    omit?: tipoPessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoPessoaInclude<ExtArgs> | null
  }


  /**
   * Model pessoaEndereco
   */

  export type AggregatePessoaEndereco = {
    _count: PessoaEnderecoCountAggregateOutputType | null
    _avg: PessoaEnderecoAvgAggregateOutputType | null
    _sum: PessoaEnderecoSumAggregateOutputType | null
    _min: PessoaEnderecoMinAggregateOutputType | null
    _max: PessoaEnderecoMaxAggregateOutputType | null
  }

  export type PessoaEnderecoAvgAggregateOutputType = {
    pessoaId: number | null
    enderecoId: number | null
  }

  export type PessoaEnderecoSumAggregateOutputType = {
    pessoaId: number | null
    enderecoId: number | null
  }

  export type PessoaEnderecoMinAggregateOutputType = {
    pessoaId: number | null
    enderecoId: number | null
  }

  export type PessoaEnderecoMaxAggregateOutputType = {
    pessoaId: number | null
    enderecoId: number | null
  }

  export type PessoaEnderecoCountAggregateOutputType = {
    pessoaId: number
    enderecoId: number
    _all: number
  }


  export type PessoaEnderecoAvgAggregateInputType = {
    pessoaId?: true
    enderecoId?: true
  }

  export type PessoaEnderecoSumAggregateInputType = {
    pessoaId?: true
    enderecoId?: true
  }

  export type PessoaEnderecoMinAggregateInputType = {
    pessoaId?: true
    enderecoId?: true
  }

  export type PessoaEnderecoMaxAggregateInputType = {
    pessoaId?: true
    enderecoId?: true
  }

  export type PessoaEnderecoCountAggregateInputType = {
    pessoaId?: true
    enderecoId?: true
    _all?: true
  }

  export type PessoaEnderecoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoaEndereco to aggregate.
     */
    where?: pessoaEnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaEnderecos to fetch.
     */
    orderBy?: pessoaEnderecoOrderByWithRelationInput | pessoaEnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pessoaEnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaEnderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaEnderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pessoaEnderecos
    **/
    _count?: true | PessoaEnderecoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaEnderecoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaEnderecoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaEnderecoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaEnderecoMaxAggregateInputType
  }

  export type GetPessoaEnderecoAggregateType<T extends PessoaEnderecoAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoaEndereco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoaEndereco[P]>
      : GetScalarType<T[P], AggregatePessoaEndereco[P]>
  }




  export type pessoaEnderecoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaEnderecoWhereInput
    orderBy?: pessoaEnderecoOrderByWithAggregationInput | pessoaEnderecoOrderByWithAggregationInput[]
    by: PessoaEnderecoScalarFieldEnum[] | PessoaEnderecoScalarFieldEnum
    having?: pessoaEnderecoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaEnderecoCountAggregateInputType | true
    _avg?: PessoaEnderecoAvgAggregateInputType
    _sum?: PessoaEnderecoSumAggregateInputType
    _min?: PessoaEnderecoMinAggregateInputType
    _max?: PessoaEnderecoMaxAggregateInputType
  }

  export type PessoaEnderecoGroupByOutputType = {
    pessoaId: number
    enderecoId: number
    _count: PessoaEnderecoCountAggregateOutputType | null
    _avg: PessoaEnderecoAvgAggregateOutputType | null
    _sum: PessoaEnderecoSumAggregateOutputType | null
    _min: PessoaEnderecoMinAggregateOutputType | null
    _max: PessoaEnderecoMaxAggregateOutputType | null
  }

  type GetPessoaEnderecoGroupByPayload<T extends pessoaEnderecoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaEnderecoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaEnderecoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaEnderecoGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaEnderecoGroupByOutputType[P]>
        }
      >
    >


  export type pessoaEnderecoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pessoaId?: boolean
    enderecoId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaEndereco"]>

  export type pessoaEnderecoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pessoaId?: boolean
    enderecoId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaEndereco"]>

  export type pessoaEnderecoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pessoaId?: boolean
    enderecoId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaEndereco"]>

  export type pessoaEnderecoSelectScalar = {
    pessoaId?: boolean
    enderecoId?: boolean
  }

  export type pessoaEnderecoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pessoaId" | "enderecoId", ExtArgs["result"]["pessoaEndereco"]>
  export type pessoaEnderecoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }
  export type pessoaEnderecoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }
  export type pessoaEnderecoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }

  export type $pessoaEnderecoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pessoaEndereco"
    objects: {
      pessoa: Prisma.$pessoaPayload<ExtArgs>
      endereco: Prisma.$enderecoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pessoaId: number
      enderecoId: number
    }, ExtArgs["result"]["pessoaEndereco"]>
    composites: {}
  }

  type pessoaEnderecoGetPayload<S extends boolean | null | undefined | pessoaEnderecoDefaultArgs> = $Result.GetResult<Prisma.$pessoaEnderecoPayload, S>

  type pessoaEnderecoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pessoaEnderecoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PessoaEnderecoCountAggregateInputType | true
    }

  export interface pessoaEnderecoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pessoaEndereco'], meta: { name: 'pessoaEndereco' } }
    /**
     * Find zero or one PessoaEndereco that matches the filter.
     * @param {pessoaEnderecoFindUniqueArgs} args - Arguments to find a PessoaEndereco
     * @example
     * // Get one PessoaEndereco
     * const pessoaEndereco = await prisma.pessoaEndereco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pessoaEnderecoFindUniqueArgs>(args: SelectSubset<T, pessoaEnderecoFindUniqueArgs<ExtArgs>>): Prisma__pessoaEnderecoClient<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PessoaEndereco that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pessoaEnderecoFindUniqueOrThrowArgs} args - Arguments to find a PessoaEndereco
     * @example
     * // Get one PessoaEndereco
     * const pessoaEndereco = await prisma.pessoaEndereco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pessoaEnderecoFindUniqueOrThrowArgs>(args: SelectSubset<T, pessoaEnderecoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pessoaEnderecoClient<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaEndereco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaEnderecoFindFirstArgs} args - Arguments to find a PessoaEndereco
     * @example
     * // Get one PessoaEndereco
     * const pessoaEndereco = await prisma.pessoaEndereco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pessoaEnderecoFindFirstArgs>(args?: SelectSubset<T, pessoaEnderecoFindFirstArgs<ExtArgs>>): Prisma__pessoaEnderecoClient<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaEndereco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaEnderecoFindFirstOrThrowArgs} args - Arguments to find a PessoaEndereco
     * @example
     * // Get one PessoaEndereco
     * const pessoaEndereco = await prisma.pessoaEndereco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pessoaEnderecoFindFirstOrThrowArgs>(args?: SelectSubset<T, pessoaEnderecoFindFirstOrThrowArgs<ExtArgs>>): Prisma__pessoaEnderecoClient<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PessoaEnderecos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaEnderecoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PessoaEnderecos
     * const pessoaEnderecos = await prisma.pessoaEndereco.findMany()
     * 
     * // Get first 10 PessoaEnderecos
     * const pessoaEnderecos = await prisma.pessoaEndereco.findMany({ take: 10 })
     * 
     * // Only select the `pessoaId`
     * const pessoaEnderecoWithPessoaIdOnly = await prisma.pessoaEndereco.findMany({ select: { pessoaId: true } })
     * 
     */
    findMany<T extends pessoaEnderecoFindManyArgs>(args?: SelectSubset<T, pessoaEnderecoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PessoaEndereco.
     * @param {pessoaEnderecoCreateArgs} args - Arguments to create a PessoaEndereco.
     * @example
     * // Create one PessoaEndereco
     * const PessoaEndereco = await prisma.pessoaEndereco.create({
     *   data: {
     *     // ... data to create a PessoaEndereco
     *   }
     * })
     * 
     */
    create<T extends pessoaEnderecoCreateArgs>(args: SelectSubset<T, pessoaEnderecoCreateArgs<ExtArgs>>): Prisma__pessoaEnderecoClient<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PessoaEnderecos.
     * @param {pessoaEnderecoCreateManyArgs} args - Arguments to create many PessoaEnderecos.
     * @example
     * // Create many PessoaEnderecos
     * const pessoaEndereco = await prisma.pessoaEndereco.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pessoaEnderecoCreateManyArgs>(args?: SelectSubset<T, pessoaEnderecoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PessoaEnderecos and returns the data saved in the database.
     * @param {pessoaEnderecoCreateManyAndReturnArgs} args - Arguments to create many PessoaEnderecos.
     * @example
     * // Create many PessoaEnderecos
     * const pessoaEndereco = await prisma.pessoaEndereco.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PessoaEnderecos and only return the `pessoaId`
     * const pessoaEnderecoWithPessoaIdOnly = await prisma.pessoaEndereco.createManyAndReturn({
     *   select: { pessoaId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pessoaEnderecoCreateManyAndReturnArgs>(args?: SelectSubset<T, pessoaEnderecoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PessoaEndereco.
     * @param {pessoaEnderecoDeleteArgs} args - Arguments to delete one PessoaEndereco.
     * @example
     * // Delete one PessoaEndereco
     * const PessoaEndereco = await prisma.pessoaEndereco.delete({
     *   where: {
     *     // ... filter to delete one PessoaEndereco
     *   }
     * })
     * 
     */
    delete<T extends pessoaEnderecoDeleteArgs>(args: SelectSubset<T, pessoaEnderecoDeleteArgs<ExtArgs>>): Prisma__pessoaEnderecoClient<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PessoaEndereco.
     * @param {pessoaEnderecoUpdateArgs} args - Arguments to update one PessoaEndereco.
     * @example
     * // Update one PessoaEndereco
     * const pessoaEndereco = await prisma.pessoaEndereco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pessoaEnderecoUpdateArgs>(args: SelectSubset<T, pessoaEnderecoUpdateArgs<ExtArgs>>): Prisma__pessoaEnderecoClient<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PessoaEnderecos.
     * @param {pessoaEnderecoDeleteManyArgs} args - Arguments to filter PessoaEnderecos to delete.
     * @example
     * // Delete a few PessoaEnderecos
     * const { count } = await prisma.pessoaEndereco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pessoaEnderecoDeleteManyArgs>(args?: SelectSubset<T, pessoaEnderecoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaEnderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaEnderecoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PessoaEnderecos
     * const pessoaEndereco = await prisma.pessoaEndereco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pessoaEnderecoUpdateManyArgs>(args: SelectSubset<T, pessoaEnderecoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaEnderecos and returns the data updated in the database.
     * @param {pessoaEnderecoUpdateManyAndReturnArgs} args - Arguments to update many PessoaEnderecos.
     * @example
     * // Update many PessoaEnderecos
     * const pessoaEndereco = await prisma.pessoaEndereco.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PessoaEnderecos and only return the `pessoaId`
     * const pessoaEnderecoWithPessoaIdOnly = await prisma.pessoaEndereco.updateManyAndReturn({
     *   select: { pessoaId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pessoaEnderecoUpdateManyAndReturnArgs>(args: SelectSubset<T, pessoaEnderecoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PessoaEndereco.
     * @param {pessoaEnderecoUpsertArgs} args - Arguments to update or create a PessoaEndereco.
     * @example
     * // Update or create a PessoaEndereco
     * const pessoaEndereco = await prisma.pessoaEndereco.upsert({
     *   create: {
     *     // ... data to create a PessoaEndereco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PessoaEndereco we want to update
     *   }
     * })
     */
    upsert<T extends pessoaEnderecoUpsertArgs>(args: SelectSubset<T, pessoaEnderecoUpsertArgs<ExtArgs>>): Prisma__pessoaEnderecoClient<$Result.GetResult<Prisma.$pessoaEnderecoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PessoaEnderecos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaEnderecoCountArgs} args - Arguments to filter PessoaEnderecos to count.
     * @example
     * // Count the number of PessoaEnderecos
     * const count = await prisma.pessoaEndereco.count({
     *   where: {
     *     // ... the filter for the PessoaEnderecos we want to count
     *   }
     * })
    **/
    count<T extends pessoaEnderecoCountArgs>(
      args?: Subset<T, pessoaEnderecoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaEnderecoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PessoaEndereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaEnderecoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaEnderecoAggregateArgs>(args: Subset<T, PessoaEnderecoAggregateArgs>): Prisma.PrismaPromise<GetPessoaEnderecoAggregateType<T>>

    /**
     * Group by PessoaEndereco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaEnderecoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pessoaEnderecoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pessoaEnderecoGroupByArgs['orderBy'] }
        : { orderBy?: pessoaEnderecoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pessoaEnderecoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaEnderecoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pessoaEndereco model
   */
  readonly fields: pessoaEnderecoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pessoaEndereco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pessoaEnderecoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    endereco<T extends enderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, enderecoDefaultArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pessoaEndereco model
   */
  interface pessoaEnderecoFieldRefs {
    readonly pessoaId: FieldRef<"pessoaEndereco", 'Int'>
    readonly enderecoId: FieldRef<"pessoaEndereco", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pessoaEndereco findUnique
   */
  export type pessoaEnderecoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaEndereco to fetch.
     */
    where: pessoaEnderecoWhereUniqueInput
  }

  /**
   * pessoaEndereco findUniqueOrThrow
   */
  export type pessoaEnderecoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaEndereco to fetch.
     */
    where: pessoaEnderecoWhereUniqueInput
  }

  /**
   * pessoaEndereco findFirst
   */
  export type pessoaEnderecoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaEndereco to fetch.
     */
    where?: pessoaEnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaEnderecos to fetch.
     */
    orderBy?: pessoaEnderecoOrderByWithRelationInput | pessoaEnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoaEnderecos.
     */
    cursor?: pessoaEnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaEnderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaEnderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoaEnderecos.
     */
    distinct?: PessoaEnderecoScalarFieldEnum | PessoaEnderecoScalarFieldEnum[]
  }

  /**
   * pessoaEndereco findFirstOrThrow
   */
  export type pessoaEnderecoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaEndereco to fetch.
     */
    where?: pessoaEnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaEnderecos to fetch.
     */
    orderBy?: pessoaEnderecoOrderByWithRelationInput | pessoaEnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoaEnderecos.
     */
    cursor?: pessoaEnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaEnderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaEnderecos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoaEnderecos.
     */
    distinct?: PessoaEnderecoScalarFieldEnum | PessoaEnderecoScalarFieldEnum[]
  }

  /**
   * pessoaEndereco findMany
   */
  export type pessoaEnderecoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaEnderecos to fetch.
     */
    where?: pessoaEnderecoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaEnderecos to fetch.
     */
    orderBy?: pessoaEnderecoOrderByWithRelationInput | pessoaEnderecoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pessoaEnderecos.
     */
    cursor?: pessoaEnderecoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaEnderecos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaEnderecos.
     */
    skip?: number
    distinct?: PessoaEnderecoScalarFieldEnum | PessoaEnderecoScalarFieldEnum[]
  }

  /**
   * pessoaEndereco create
   */
  export type pessoaEnderecoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    /**
     * The data needed to create a pessoaEndereco.
     */
    data: XOR<pessoaEnderecoCreateInput, pessoaEnderecoUncheckedCreateInput>
  }

  /**
   * pessoaEndereco createMany
   */
  export type pessoaEnderecoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pessoaEnderecos.
     */
    data: pessoaEnderecoCreateManyInput | pessoaEnderecoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pessoaEndereco createManyAndReturn
   */
  export type pessoaEnderecoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * The data used to create many pessoaEnderecos.
     */
    data: pessoaEnderecoCreateManyInput | pessoaEnderecoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoaEndereco update
   */
  export type pessoaEnderecoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    /**
     * The data needed to update a pessoaEndereco.
     */
    data: XOR<pessoaEnderecoUpdateInput, pessoaEnderecoUncheckedUpdateInput>
    /**
     * Choose, which pessoaEndereco to update.
     */
    where: pessoaEnderecoWhereUniqueInput
  }

  /**
   * pessoaEndereco updateMany
   */
  export type pessoaEnderecoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pessoaEnderecos.
     */
    data: XOR<pessoaEnderecoUpdateManyMutationInput, pessoaEnderecoUncheckedUpdateManyInput>
    /**
     * Filter which pessoaEnderecos to update
     */
    where?: pessoaEnderecoWhereInput
    /**
     * Limit how many pessoaEnderecos to update.
     */
    limit?: number
  }

  /**
   * pessoaEndereco updateManyAndReturn
   */
  export type pessoaEnderecoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * The data used to update pessoaEnderecos.
     */
    data: XOR<pessoaEnderecoUpdateManyMutationInput, pessoaEnderecoUncheckedUpdateManyInput>
    /**
     * Filter which pessoaEnderecos to update
     */
    where?: pessoaEnderecoWhereInput
    /**
     * Limit how many pessoaEnderecos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoaEndereco upsert
   */
  export type pessoaEnderecoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    /**
     * The filter to search for the pessoaEndereco to update in case it exists.
     */
    where: pessoaEnderecoWhereUniqueInput
    /**
     * In case the pessoaEndereco found by the `where` argument doesn't exist, create a new pessoaEndereco with this data.
     */
    create: XOR<pessoaEnderecoCreateInput, pessoaEnderecoUncheckedCreateInput>
    /**
     * In case the pessoaEndereco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pessoaEnderecoUpdateInput, pessoaEnderecoUncheckedUpdateInput>
  }

  /**
   * pessoaEndereco delete
   */
  export type pessoaEnderecoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
    /**
     * Filter which pessoaEndereco to delete.
     */
    where: pessoaEnderecoWhereUniqueInput
  }

  /**
   * pessoaEndereco deleteMany
   */
  export type pessoaEnderecoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoaEnderecos to delete
     */
    where?: pessoaEnderecoWhereInput
    /**
     * Limit how many pessoaEnderecos to delete.
     */
    limit?: number
  }

  /**
   * pessoaEndereco without action
   */
  export type pessoaEnderecoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaEndereco
     */
    select?: pessoaEnderecoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaEndereco
     */
    omit?: pessoaEnderecoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaEnderecoInclude<ExtArgs> | null
  }


  /**
   * Model pessoaCasal
   */

  export type AggregatePessoaCasal = {
    _count: PessoaCasalCountAggregateOutputType | null
    _avg: PessoaCasalAvgAggregateOutputType | null
    _sum: PessoaCasalSumAggregateOutputType | null
    _min: PessoaCasalMinAggregateOutputType | null
    _max: PessoaCasalMaxAggregateOutputType | null
  }

  export type PessoaCasalAvgAggregateOutputType = {
    id: number | null
    pessoaMaridoId: number | null
    pessoaMulherId: number | null
  }

  export type PessoaCasalSumAggregateOutputType = {
    id: number | null
    pessoaMaridoId: number | null
    pessoaMulherId: number | null
  }

  export type PessoaCasalMinAggregateOutputType = {
    id: number | null
    pessoaMaridoId: number | null
    pessoaMulherId: number | null
  }

  export type PessoaCasalMaxAggregateOutputType = {
    id: number | null
    pessoaMaridoId: number | null
    pessoaMulherId: number | null
  }

  export type PessoaCasalCountAggregateOutputType = {
    id: number
    pessoaMaridoId: number
    pessoaMulherId: number
    _all: number
  }


  export type PessoaCasalAvgAggregateInputType = {
    id?: true
    pessoaMaridoId?: true
    pessoaMulherId?: true
  }

  export type PessoaCasalSumAggregateInputType = {
    id?: true
    pessoaMaridoId?: true
    pessoaMulherId?: true
  }

  export type PessoaCasalMinAggregateInputType = {
    id?: true
    pessoaMaridoId?: true
    pessoaMulherId?: true
  }

  export type PessoaCasalMaxAggregateInputType = {
    id?: true
    pessoaMaridoId?: true
    pessoaMulherId?: true
  }

  export type PessoaCasalCountAggregateInputType = {
    id?: true
    pessoaMaridoId?: true
    pessoaMulherId?: true
    _all?: true
  }

  export type PessoaCasalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoaCasal to aggregate.
     */
    where?: pessoaCasalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaCasals to fetch.
     */
    orderBy?: pessoaCasalOrderByWithRelationInput | pessoaCasalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pessoaCasalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaCasals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaCasals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pessoaCasals
    **/
    _count?: true | PessoaCasalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaCasalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaCasalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaCasalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaCasalMaxAggregateInputType
  }

  export type GetPessoaCasalAggregateType<T extends PessoaCasalAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoaCasal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoaCasal[P]>
      : GetScalarType<T[P], AggregatePessoaCasal[P]>
  }




  export type pessoaCasalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaCasalWhereInput
    orderBy?: pessoaCasalOrderByWithAggregationInput | pessoaCasalOrderByWithAggregationInput[]
    by: PessoaCasalScalarFieldEnum[] | PessoaCasalScalarFieldEnum
    having?: pessoaCasalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCasalCountAggregateInputType | true
    _avg?: PessoaCasalAvgAggregateInputType
    _sum?: PessoaCasalSumAggregateInputType
    _min?: PessoaCasalMinAggregateInputType
    _max?: PessoaCasalMaxAggregateInputType
  }

  export type PessoaCasalGroupByOutputType = {
    id: number
    pessoaMaridoId: number
    pessoaMulherId: number
    _count: PessoaCasalCountAggregateOutputType | null
    _avg: PessoaCasalAvgAggregateOutputType | null
    _sum: PessoaCasalSumAggregateOutputType | null
    _min: PessoaCasalMinAggregateOutputType | null
    _max: PessoaCasalMaxAggregateOutputType | null
  }

  type GetPessoaCasalGroupByPayload<T extends pessoaCasalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaCasalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaCasalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaCasalGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaCasalGroupByOutputType[P]>
        }
      >
    >


  export type pessoaCasalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pessoaMaridoId?: boolean
    pessoaMulherId?: boolean
    marido?: boolean | pessoaDefaultArgs<ExtArgs>
    mulher?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaCasal"]>

  export type pessoaCasalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pessoaMaridoId?: boolean
    pessoaMulherId?: boolean
    marido?: boolean | pessoaDefaultArgs<ExtArgs>
    mulher?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaCasal"]>

  export type pessoaCasalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pessoaMaridoId?: boolean
    pessoaMulherId?: boolean
    marido?: boolean | pessoaDefaultArgs<ExtArgs>
    mulher?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaCasal"]>

  export type pessoaCasalSelectScalar = {
    id?: boolean
    pessoaMaridoId?: boolean
    pessoaMulherId?: boolean
  }

  export type pessoaCasalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pessoaMaridoId" | "pessoaMulherId", ExtArgs["result"]["pessoaCasal"]>
  export type pessoaCasalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marido?: boolean | pessoaDefaultArgs<ExtArgs>
    mulher?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type pessoaCasalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marido?: boolean | pessoaDefaultArgs<ExtArgs>
    mulher?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type pessoaCasalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marido?: boolean | pessoaDefaultArgs<ExtArgs>
    mulher?: boolean | pessoaDefaultArgs<ExtArgs>
  }

  export type $pessoaCasalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pessoaCasal"
    objects: {
      marido: Prisma.$pessoaPayload<ExtArgs>
      mulher: Prisma.$pessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pessoaMaridoId: number
      pessoaMulherId: number
    }, ExtArgs["result"]["pessoaCasal"]>
    composites: {}
  }

  type pessoaCasalGetPayload<S extends boolean | null | undefined | pessoaCasalDefaultArgs> = $Result.GetResult<Prisma.$pessoaCasalPayload, S>

  type pessoaCasalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pessoaCasalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PessoaCasalCountAggregateInputType | true
    }

  export interface pessoaCasalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pessoaCasal'], meta: { name: 'pessoaCasal' } }
    /**
     * Find zero or one PessoaCasal that matches the filter.
     * @param {pessoaCasalFindUniqueArgs} args - Arguments to find a PessoaCasal
     * @example
     * // Get one PessoaCasal
     * const pessoaCasal = await prisma.pessoaCasal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pessoaCasalFindUniqueArgs>(args: SelectSubset<T, pessoaCasalFindUniqueArgs<ExtArgs>>): Prisma__pessoaCasalClient<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PessoaCasal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pessoaCasalFindUniqueOrThrowArgs} args - Arguments to find a PessoaCasal
     * @example
     * // Get one PessoaCasal
     * const pessoaCasal = await prisma.pessoaCasal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pessoaCasalFindUniqueOrThrowArgs>(args: SelectSubset<T, pessoaCasalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pessoaCasalClient<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaCasal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCasalFindFirstArgs} args - Arguments to find a PessoaCasal
     * @example
     * // Get one PessoaCasal
     * const pessoaCasal = await prisma.pessoaCasal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pessoaCasalFindFirstArgs>(args?: SelectSubset<T, pessoaCasalFindFirstArgs<ExtArgs>>): Prisma__pessoaCasalClient<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaCasal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCasalFindFirstOrThrowArgs} args - Arguments to find a PessoaCasal
     * @example
     * // Get one PessoaCasal
     * const pessoaCasal = await prisma.pessoaCasal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pessoaCasalFindFirstOrThrowArgs>(args?: SelectSubset<T, pessoaCasalFindFirstOrThrowArgs<ExtArgs>>): Prisma__pessoaCasalClient<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PessoaCasals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCasalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PessoaCasals
     * const pessoaCasals = await prisma.pessoaCasal.findMany()
     * 
     * // Get first 10 PessoaCasals
     * const pessoaCasals = await prisma.pessoaCasal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaCasalWithIdOnly = await prisma.pessoaCasal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pessoaCasalFindManyArgs>(args?: SelectSubset<T, pessoaCasalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PessoaCasal.
     * @param {pessoaCasalCreateArgs} args - Arguments to create a PessoaCasal.
     * @example
     * // Create one PessoaCasal
     * const PessoaCasal = await prisma.pessoaCasal.create({
     *   data: {
     *     // ... data to create a PessoaCasal
     *   }
     * })
     * 
     */
    create<T extends pessoaCasalCreateArgs>(args: SelectSubset<T, pessoaCasalCreateArgs<ExtArgs>>): Prisma__pessoaCasalClient<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PessoaCasals.
     * @param {pessoaCasalCreateManyArgs} args - Arguments to create many PessoaCasals.
     * @example
     * // Create many PessoaCasals
     * const pessoaCasal = await prisma.pessoaCasal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pessoaCasalCreateManyArgs>(args?: SelectSubset<T, pessoaCasalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PessoaCasals and returns the data saved in the database.
     * @param {pessoaCasalCreateManyAndReturnArgs} args - Arguments to create many PessoaCasals.
     * @example
     * // Create many PessoaCasals
     * const pessoaCasal = await prisma.pessoaCasal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PessoaCasals and only return the `id`
     * const pessoaCasalWithIdOnly = await prisma.pessoaCasal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pessoaCasalCreateManyAndReturnArgs>(args?: SelectSubset<T, pessoaCasalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PessoaCasal.
     * @param {pessoaCasalDeleteArgs} args - Arguments to delete one PessoaCasal.
     * @example
     * // Delete one PessoaCasal
     * const PessoaCasal = await prisma.pessoaCasal.delete({
     *   where: {
     *     // ... filter to delete one PessoaCasal
     *   }
     * })
     * 
     */
    delete<T extends pessoaCasalDeleteArgs>(args: SelectSubset<T, pessoaCasalDeleteArgs<ExtArgs>>): Prisma__pessoaCasalClient<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PessoaCasal.
     * @param {pessoaCasalUpdateArgs} args - Arguments to update one PessoaCasal.
     * @example
     * // Update one PessoaCasal
     * const pessoaCasal = await prisma.pessoaCasal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pessoaCasalUpdateArgs>(args: SelectSubset<T, pessoaCasalUpdateArgs<ExtArgs>>): Prisma__pessoaCasalClient<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PessoaCasals.
     * @param {pessoaCasalDeleteManyArgs} args - Arguments to filter PessoaCasals to delete.
     * @example
     * // Delete a few PessoaCasals
     * const { count } = await prisma.pessoaCasal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pessoaCasalDeleteManyArgs>(args?: SelectSubset<T, pessoaCasalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaCasals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCasalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PessoaCasals
     * const pessoaCasal = await prisma.pessoaCasal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pessoaCasalUpdateManyArgs>(args: SelectSubset<T, pessoaCasalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaCasals and returns the data updated in the database.
     * @param {pessoaCasalUpdateManyAndReturnArgs} args - Arguments to update many PessoaCasals.
     * @example
     * // Update many PessoaCasals
     * const pessoaCasal = await prisma.pessoaCasal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PessoaCasals and only return the `id`
     * const pessoaCasalWithIdOnly = await prisma.pessoaCasal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pessoaCasalUpdateManyAndReturnArgs>(args: SelectSubset<T, pessoaCasalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PessoaCasal.
     * @param {pessoaCasalUpsertArgs} args - Arguments to update or create a PessoaCasal.
     * @example
     * // Update or create a PessoaCasal
     * const pessoaCasal = await prisma.pessoaCasal.upsert({
     *   create: {
     *     // ... data to create a PessoaCasal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PessoaCasal we want to update
     *   }
     * })
     */
    upsert<T extends pessoaCasalUpsertArgs>(args: SelectSubset<T, pessoaCasalUpsertArgs<ExtArgs>>): Prisma__pessoaCasalClient<$Result.GetResult<Prisma.$pessoaCasalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PessoaCasals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCasalCountArgs} args - Arguments to filter PessoaCasals to count.
     * @example
     * // Count the number of PessoaCasals
     * const count = await prisma.pessoaCasal.count({
     *   where: {
     *     // ... the filter for the PessoaCasals we want to count
     *   }
     * })
    **/
    count<T extends pessoaCasalCountArgs>(
      args?: Subset<T, pessoaCasalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCasalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PessoaCasal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaCasalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaCasalAggregateArgs>(args: Subset<T, PessoaCasalAggregateArgs>): Prisma.PrismaPromise<GetPessoaCasalAggregateType<T>>

    /**
     * Group by PessoaCasal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCasalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pessoaCasalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pessoaCasalGroupByArgs['orderBy'] }
        : { orderBy?: pessoaCasalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pessoaCasalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaCasalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pessoaCasal model
   */
  readonly fields: pessoaCasalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pessoaCasal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pessoaCasalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marido<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    mulher<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pessoaCasal model
   */
  interface pessoaCasalFieldRefs {
    readonly id: FieldRef<"pessoaCasal", 'Int'>
    readonly pessoaMaridoId: FieldRef<"pessoaCasal", 'Int'>
    readonly pessoaMulherId: FieldRef<"pessoaCasal", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pessoaCasal findUnique
   */
  export type pessoaCasalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCasal to fetch.
     */
    where: pessoaCasalWhereUniqueInput
  }

  /**
   * pessoaCasal findUniqueOrThrow
   */
  export type pessoaCasalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCasal to fetch.
     */
    where: pessoaCasalWhereUniqueInput
  }

  /**
   * pessoaCasal findFirst
   */
  export type pessoaCasalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCasal to fetch.
     */
    where?: pessoaCasalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaCasals to fetch.
     */
    orderBy?: pessoaCasalOrderByWithRelationInput | pessoaCasalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoaCasals.
     */
    cursor?: pessoaCasalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaCasals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaCasals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoaCasals.
     */
    distinct?: PessoaCasalScalarFieldEnum | PessoaCasalScalarFieldEnum[]
  }

  /**
   * pessoaCasal findFirstOrThrow
   */
  export type pessoaCasalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCasal to fetch.
     */
    where?: pessoaCasalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaCasals to fetch.
     */
    orderBy?: pessoaCasalOrderByWithRelationInput | pessoaCasalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoaCasals.
     */
    cursor?: pessoaCasalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaCasals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaCasals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoaCasals.
     */
    distinct?: PessoaCasalScalarFieldEnum | PessoaCasalScalarFieldEnum[]
  }

  /**
   * pessoaCasal findMany
   */
  export type pessoaCasalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCasals to fetch.
     */
    where?: pessoaCasalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaCasals to fetch.
     */
    orderBy?: pessoaCasalOrderByWithRelationInput | pessoaCasalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pessoaCasals.
     */
    cursor?: pessoaCasalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaCasals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaCasals.
     */
    skip?: number
    distinct?: PessoaCasalScalarFieldEnum | PessoaCasalScalarFieldEnum[]
  }

  /**
   * pessoaCasal create
   */
  export type pessoaCasalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    /**
     * The data needed to create a pessoaCasal.
     */
    data: XOR<pessoaCasalCreateInput, pessoaCasalUncheckedCreateInput>
  }

  /**
   * pessoaCasal createMany
   */
  export type pessoaCasalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pessoaCasals.
     */
    data: pessoaCasalCreateManyInput | pessoaCasalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pessoaCasal createManyAndReturn
   */
  export type pessoaCasalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * The data used to create many pessoaCasals.
     */
    data: pessoaCasalCreateManyInput | pessoaCasalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoaCasal update
   */
  export type pessoaCasalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    /**
     * The data needed to update a pessoaCasal.
     */
    data: XOR<pessoaCasalUpdateInput, pessoaCasalUncheckedUpdateInput>
    /**
     * Choose, which pessoaCasal to update.
     */
    where: pessoaCasalWhereUniqueInput
  }

  /**
   * pessoaCasal updateMany
   */
  export type pessoaCasalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pessoaCasals.
     */
    data: XOR<pessoaCasalUpdateManyMutationInput, pessoaCasalUncheckedUpdateManyInput>
    /**
     * Filter which pessoaCasals to update
     */
    where?: pessoaCasalWhereInput
    /**
     * Limit how many pessoaCasals to update.
     */
    limit?: number
  }

  /**
   * pessoaCasal updateManyAndReturn
   */
  export type pessoaCasalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * The data used to update pessoaCasals.
     */
    data: XOR<pessoaCasalUpdateManyMutationInput, pessoaCasalUncheckedUpdateManyInput>
    /**
     * Filter which pessoaCasals to update
     */
    where?: pessoaCasalWhereInput
    /**
     * Limit how many pessoaCasals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoaCasal upsert
   */
  export type pessoaCasalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    /**
     * The filter to search for the pessoaCasal to update in case it exists.
     */
    where: pessoaCasalWhereUniqueInput
    /**
     * In case the pessoaCasal found by the `where` argument doesn't exist, create a new pessoaCasal with this data.
     */
    create: XOR<pessoaCasalCreateInput, pessoaCasalUncheckedCreateInput>
    /**
     * In case the pessoaCasal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pessoaCasalUpdateInput, pessoaCasalUncheckedUpdateInput>
  }

  /**
   * pessoaCasal delete
   */
  export type pessoaCasalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
    /**
     * Filter which pessoaCasal to delete.
     */
    where: pessoaCasalWhereUniqueInput
  }

  /**
   * pessoaCasal deleteMany
   */
  export type pessoaCasalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoaCasals to delete
     */
    where?: pessoaCasalWhereInput
    /**
     * Limit how many pessoaCasals to delete.
     */
    limit?: number
  }

  /**
   * pessoaCasal without action
   */
  export type pessoaCasalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCasal
     */
    select?: pessoaCasalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCasal
     */
    omit?: pessoaCasalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCasalInclude<ExtArgs> | null
  }


  /**
   * Model pessoaCarisma
   */

  export type AggregatePessoaCarisma = {
    _count: PessoaCarismaCountAggregateOutputType | null
    _avg: PessoaCarismaAvgAggregateOutputType | null
    _sum: PessoaCarismaSumAggregateOutputType | null
    _min: PessoaCarismaMinAggregateOutputType | null
    _max: PessoaCarismaMaxAggregateOutputType | null
  }

  export type PessoaCarismaAvgAggregateOutputType = {
    pessoaId: number | null
    tipoCarismaId: number | null
  }

  export type PessoaCarismaSumAggregateOutputType = {
    pessoaId: number | null
    tipoCarismaId: number | null
  }

  export type PessoaCarismaMinAggregateOutputType = {
    pessoaId: number | null
    tipoCarismaId: number | null
  }

  export type PessoaCarismaMaxAggregateOutputType = {
    pessoaId: number | null
    tipoCarismaId: number | null
  }

  export type PessoaCarismaCountAggregateOutputType = {
    pessoaId: number
    tipoCarismaId: number
    _all: number
  }


  export type PessoaCarismaAvgAggregateInputType = {
    pessoaId?: true
    tipoCarismaId?: true
  }

  export type PessoaCarismaSumAggregateInputType = {
    pessoaId?: true
    tipoCarismaId?: true
  }

  export type PessoaCarismaMinAggregateInputType = {
    pessoaId?: true
    tipoCarismaId?: true
  }

  export type PessoaCarismaMaxAggregateInputType = {
    pessoaId?: true
    tipoCarismaId?: true
  }

  export type PessoaCarismaCountAggregateInputType = {
    pessoaId?: true
    tipoCarismaId?: true
    _all?: true
  }

  export type PessoaCarismaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoaCarisma to aggregate.
     */
    where?: pessoaCarismaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaCarismas to fetch.
     */
    orderBy?: pessoaCarismaOrderByWithRelationInput | pessoaCarismaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pessoaCarismaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaCarismas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaCarismas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pessoaCarismas
    **/
    _count?: true | PessoaCarismaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaCarismaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaCarismaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaCarismaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaCarismaMaxAggregateInputType
  }

  export type GetPessoaCarismaAggregateType<T extends PessoaCarismaAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoaCarisma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoaCarisma[P]>
      : GetScalarType<T[P], AggregatePessoaCarisma[P]>
  }




  export type pessoaCarismaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaCarismaWhereInput
    orderBy?: pessoaCarismaOrderByWithAggregationInput | pessoaCarismaOrderByWithAggregationInput[]
    by: PessoaCarismaScalarFieldEnum[] | PessoaCarismaScalarFieldEnum
    having?: pessoaCarismaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaCarismaCountAggregateInputType | true
    _avg?: PessoaCarismaAvgAggregateInputType
    _sum?: PessoaCarismaSumAggregateInputType
    _min?: PessoaCarismaMinAggregateInputType
    _max?: PessoaCarismaMaxAggregateInputType
  }

  export type PessoaCarismaGroupByOutputType = {
    pessoaId: number
    tipoCarismaId: number
    _count: PessoaCarismaCountAggregateOutputType | null
    _avg: PessoaCarismaAvgAggregateOutputType | null
    _sum: PessoaCarismaSumAggregateOutputType | null
    _min: PessoaCarismaMinAggregateOutputType | null
    _max: PessoaCarismaMaxAggregateOutputType | null
  }

  type GetPessoaCarismaGroupByPayload<T extends pessoaCarismaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaCarismaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaCarismaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaCarismaGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaCarismaGroupByOutputType[P]>
        }
      >
    >


  export type pessoaCarismaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pessoaId?: boolean
    tipoCarismaId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    tipoCarisma?: boolean | tipoCarismaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaCarisma"]>

  export type pessoaCarismaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pessoaId?: boolean
    tipoCarismaId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    tipoCarisma?: boolean | tipoCarismaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaCarisma"]>

  export type pessoaCarismaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pessoaId?: boolean
    tipoCarismaId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    tipoCarisma?: boolean | tipoCarismaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaCarisma"]>

  export type pessoaCarismaSelectScalar = {
    pessoaId?: boolean
    tipoCarismaId?: boolean
  }

  export type pessoaCarismaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pessoaId" | "tipoCarismaId", ExtArgs["result"]["pessoaCarisma"]>
  export type pessoaCarismaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    tipoCarisma?: boolean | tipoCarismaDefaultArgs<ExtArgs>
  }
  export type pessoaCarismaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    tipoCarisma?: boolean | tipoCarismaDefaultArgs<ExtArgs>
  }
  export type pessoaCarismaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    tipoCarisma?: boolean | tipoCarismaDefaultArgs<ExtArgs>
  }

  export type $pessoaCarismaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pessoaCarisma"
    objects: {
      pessoa: Prisma.$pessoaPayload<ExtArgs>
      tipoCarisma: Prisma.$tipoCarismaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pessoaId: number
      tipoCarismaId: number
    }, ExtArgs["result"]["pessoaCarisma"]>
    composites: {}
  }

  type pessoaCarismaGetPayload<S extends boolean | null | undefined | pessoaCarismaDefaultArgs> = $Result.GetResult<Prisma.$pessoaCarismaPayload, S>

  type pessoaCarismaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pessoaCarismaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PessoaCarismaCountAggregateInputType | true
    }

  export interface pessoaCarismaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pessoaCarisma'], meta: { name: 'pessoaCarisma' } }
    /**
     * Find zero or one PessoaCarisma that matches the filter.
     * @param {pessoaCarismaFindUniqueArgs} args - Arguments to find a PessoaCarisma
     * @example
     * // Get one PessoaCarisma
     * const pessoaCarisma = await prisma.pessoaCarisma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pessoaCarismaFindUniqueArgs>(args: SelectSubset<T, pessoaCarismaFindUniqueArgs<ExtArgs>>): Prisma__pessoaCarismaClient<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PessoaCarisma that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pessoaCarismaFindUniqueOrThrowArgs} args - Arguments to find a PessoaCarisma
     * @example
     * // Get one PessoaCarisma
     * const pessoaCarisma = await prisma.pessoaCarisma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pessoaCarismaFindUniqueOrThrowArgs>(args: SelectSubset<T, pessoaCarismaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pessoaCarismaClient<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaCarisma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCarismaFindFirstArgs} args - Arguments to find a PessoaCarisma
     * @example
     * // Get one PessoaCarisma
     * const pessoaCarisma = await prisma.pessoaCarisma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pessoaCarismaFindFirstArgs>(args?: SelectSubset<T, pessoaCarismaFindFirstArgs<ExtArgs>>): Prisma__pessoaCarismaClient<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaCarisma that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCarismaFindFirstOrThrowArgs} args - Arguments to find a PessoaCarisma
     * @example
     * // Get one PessoaCarisma
     * const pessoaCarisma = await prisma.pessoaCarisma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pessoaCarismaFindFirstOrThrowArgs>(args?: SelectSubset<T, pessoaCarismaFindFirstOrThrowArgs<ExtArgs>>): Prisma__pessoaCarismaClient<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PessoaCarismas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCarismaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PessoaCarismas
     * const pessoaCarismas = await prisma.pessoaCarisma.findMany()
     * 
     * // Get first 10 PessoaCarismas
     * const pessoaCarismas = await prisma.pessoaCarisma.findMany({ take: 10 })
     * 
     * // Only select the `pessoaId`
     * const pessoaCarismaWithPessoaIdOnly = await prisma.pessoaCarisma.findMany({ select: { pessoaId: true } })
     * 
     */
    findMany<T extends pessoaCarismaFindManyArgs>(args?: SelectSubset<T, pessoaCarismaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PessoaCarisma.
     * @param {pessoaCarismaCreateArgs} args - Arguments to create a PessoaCarisma.
     * @example
     * // Create one PessoaCarisma
     * const PessoaCarisma = await prisma.pessoaCarisma.create({
     *   data: {
     *     // ... data to create a PessoaCarisma
     *   }
     * })
     * 
     */
    create<T extends pessoaCarismaCreateArgs>(args: SelectSubset<T, pessoaCarismaCreateArgs<ExtArgs>>): Prisma__pessoaCarismaClient<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PessoaCarismas.
     * @param {pessoaCarismaCreateManyArgs} args - Arguments to create many PessoaCarismas.
     * @example
     * // Create many PessoaCarismas
     * const pessoaCarisma = await prisma.pessoaCarisma.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pessoaCarismaCreateManyArgs>(args?: SelectSubset<T, pessoaCarismaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PessoaCarismas and returns the data saved in the database.
     * @param {pessoaCarismaCreateManyAndReturnArgs} args - Arguments to create many PessoaCarismas.
     * @example
     * // Create many PessoaCarismas
     * const pessoaCarisma = await prisma.pessoaCarisma.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PessoaCarismas and only return the `pessoaId`
     * const pessoaCarismaWithPessoaIdOnly = await prisma.pessoaCarisma.createManyAndReturn({
     *   select: { pessoaId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pessoaCarismaCreateManyAndReturnArgs>(args?: SelectSubset<T, pessoaCarismaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PessoaCarisma.
     * @param {pessoaCarismaDeleteArgs} args - Arguments to delete one PessoaCarisma.
     * @example
     * // Delete one PessoaCarisma
     * const PessoaCarisma = await prisma.pessoaCarisma.delete({
     *   where: {
     *     // ... filter to delete one PessoaCarisma
     *   }
     * })
     * 
     */
    delete<T extends pessoaCarismaDeleteArgs>(args: SelectSubset<T, pessoaCarismaDeleteArgs<ExtArgs>>): Prisma__pessoaCarismaClient<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PessoaCarisma.
     * @param {pessoaCarismaUpdateArgs} args - Arguments to update one PessoaCarisma.
     * @example
     * // Update one PessoaCarisma
     * const pessoaCarisma = await prisma.pessoaCarisma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pessoaCarismaUpdateArgs>(args: SelectSubset<T, pessoaCarismaUpdateArgs<ExtArgs>>): Prisma__pessoaCarismaClient<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PessoaCarismas.
     * @param {pessoaCarismaDeleteManyArgs} args - Arguments to filter PessoaCarismas to delete.
     * @example
     * // Delete a few PessoaCarismas
     * const { count } = await prisma.pessoaCarisma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pessoaCarismaDeleteManyArgs>(args?: SelectSubset<T, pessoaCarismaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaCarismas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCarismaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PessoaCarismas
     * const pessoaCarisma = await prisma.pessoaCarisma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pessoaCarismaUpdateManyArgs>(args: SelectSubset<T, pessoaCarismaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaCarismas and returns the data updated in the database.
     * @param {pessoaCarismaUpdateManyAndReturnArgs} args - Arguments to update many PessoaCarismas.
     * @example
     * // Update many PessoaCarismas
     * const pessoaCarisma = await prisma.pessoaCarisma.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PessoaCarismas and only return the `pessoaId`
     * const pessoaCarismaWithPessoaIdOnly = await prisma.pessoaCarisma.updateManyAndReturn({
     *   select: { pessoaId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pessoaCarismaUpdateManyAndReturnArgs>(args: SelectSubset<T, pessoaCarismaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PessoaCarisma.
     * @param {pessoaCarismaUpsertArgs} args - Arguments to update or create a PessoaCarisma.
     * @example
     * // Update or create a PessoaCarisma
     * const pessoaCarisma = await prisma.pessoaCarisma.upsert({
     *   create: {
     *     // ... data to create a PessoaCarisma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PessoaCarisma we want to update
     *   }
     * })
     */
    upsert<T extends pessoaCarismaUpsertArgs>(args: SelectSubset<T, pessoaCarismaUpsertArgs<ExtArgs>>): Prisma__pessoaCarismaClient<$Result.GetResult<Prisma.$pessoaCarismaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PessoaCarismas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCarismaCountArgs} args - Arguments to filter PessoaCarismas to count.
     * @example
     * // Count the number of PessoaCarismas
     * const count = await prisma.pessoaCarisma.count({
     *   where: {
     *     // ... the filter for the PessoaCarismas we want to count
     *   }
     * })
    **/
    count<T extends pessoaCarismaCountArgs>(
      args?: Subset<T, pessoaCarismaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaCarismaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PessoaCarisma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaCarismaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaCarismaAggregateArgs>(args: Subset<T, PessoaCarismaAggregateArgs>): Prisma.PrismaPromise<GetPessoaCarismaAggregateType<T>>

    /**
     * Group by PessoaCarisma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaCarismaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pessoaCarismaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pessoaCarismaGroupByArgs['orderBy'] }
        : { orderBy?: pessoaCarismaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pessoaCarismaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaCarismaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pessoaCarisma model
   */
  readonly fields: pessoaCarismaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pessoaCarisma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pessoaCarismaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tipoCarisma<T extends tipoCarismaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipoCarismaDefaultArgs<ExtArgs>>): Prisma__tipoCarismaClient<$Result.GetResult<Prisma.$tipoCarismaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pessoaCarisma model
   */
  interface pessoaCarismaFieldRefs {
    readonly pessoaId: FieldRef<"pessoaCarisma", 'Int'>
    readonly tipoCarismaId: FieldRef<"pessoaCarisma", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pessoaCarisma findUnique
   */
  export type pessoaCarismaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCarisma to fetch.
     */
    where: pessoaCarismaWhereUniqueInput
  }

  /**
   * pessoaCarisma findUniqueOrThrow
   */
  export type pessoaCarismaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCarisma to fetch.
     */
    where: pessoaCarismaWhereUniqueInput
  }

  /**
   * pessoaCarisma findFirst
   */
  export type pessoaCarismaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCarisma to fetch.
     */
    where?: pessoaCarismaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaCarismas to fetch.
     */
    orderBy?: pessoaCarismaOrderByWithRelationInput | pessoaCarismaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoaCarismas.
     */
    cursor?: pessoaCarismaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaCarismas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaCarismas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoaCarismas.
     */
    distinct?: PessoaCarismaScalarFieldEnum | PessoaCarismaScalarFieldEnum[]
  }

  /**
   * pessoaCarisma findFirstOrThrow
   */
  export type pessoaCarismaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCarisma to fetch.
     */
    where?: pessoaCarismaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaCarismas to fetch.
     */
    orderBy?: pessoaCarismaOrderByWithRelationInput | pessoaCarismaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoaCarismas.
     */
    cursor?: pessoaCarismaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaCarismas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaCarismas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoaCarismas.
     */
    distinct?: PessoaCarismaScalarFieldEnum | PessoaCarismaScalarFieldEnum[]
  }

  /**
   * pessoaCarisma findMany
   */
  export type pessoaCarismaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    /**
     * Filter, which pessoaCarismas to fetch.
     */
    where?: pessoaCarismaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaCarismas to fetch.
     */
    orderBy?: pessoaCarismaOrderByWithRelationInput | pessoaCarismaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pessoaCarismas.
     */
    cursor?: pessoaCarismaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaCarismas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaCarismas.
     */
    skip?: number
    distinct?: PessoaCarismaScalarFieldEnum | PessoaCarismaScalarFieldEnum[]
  }

  /**
   * pessoaCarisma create
   */
  export type pessoaCarismaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    /**
     * The data needed to create a pessoaCarisma.
     */
    data: XOR<pessoaCarismaCreateInput, pessoaCarismaUncheckedCreateInput>
  }

  /**
   * pessoaCarisma createMany
   */
  export type pessoaCarismaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pessoaCarismas.
     */
    data: pessoaCarismaCreateManyInput | pessoaCarismaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pessoaCarisma createManyAndReturn
   */
  export type pessoaCarismaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * The data used to create many pessoaCarismas.
     */
    data: pessoaCarismaCreateManyInput | pessoaCarismaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoaCarisma update
   */
  export type pessoaCarismaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    /**
     * The data needed to update a pessoaCarisma.
     */
    data: XOR<pessoaCarismaUpdateInput, pessoaCarismaUncheckedUpdateInput>
    /**
     * Choose, which pessoaCarisma to update.
     */
    where: pessoaCarismaWhereUniqueInput
  }

  /**
   * pessoaCarisma updateMany
   */
  export type pessoaCarismaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pessoaCarismas.
     */
    data: XOR<pessoaCarismaUpdateManyMutationInput, pessoaCarismaUncheckedUpdateManyInput>
    /**
     * Filter which pessoaCarismas to update
     */
    where?: pessoaCarismaWhereInput
    /**
     * Limit how many pessoaCarismas to update.
     */
    limit?: number
  }

  /**
   * pessoaCarisma updateManyAndReturn
   */
  export type pessoaCarismaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * The data used to update pessoaCarismas.
     */
    data: XOR<pessoaCarismaUpdateManyMutationInput, pessoaCarismaUncheckedUpdateManyInput>
    /**
     * Filter which pessoaCarismas to update
     */
    where?: pessoaCarismaWhereInput
    /**
     * Limit how many pessoaCarismas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoaCarisma upsert
   */
  export type pessoaCarismaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    /**
     * The filter to search for the pessoaCarisma to update in case it exists.
     */
    where: pessoaCarismaWhereUniqueInput
    /**
     * In case the pessoaCarisma found by the `where` argument doesn't exist, create a new pessoaCarisma with this data.
     */
    create: XOR<pessoaCarismaCreateInput, pessoaCarismaUncheckedCreateInput>
    /**
     * In case the pessoaCarisma was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pessoaCarismaUpdateInput, pessoaCarismaUncheckedUpdateInput>
  }

  /**
   * pessoaCarisma delete
   */
  export type pessoaCarismaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
    /**
     * Filter which pessoaCarisma to delete.
     */
    where: pessoaCarismaWhereUniqueInput
  }

  /**
   * pessoaCarisma deleteMany
   */
  export type pessoaCarismaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoaCarismas to delete
     */
    where?: pessoaCarismaWhereInput
    /**
     * Limit how many pessoaCarismas to delete.
     */
    limit?: number
  }

  /**
   * pessoaCarisma without action
   */
  export type pessoaCarismaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaCarisma
     */
    select?: pessoaCarismaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaCarisma
     */
    omit?: pessoaCarismaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaCarismaInclude<ExtArgs> | null
  }


  /**
   * Model passaportePessoa
   */

  export type AggregatePassaportePessoa = {
    _count: PassaportePessoaCountAggregateOutputType | null
    _avg: PassaportePessoaAvgAggregateOutputType | null
    _sum: PassaportePessoaSumAggregateOutputType | null
    _min: PassaportePessoaMinAggregateOutputType | null
    _max: PassaportePessoaMaxAggregateOutputType | null
  }

  export type PassaportePessoaAvgAggregateOutputType = {
    id: number | null
    pessoaId: number | null
  }

  export type PassaportePessoaSumAggregateOutputType = {
    id: number | null
    pessoaId: number | null
  }

  export type PassaportePessoaMinAggregateOutputType = {
    id: number | null
    pessoaId: number | null
    numero: string | null
    dataExpiracao: Date | null
    renovado: boolean | null
    dataRenovacao: Date | null
  }

  export type PassaportePessoaMaxAggregateOutputType = {
    id: number | null
    pessoaId: number | null
    numero: string | null
    dataExpiracao: Date | null
    renovado: boolean | null
    dataRenovacao: Date | null
  }

  export type PassaportePessoaCountAggregateOutputType = {
    id: number
    pessoaId: number
    numero: number
    dataExpiracao: number
    renovado: number
    dataRenovacao: number
    _all: number
  }


  export type PassaportePessoaAvgAggregateInputType = {
    id?: true
    pessoaId?: true
  }

  export type PassaportePessoaSumAggregateInputType = {
    id?: true
    pessoaId?: true
  }

  export type PassaportePessoaMinAggregateInputType = {
    id?: true
    pessoaId?: true
    numero?: true
    dataExpiracao?: true
    renovado?: true
    dataRenovacao?: true
  }

  export type PassaportePessoaMaxAggregateInputType = {
    id?: true
    pessoaId?: true
    numero?: true
    dataExpiracao?: true
    renovado?: true
    dataRenovacao?: true
  }

  export type PassaportePessoaCountAggregateInputType = {
    id?: true
    pessoaId?: true
    numero?: true
    dataExpiracao?: true
    renovado?: true
    dataRenovacao?: true
    _all?: true
  }

  export type PassaportePessoaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which passaportePessoa to aggregate.
     */
    where?: passaportePessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passaportePessoas to fetch.
     */
    orderBy?: passaportePessoaOrderByWithRelationInput | passaportePessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: passaportePessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passaportePessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passaportePessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned passaportePessoas
    **/
    _count?: true | PassaportePessoaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PassaportePessoaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PassaportePessoaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassaportePessoaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassaportePessoaMaxAggregateInputType
  }

  export type GetPassaportePessoaAggregateType<T extends PassaportePessoaAggregateArgs> = {
        [P in keyof T & keyof AggregatePassaportePessoa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassaportePessoa[P]>
      : GetScalarType<T[P], AggregatePassaportePessoa[P]>
  }




  export type passaportePessoaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: passaportePessoaWhereInput
    orderBy?: passaportePessoaOrderByWithAggregationInput | passaportePessoaOrderByWithAggregationInput[]
    by: PassaportePessoaScalarFieldEnum[] | PassaportePessoaScalarFieldEnum
    having?: passaportePessoaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassaportePessoaCountAggregateInputType | true
    _avg?: PassaportePessoaAvgAggregateInputType
    _sum?: PassaportePessoaSumAggregateInputType
    _min?: PassaportePessoaMinAggregateInputType
    _max?: PassaportePessoaMaxAggregateInputType
  }

  export type PassaportePessoaGroupByOutputType = {
    id: number
    pessoaId: number
    numero: string
    dataExpiracao: Date
    renovado: boolean
    dataRenovacao: Date | null
    _count: PassaportePessoaCountAggregateOutputType | null
    _avg: PassaportePessoaAvgAggregateOutputType | null
    _sum: PassaportePessoaSumAggregateOutputType | null
    _min: PassaportePessoaMinAggregateOutputType | null
    _max: PassaportePessoaMaxAggregateOutputType | null
  }

  type GetPassaportePessoaGroupByPayload<T extends passaportePessoaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassaportePessoaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassaportePessoaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassaportePessoaGroupByOutputType[P]>
            : GetScalarType<T[P], PassaportePessoaGroupByOutputType[P]>
        }
      >
    >


  export type passaportePessoaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pessoaId?: boolean
    numero?: boolean
    dataExpiracao?: boolean
    renovado?: boolean
    dataRenovacao?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passaportePessoa"]>

  export type passaportePessoaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pessoaId?: boolean
    numero?: boolean
    dataExpiracao?: boolean
    renovado?: boolean
    dataRenovacao?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passaportePessoa"]>

  export type passaportePessoaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pessoaId?: boolean
    numero?: boolean
    dataExpiracao?: boolean
    renovado?: boolean
    dataRenovacao?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passaportePessoa"]>

  export type passaportePessoaSelectScalar = {
    id?: boolean
    pessoaId?: boolean
    numero?: boolean
    dataExpiracao?: boolean
    renovado?: boolean
    dataRenovacao?: boolean
  }

  export type passaportePessoaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pessoaId" | "numero" | "dataExpiracao" | "renovado" | "dataRenovacao", ExtArgs["result"]["passaportePessoa"]>
  export type passaportePessoaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type passaportePessoaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type passaportePessoaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }

  export type $passaportePessoaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "passaportePessoa"
    objects: {
      pessoa: Prisma.$pessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pessoaId: number
      numero: string
      dataExpiracao: Date
      renovado: boolean
      dataRenovacao: Date | null
    }, ExtArgs["result"]["passaportePessoa"]>
    composites: {}
  }

  type passaportePessoaGetPayload<S extends boolean | null | undefined | passaportePessoaDefaultArgs> = $Result.GetResult<Prisma.$passaportePessoaPayload, S>

  type passaportePessoaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<passaportePessoaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassaportePessoaCountAggregateInputType | true
    }

  export interface passaportePessoaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['passaportePessoa'], meta: { name: 'passaportePessoa' } }
    /**
     * Find zero or one PassaportePessoa that matches the filter.
     * @param {passaportePessoaFindUniqueArgs} args - Arguments to find a PassaportePessoa
     * @example
     * // Get one PassaportePessoa
     * const passaportePessoa = await prisma.passaportePessoa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends passaportePessoaFindUniqueArgs>(args: SelectSubset<T, passaportePessoaFindUniqueArgs<ExtArgs>>): Prisma__passaportePessoaClient<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PassaportePessoa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {passaportePessoaFindUniqueOrThrowArgs} args - Arguments to find a PassaportePessoa
     * @example
     * // Get one PassaportePessoa
     * const passaportePessoa = await prisma.passaportePessoa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends passaportePessoaFindUniqueOrThrowArgs>(args: SelectSubset<T, passaportePessoaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__passaportePessoaClient<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PassaportePessoa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passaportePessoaFindFirstArgs} args - Arguments to find a PassaportePessoa
     * @example
     * // Get one PassaportePessoa
     * const passaportePessoa = await prisma.passaportePessoa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends passaportePessoaFindFirstArgs>(args?: SelectSubset<T, passaportePessoaFindFirstArgs<ExtArgs>>): Prisma__passaportePessoaClient<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PassaportePessoa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passaportePessoaFindFirstOrThrowArgs} args - Arguments to find a PassaportePessoa
     * @example
     * // Get one PassaportePessoa
     * const passaportePessoa = await prisma.passaportePessoa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends passaportePessoaFindFirstOrThrowArgs>(args?: SelectSubset<T, passaportePessoaFindFirstOrThrowArgs<ExtArgs>>): Prisma__passaportePessoaClient<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PassaportePessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passaportePessoaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PassaportePessoas
     * const passaportePessoas = await prisma.passaportePessoa.findMany()
     * 
     * // Get first 10 PassaportePessoas
     * const passaportePessoas = await prisma.passaportePessoa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passaportePessoaWithIdOnly = await prisma.passaportePessoa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends passaportePessoaFindManyArgs>(args?: SelectSubset<T, passaportePessoaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PassaportePessoa.
     * @param {passaportePessoaCreateArgs} args - Arguments to create a PassaportePessoa.
     * @example
     * // Create one PassaportePessoa
     * const PassaportePessoa = await prisma.passaportePessoa.create({
     *   data: {
     *     // ... data to create a PassaportePessoa
     *   }
     * })
     * 
     */
    create<T extends passaportePessoaCreateArgs>(args: SelectSubset<T, passaportePessoaCreateArgs<ExtArgs>>): Prisma__passaportePessoaClient<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PassaportePessoas.
     * @param {passaportePessoaCreateManyArgs} args - Arguments to create many PassaportePessoas.
     * @example
     * // Create many PassaportePessoas
     * const passaportePessoa = await prisma.passaportePessoa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends passaportePessoaCreateManyArgs>(args?: SelectSubset<T, passaportePessoaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PassaportePessoas and returns the data saved in the database.
     * @param {passaportePessoaCreateManyAndReturnArgs} args - Arguments to create many PassaportePessoas.
     * @example
     * // Create many PassaportePessoas
     * const passaportePessoa = await prisma.passaportePessoa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PassaportePessoas and only return the `id`
     * const passaportePessoaWithIdOnly = await prisma.passaportePessoa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends passaportePessoaCreateManyAndReturnArgs>(args?: SelectSubset<T, passaportePessoaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PassaportePessoa.
     * @param {passaportePessoaDeleteArgs} args - Arguments to delete one PassaportePessoa.
     * @example
     * // Delete one PassaportePessoa
     * const PassaportePessoa = await prisma.passaportePessoa.delete({
     *   where: {
     *     // ... filter to delete one PassaportePessoa
     *   }
     * })
     * 
     */
    delete<T extends passaportePessoaDeleteArgs>(args: SelectSubset<T, passaportePessoaDeleteArgs<ExtArgs>>): Prisma__passaportePessoaClient<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PassaportePessoa.
     * @param {passaportePessoaUpdateArgs} args - Arguments to update one PassaportePessoa.
     * @example
     * // Update one PassaportePessoa
     * const passaportePessoa = await prisma.passaportePessoa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends passaportePessoaUpdateArgs>(args: SelectSubset<T, passaportePessoaUpdateArgs<ExtArgs>>): Prisma__passaportePessoaClient<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PassaportePessoas.
     * @param {passaportePessoaDeleteManyArgs} args - Arguments to filter PassaportePessoas to delete.
     * @example
     * // Delete a few PassaportePessoas
     * const { count } = await prisma.passaportePessoa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends passaportePessoaDeleteManyArgs>(args?: SelectSubset<T, passaportePessoaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PassaportePessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passaportePessoaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PassaportePessoas
     * const passaportePessoa = await prisma.passaportePessoa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends passaportePessoaUpdateManyArgs>(args: SelectSubset<T, passaportePessoaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PassaportePessoas and returns the data updated in the database.
     * @param {passaportePessoaUpdateManyAndReturnArgs} args - Arguments to update many PassaportePessoas.
     * @example
     * // Update many PassaportePessoas
     * const passaportePessoa = await prisma.passaportePessoa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PassaportePessoas and only return the `id`
     * const passaportePessoaWithIdOnly = await prisma.passaportePessoa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends passaportePessoaUpdateManyAndReturnArgs>(args: SelectSubset<T, passaportePessoaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PassaportePessoa.
     * @param {passaportePessoaUpsertArgs} args - Arguments to update or create a PassaportePessoa.
     * @example
     * // Update or create a PassaportePessoa
     * const passaportePessoa = await prisma.passaportePessoa.upsert({
     *   create: {
     *     // ... data to create a PassaportePessoa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PassaportePessoa we want to update
     *   }
     * })
     */
    upsert<T extends passaportePessoaUpsertArgs>(args: SelectSubset<T, passaportePessoaUpsertArgs<ExtArgs>>): Prisma__passaportePessoaClient<$Result.GetResult<Prisma.$passaportePessoaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PassaportePessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passaportePessoaCountArgs} args - Arguments to filter PassaportePessoas to count.
     * @example
     * // Count the number of PassaportePessoas
     * const count = await prisma.passaportePessoa.count({
     *   where: {
     *     // ... the filter for the PassaportePessoas we want to count
     *   }
     * })
    **/
    count<T extends passaportePessoaCountArgs>(
      args?: Subset<T, passaportePessoaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassaportePessoaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PassaportePessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassaportePessoaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassaportePessoaAggregateArgs>(args: Subset<T, PassaportePessoaAggregateArgs>): Prisma.PrismaPromise<GetPassaportePessoaAggregateType<T>>

    /**
     * Group by PassaportePessoa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {passaportePessoaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends passaportePessoaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: passaportePessoaGroupByArgs['orderBy'] }
        : { orderBy?: passaportePessoaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, passaportePessoaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassaportePessoaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the passaportePessoa model
   */
  readonly fields: passaportePessoaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for passaportePessoa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__passaportePessoaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the passaportePessoa model
   */
  interface passaportePessoaFieldRefs {
    readonly id: FieldRef<"passaportePessoa", 'Int'>
    readonly pessoaId: FieldRef<"passaportePessoa", 'Int'>
    readonly numero: FieldRef<"passaportePessoa", 'String'>
    readonly dataExpiracao: FieldRef<"passaportePessoa", 'DateTime'>
    readonly renovado: FieldRef<"passaportePessoa", 'Boolean'>
    readonly dataRenovacao: FieldRef<"passaportePessoa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * passaportePessoa findUnique
   */
  export type passaportePessoaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    /**
     * Filter, which passaportePessoa to fetch.
     */
    where: passaportePessoaWhereUniqueInput
  }

  /**
   * passaportePessoa findUniqueOrThrow
   */
  export type passaportePessoaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    /**
     * Filter, which passaportePessoa to fetch.
     */
    where: passaportePessoaWhereUniqueInput
  }

  /**
   * passaportePessoa findFirst
   */
  export type passaportePessoaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    /**
     * Filter, which passaportePessoa to fetch.
     */
    where?: passaportePessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passaportePessoas to fetch.
     */
    orderBy?: passaportePessoaOrderByWithRelationInput | passaportePessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passaportePessoas.
     */
    cursor?: passaportePessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passaportePessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passaportePessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passaportePessoas.
     */
    distinct?: PassaportePessoaScalarFieldEnum | PassaportePessoaScalarFieldEnum[]
  }

  /**
   * passaportePessoa findFirstOrThrow
   */
  export type passaportePessoaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    /**
     * Filter, which passaportePessoa to fetch.
     */
    where?: passaportePessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passaportePessoas to fetch.
     */
    orderBy?: passaportePessoaOrderByWithRelationInput | passaportePessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for passaportePessoas.
     */
    cursor?: passaportePessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passaportePessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passaportePessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of passaportePessoas.
     */
    distinct?: PassaportePessoaScalarFieldEnum | PassaportePessoaScalarFieldEnum[]
  }

  /**
   * passaportePessoa findMany
   */
  export type passaportePessoaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    /**
     * Filter, which passaportePessoas to fetch.
     */
    where?: passaportePessoaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of passaportePessoas to fetch.
     */
    orderBy?: passaportePessoaOrderByWithRelationInput | passaportePessoaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing passaportePessoas.
     */
    cursor?: passaportePessoaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` passaportePessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` passaportePessoas.
     */
    skip?: number
    distinct?: PassaportePessoaScalarFieldEnum | PassaportePessoaScalarFieldEnum[]
  }

  /**
   * passaportePessoa create
   */
  export type passaportePessoaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    /**
     * The data needed to create a passaportePessoa.
     */
    data: XOR<passaportePessoaCreateInput, passaportePessoaUncheckedCreateInput>
  }

  /**
   * passaportePessoa createMany
   */
  export type passaportePessoaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many passaportePessoas.
     */
    data: passaportePessoaCreateManyInput | passaportePessoaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * passaportePessoa createManyAndReturn
   */
  export type passaportePessoaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * The data used to create many passaportePessoas.
     */
    data: passaportePessoaCreateManyInput | passaportePessoaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * passaportePessoa update
   */
  export type passaportePessoaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    /**
     * The data needed to update a passaportePessoa.
     */
    data: XOR<passaportePessoaUpdateInput, passaportePessoaUncheckedUpdateInput>
    /**
     * Choose, which passaportePessoa to update.
     */
    where: passaportePessoaWhereUniqueInput
  }

  /**
   * passaportePessoa updateMany
   */
  export type passaportePessoaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update passaportePessoas.
     */
    data: XOR<passaportePessoaUpdateManyMutationInput, passaportePessoaUncheckedUpdateManyInput>
    /**
     * Filter which passaportePessoas to update
     */
    where?: passaportePessoaWhereInput
    /**
     * Limit how many passaportePessoas to update.
     */
    limit?: number
  }

  /**
   * passaportePessoa updateManyAndReturn
   */
  export type passaportePessoaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * The data used to update passaportePessoas.
     */
    data: XOR<passaportePessoaUpdateManyMutationInput, passaportePessoaUncheckedUpdateManyInput>
    /**
     * Filter which passaportePessoas to update
     */
    where?: passaportePessoaWhereInput
    /**
     * Limit how many passaportePessoas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * passaportePessoa upsert
   */
  export type passaportePessoaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    /**
     * The filter to search for the passaportePessoa to update in case it exists.
     */
    where: passaportePessoaWhereUniqueInput
    /**
     * In case the passaportePessoa found by the `where` argument doesn't exist, create a new passaportePessoa with this data.
     */
    create: XOR<passaportePessoaCreateInput, passaportePessoaUncheckedCreateInput>
    /**
     * In case the passaportePessoa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<passaportePessoaUpdateInput, passaportePessoaUncheckedUpdateInput>
  }

  /**
   * passaportePessoa delete
   */
  export type passaportePessoaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
    /**
     * Filter which passaportePessoa to delete.
     */
    where: passaportePessoaWhereUniqueInput
  }

  /**
   * passaportePessoa deleteMany
   */
  export type passaportePessoaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which passaportePessoas to delete
     */
    where?: passaportePessoaWhereInput
    /**
     * Limit how many passaportePessoas to delete.
     */
    limit?: number
  }

  /**
   * passaportePessoa without action
   */
  export type passaportePessoaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the passaportePessoa
     */
    select?: passaportePessoaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the passaportePessoa
     */
    omit?: passaportePessoaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: passaportePessoaInclude<ExtArgs> | null
  }


  /**
   * Model pessoaContato
   */

  export type AggregatePessoaContato = {
    _count: PessoaContatoCountAggregateOutputType | null
    _avg: PessoaContatoAvgAggregateOutputType | null
    _sum: PessoaContatoSumAggregateOutputType | null
    _min: PessoaContatoMinAggregateOutputType | null
    _max: PessoaContatoMaxAggregateOutputType | null
  }

  export type PessoaContatoAvgAggregateOutputType = {
    id: number | null
    pessoaId: number | null
  }

  export type PessoaContatoSumAggregateOutputType = {
    id: number | null
    pessoaId: number | null
  }

  export type PessoaContatoMinAggregateOutputType = {
    id: number | null
    telefoneResidencial: string | null
    telefoneCelular: string | null
    observacao: string | null
    ativo: boolean | null
    email: string | null
    pessoaId: number | null
  }

  export type PessoaContatoMaxAggregateOutputType = {
    id: number | null
    telefoneResidencial: string | null
    telefoneCelular: string | null
    observacao: string | null
    ativo: boolean | null
    email: string | null
    pessoaId: number | null
  }

  export type PessoaContatoCountAggregateOutputType = {
    id: number
    telefoneResidencial: number
    telefoneCelular: number
    observacao: number
    ativo: number
    email: number
    pessoaId: number
    _all: number
  }


  export type PessoaContatoAvgAggregateInputType = {
    id?: true
    pessoaId?: true
  }

  export type PessoaContatoSumAggregateInputType = {
    id?: true
    pessoaId?: true
  }

  export type PessoaContatoMinAggregateInputType = {
    id?: true
    telefoneResidencial?: true
    telefoneCelular?: true
    observacao?: true
    ativo?: true
    email?: true
    pessoaId?: true
  }

  export type PessoaContatoMaxAggregateInputType = {
    id?: true
    telefoneResidencial?: true
    telefoneCelular?: true
    observacao?: true
    ativo?: true
    email?: true
    pessoaId?: true
  }

  export type PessoaContatoCountAggregateInputType = {
    id?: true
    telefoneResidencial?: true
    telefoneCelular?: true
    observacao?: true
    ativo?: true
    email?: true
    pessoaId?: true
    _all?: true
  }

  export type PessoaContatoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoaContato to aggregate.
     */
    where?: pessoaContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaContatoes to fetch.
     */
    orderBy?: pessoaContatoOrderByWithRelationInput | pessoaContatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: pessoaContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaContatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaContatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pessoaContatoes
    **/
    _count?: true | PessoaContatoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PessoaContatoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PessoaContatoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PessoaContatoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PessoaContatoMaxAggregateInputType
  }

  export type GetPessoaContatoAggregateType<T extends PessoaContatoAggregateArgs> = {
        [P in keyof T & keyof AggregatePessoaContato]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePessoaContato[P]>
      : GetScalarType<T[P], AggregatePessoaContato[P]>
  }




  export type pessoaContatoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: pessoaContatoWhereInput
    orderBy?: pessoaContatoOrderByWithAggregationInput | pessoaContatoOrderByWithAggregationInput[]
    by: PessoaContatoScalarFieldEnum[] | PessoaContatoScalarFieldEnum
    having?: pessoaContatoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PessoaContatoCountAggregateInputType | true
    _avg?: PessoaContatoAvgAggregateInputType
    _sum?: PessoaContatoSumAggregateInputType
    _min?: PessoaContatoMinAggregateInputType
    _max?: PessoaContatoMaxAggregateInputType
  }

  export type PessoaContatoGroupByOutputType = {
    id: number
    telefoneResidencial: string | null
    telefoneCelular: string | null
    observacao: string | null
    ativo: boolean
    email: string | null
    pessoaId: number
    _count: PessoaContatoCountAggregateOutputType | null
    _avg: PessoaContatoAvgAggregateOutputType | null
    _sum: PessoaContatoSumAggregateOutputType | null
    _min: PessoaContatoMinAggregateOutputType | null
    _max: PessoaContatoMaxAggregateOutputType | null
  }

  type GetPessoaContatoGroupByPayload<T extends pessoaContatoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PessoaContatoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PessoaContatoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PessoaContatoGroupByOutputType[P]>
            : GetScalarType<T[P], PessoaContatoGroupByOutputType[P]>
        }
      >
    >


  export type pessoaContatoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telefoneResidencial?: boolean
    telefoneCelular?: boolean
    observacao?: boolean
    ativo?: boolean
    email?: boolean
    pessoaId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaContato"]>

  export type pessoaContatoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telefoneResidencial?: boolean
    telefoneCelular?: boolean
    observacao?: boolean
    ativo?: boolean
    email?: boolean
    pessoaId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaContato"]>

  export type pessoaContatoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telefoneResidencial?: boolean
    telefoneCelular?: boolean
    observacao?: boolean
    ativo?: boolean
    email?: boolean
    pessoaId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pessoaContato"]>

  export type pessoaContatoSelectScalar = {
    id?: boolean
    telefoneResidencial?: boolean
    telefoneCelular?: boolean
    observacao?: boolean
    ativo?: boolean
    email?: boolean
    pessoaId?: boolean
  }

  export type pessoaContatoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "telefoneResidencial" | "telefoneCelular" | "observacao" | "ativo" | "email" | "pessoaId", ExtArgs["result"]["pessoaContato"]>
  export type pessoaContatoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type pessoaContatoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type pessoaContatoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }

  export type $pessoaContatoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "pessoaContato"
    objects: {
      pessoa: Prisma.$pessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      telefoneResidencial: string | null
      telefoneCelular: string | null
      observacao: string | null
      ativo: boolean
      email: string | null
      pessoaId: number
    }, ExtArgs["result"]["pessoaContato"]>
    composites: {}
  }

  type pessoaContatoGetPayload<S extends boolean | null | undefined | pessoaContatoDefaultArgs> = $Result.GetResult<Prisma.$pessoaContatoPayload, S>

  type pessoaContatoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<pessoaContatoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PessoaContatoCountAggregateInputType | true
    }

  export interface pessoaContatoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['pessoaContato'], meta: { name: 'pessoaContato' } }
    /**
     * Find zero or one PessoaContato that matches the filter.
     * @param {pessoaContatoFindUniqueArgs} args - Arguments to find a PessoaContato
     * @example
     * // Get one PessoaContato
     * const pessoaContato = await prisma.pessoaContato.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends pessoaContatoFindUniqueArgs>(args: SelectSubset<T, pessoaContatoFindUniqueArgs<ExtArgs>>): Prisma__pessoaContatoClient<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PessoaContato that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {pessoaContatoFindUniqueOrThrowArgs} args - Arguments to find a PessoaContato
     * @example
     * // Get one PessoaContato
     * const pessoaContato = await prisma.pessoaContato.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends pessoaContatoFindUniqueOrThrowArgs>(args: SelectSubset<T, pessoaContatoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__pessoaContatoClient<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaContato that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaContatoFindFirstArgs} args - Arguments to find a PessoaContato
     * @example
     * // Get one PessoaContato
     * const pessoaContato = await prisma.pessoaContato.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends pessoaContatoFindFirstArgs>(args?: SelectSubset<T, pessoaContatoFindFirstArgs<ExtArgs>>): Prisma__pessoaContatoClient<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PessoaContato that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaContatoFindFirstOrThrowArgs} args - Arguments to find a PessoaContato
     * @example
     * // Get one PessoaContato
     * const pessoaContato = await prisma.pessoaContato.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends pessoaContatoFindFirstOrThrowArgs>(args?: SelectSubset<T, pessoaContatoFindFirstOrThrowArgs<ExtArgs>>): Prisma__pessoaContatoClient<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PessoaContatoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaContatoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PessoaContatoes
     * const pessoaContatoes = await prisma.pessoaContato.findMany()
     * 
     * // Get first 10 PessoaContatoes
     * const pessoaContatoes = await prisma.pessoaContato.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pessoaContatoWithIdOnly = await prisma.pessoaContato.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends pessoaContatoFindManyArgs>(args?: SelectSubset<T, pessoaContatoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PessoaContato.
     * @param {pessoaContatoCreateArgs} args - Arguments to create a PessoaContato.
     * @example
     * // Create one PessoaContato
     * const PessoaContato = await prisma.pessoaContato.create({
     *   data: {
     *     // ... data to create a PessoaContato
     *   }
     * })
     * 
     */
    create<T extends pessoaContatoCreateArgs>(args: SelectSubset<T, pessoaContatoCreateArgs<ExtArgs>>): Prisma__pessoaContatoClient<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PessoaContatoes.
     * @param {pessoaContatoCreateManyArgs} args - Arguments to create many PessoaContatoes.
     * @example
     * // Create many PessoaContatoes
     * const pessoaContato = await prisma.pessoaContato.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends pessoaContatoCreateManyArgs>(args?: SelectSubset<T, pessoaContatoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PessoaContatoes and returns the data saved in the database.
     * @param {pessoaContatoCreateManyAndReturnArgs} args - Arguments to create many PessoaContatoes.
     * @example
     * // Create many PessoaContatoes
     * const pessoaContato = await prisma.pessoaContato.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PessoaContatoes and only return the `id`
     * const pessoaContatoWithIdOnly = await prisma.pessoaContato.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends pessoaContatoCreateManyAndReturnArgs>(args?: SelectSubset<T, pessoaContatoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PessoaContato.
     * @param {pessoaContatoDeleteArgs} args - Arguments to delete one PessoaContato.
     * @example
     * // Delete one PessoaContato
     * const PessoaContato = await prisma.pessoaContato.delete({
     *   where: {
     *     // ... filter to delete one PessoaContato
     *   }
     * })
     * 
     */
    delete<T extends pessoaContatoDeleteArgs>(args: SelectSubset<T, pessoaContatoDeleteArgs<ExtArgs>>): Prisma__pessoaContatoClient<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PessoaContato.
     * @param {pessoaContatoUpdateArgs} args - Arguments to update one PessoaContato.
     * @example
     * // Update one PessoaContato
     * const pessoaContato = await prisma.pessoaContato.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends pessoaContatoUpdateArgs>(args: SelectSubset<T, pessoaContatoUpdateArgs<ExtArgs>>): Prisma__pessoaContatoClient<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PessoaContatoes.
     * @param {pessoaContatoDeleteManyArgs} args - Arguments to filter PessoaContatoes to delete.
     * @example
     * // Delete a few PessoaContatoes
     * const { count } = await prisma.pessoaContato.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends pessoaContatoDeleteManyArgs>(args?: SelectSubset<T, pessoaContatoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaContatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaContatoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PessoaContatoes
     * const pessoaContato = await prisma.pessoaContato.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends pessoaContatoUpdateManyArgs>(args: SelectSubset<T, pessoaContatoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PessoaContatoes and returns the data updated in the database.
     * @param {pessoaContatoUpdateManyAndReturnArgs} args - Arguments to update many PessoaContatoes.
     * @example
     * // Update many PessoaContatoes
     * const pessoaContato = await prisma.pessoaContato.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PessoaContatoes and only return the `id`
     * const pessoaContatoWithIdOnly = await prisma.pessoaContato.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends pessoaContatoUpdateManyAndReturnArgs>(args: SelectSubset<T, pessoaContatoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PessoaContato.
     * @param {pessoaContatoUpsertArgs} args - Arguments to update or create a PessoaContato.
     * @example
     * // Update or create a PessoaContato
     * const pessoaContato = await prisma.pessoaContato.upsert({
     *   create: {
     *     // ... data to create a PessoaContato
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PessoaContato we want to update
     *   }
     * })
     */
    upsert<T extends pessoaContatoUpsertArgs>(args: SelectSubset<T, pessoaContatoUpsertArgs<ExtArgs>>): Prisma__pessoaContatoClient<$Result.GetResult<Prisma.$pessoaContatoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PessoaContatoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaContatoCountArgs} args - Arguments to filter PessoaContatoes to count.
     * @example
     * // Count the number of PessoaContatoes
     * const count = await prisma.pessoaContato.count({
     *   where: {
     *     // ... the filter for the PessoaContatoes we want to count
     *   }
     * })
    **/
    count<T extends pessoaContatoCountArgs>(
      args?: Subset<T, pessoaContatoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PessoaContatoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PessoaContato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PessoaContatoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PessoaContatoAggregateArgs>(args: Subset<T, PessoaContatoAggregateArgs>): Prisma.PrismaPromise<GetPessoaContatoAggregateType<T>>

    /**
     * Group by PessoaContato.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pessoaContatoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends pessoaContatoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: pessoaContatoGroupByArgs['orderBy'] }
        : { orderBy?: pessoaContatoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, pessoaContatoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPessoaContatoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the pessoaContato model
   */
  readonly fields: pessoaContatoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for pessoaContato.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__pessoaContatoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the pessoaContato model
   */
  interface pessoaContatoFieldRefs {
    readonly id: FieldRef<"pessoaContato", 'Int'>
    readonly telefoneResidencial: FieldRef<"pessoaContato", 'String'>
    readonly telefoneCelular: FieldRef<"pessoaContato", 'String'>
    readonly observacao: FieldRef<"pessoaContato", 'String'>
    readonly ativo: FieldRef<"pessoaContato", 'Boolean'>
    readonly email: FieldRef<"pessoaContato", 'String'>
    readonly pessoaId: FieldRef<"pessoaContato", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * pessoaContato findUnique
   */
  export type pessoaContatoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaContato to fetch.
     */
    where: pessoaContatoWhereUniqueInput
  }

  /**
   * pessoaContato findUniqueOrThrow
   */
  export type pessoaContatoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaContato to fetch.
     */
    where: pessoaContatoWhereUniqueInput
  }

  /**
   * pessoaContato findFirst
   */
  export type pessoaContatoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaContato to fetch.
     */
    where?: pessoaContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaContatoes to fetch.
     */
    orderBy?: pessoaContatoOrderByWithRelationInput | pessoaContatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoaContatoes.
     */
    cursor?: pessoaContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaContatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaContatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoaContatoes.
     */
    distinct?: PessoaContatoScalarFieldEnum | PessoaContatoScalarFieldEnum[]
  }

  /**
   * pessoaContato findFirstOrThrow
   */
  export type pessoaContatoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaContato to fetch.
     */
    where?: pessoaContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaContatoes to fetch.
     */
    orderBy?: pessoaContatoOrderByWithRelationInput | pessoaContatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pessoaContatoes.
     */
    cursor?: pessoaContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaContatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaContatoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pessoaContatoes.
     */
    distinct?: PessoaContatoScalarFieldEnum | PessoaContatoScalarFieldEnum[]
  }

  /**
   * pessoaContato findMany
   */
  export type pessoaContatoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    /**
     * Filter, which pessoaContatoes to fetch.
     */
    where?: pessoaContatoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pessoaContatoes to fetch.
     */
    orderBy?: pessoaContatoOrderByWithRelationInput | pessoaContatoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pessoaContatoes.
     */
    cursor?: pessoaContatoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pessoaContatoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pessoaContatoes.
     */
    skip?: number
    distinct?: PessoaContatoScalarFieldEnum | PessoaContatoScalarFieldEnum[]
  }

  /**
   * pessoaContato create
   */
  export type pessoaContatoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    /**
     * The data needed to create a pessoaContato.
     */
    data: XOR<pessoaContatoCreateInput, pessoaContatoUncheckedCreateInput>
  }

  /**
   * pessoaContato createMany
   */
  export type pessoaContatoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many pessoaContatoes.
     */
    data: pessoaContatoCreateManyInput | pessoaContatoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * pessoaContato createManyAndReturn
   */
  export type pessoaContatoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * The data used to create many pessoaContatoes.
     */
    data: pessoaContatoCreateManyInput | pessoaContatoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoaContato update
   */
  export type pessoaContatoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    /**
     * The data needed to update a pessoaContato.
     */
    data: XOR<pessoaContatoUpdateInput, pessoaContatoUncheckedUpdateInput>
    /**
     * Choose, which pessoaContato to update.
     */
    where: pessoaContatoWhereUniqueInput
  }

  /**
   * pessoaContato updateMany
   */
  export type pessoaContatoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update pessoaContatoes.
     */
    data: XOR<pessoaContatoUpdateManyMutationInput, pessoaContatoUncheckedUpdateManyInput>
    /**
     * Filter which pessoaContatoes to update
     */
    where?: pessoaContatoWhereInput
    /**
     * Limit how many pessoaContatoes to update.
     */
    limit?: number
  }

  /**
   * pessoaContato updateManyAndReturn
   */
  export type pessoaContatoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * The data used to update pessoaContatoes.
     */
    data: XOR<pessoaContatoUpdateManyMutationInput, pessoaContatoUncheckedUpdateManyInput>
    /**
     * Filter which pessoaContatoes to update
     */
    where?: pessoaContatoWhereInput
    /**
     * Limit how many pessoaContatoes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * pessoaContato upsert
   */
  export type pessoaContatoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    /**
     * The filter to search for the pessoaContato to update in case it exists.
     */
    where: pessoaContatoWhereUniqueInput
    /**
     * In case the pessoaContato found by the `where` argument doesn't exist, create a new pessoaContato with this data.
     */
    create: XOR<pessoaContatoCreateInput, pessoaContatoUncheckedCreateInput>
    /**
     * In case the pessoaContato was found with the provided `where` argument, update it with this data.
     */
    update: XOR<pessoaContatoUpdateInput, pessoaContatoUncheckedUpdateInput>
  }

  /**
   * pessoaContato delete
   */
  export type pessoaContatoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
    /**
     * Filter which pessoaContato to delete.
     */
    where: pessoaContatoWhereUniqueInput
  }

  /**
   * pessoaContato deleteMany
   */
  export type pessoaContatoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which pessoaContatoes to delete
     */
    where?: pessoaContatoWhereInput
    /**
     * Limit how many pessoaContatoes to delete.
     */
    limit?: number
  }

  /**
   * pessoaContato without action
   */
  export type pessoaContatoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the pessoaContato
     */
    select?: pessoaContatoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the pessoaContato
     */
    omit?: pessoaContatoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: pessoaContatoInclude<ExtArgs> | null
  }


  /**
   * Model tipoDiocese
   */

  export type AggregateTipoDiocese = {
    _count: TipoDioceseCountAggregateOutputType | null
    _avg: TipoDioceseAvgAggregateOutputType | null
    _sum: TipoDioceseSumAggregateOutputType | null
    _min: TipoDioceseMinAggregateOutputType | null
    _max: TipoDioceseMaxAggregateOutputType | null
  }

  export type TipoDioceseAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoDioceseSumAggregateOutputType = {
    id: number | null
  }

  export type TipoDioceseMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoDioceseMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoDioceseCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type TipoDioceseAvgAggregateInputType = {
    id?: true
  }

  export type TipoDioceseSumAggregateInputType = {
    id?: true
  }

  export type TipoDioceseMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoDioceseMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoDioceseCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type TipoDioceseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoDiocese to aggregate.
     */
    where?: tipoDioceseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoDiocese to fetch.
     */
    orderBy?: tipoDioceseOrderByWithRelationInput | tipoDioceseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipoDioceseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoDiocese from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoDiocese.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipoDiocese
    **/
    _count?: true | TipoDioceseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoDioceseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoDioceseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoDioceseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoDioceseMaxAggregateInputType
  }

  export type GetTipoDioceseAggregateType<T extends TipoDioceseAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoDiocese]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoDiocese[P]>
      : GetScalarType<T[P], AggregateTipoDiocese[P]>
  }




  export type tipoDioceseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipoDioceseWhereInput
    orderBy?: tipoDioceseOrderByWithAggregationInput | tipoDioceseOrderByWithAggregationInput[]
    by: TipoDioceseScalarFieldEnum[] | TipoDioceseScalarFieldEnum
    having?: tipoDioceseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoDioceseCountAggregateInputType | true
    _avg?: TipoDioceseAvgAggregateInputType
    _sum?: TipoDioceseSumAggregateInputType
    _min?: TipoDioceseMinAggregateInputType
    _max?: TipoDioceseMaxAggregateInputType
  }

  export type TipoDioceseGroupByOutputType = {
    id: number
    descricao: string
    _count: TipoDioceseCountAggregateOutputType | null
    _avg: TipoDioceseAvgAggregateOutputType | null
    _sum: TipoDioceseSumAggregateOutputType | null
    _min: TipoDioceseMinAggregateOutputType | null
    _max: TipoDioceseMaxAggregateOutputType | null
  }

  type GetTipoDioceseGroupByPayload<T extends tipoDioceseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoDioceseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoDioceseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoDioceseGroupByOutputType[P]>
            : GetScalarType<T[P], TipoDioceseGroupByOutputType[P]>
        }
      >
    >


  export type tipoDioceseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    dioceses?: boolean | tipoDiocese$diocesesArgs<ExtArgs>
    _count?: boolean | TipoDioceseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoDiocese"]>

  export type tipoDioceseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoDiocese"]>

  export type tipoDioceseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoDiocese"]>

  export type tipoDioceseSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type tipoDioceseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["tipoDiocese"]>
  export type tipoDioceseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dioceses?: boolean | tipoDiocese$diocesesArgs<ExtArgs>
    _count?: boolean | TipoDioceseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tipoDioceseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tipoDioceseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tipoDiocesePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipoDiocese"
    objects: {
      dioceses: Prisma.$diocesePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["tipoDiocese"]>
    composites: {}
  }

  type tipoDioceseGetPayload<S extends boolean | null | undefined | tipoDioceseDefaultArgs> = $Result.GetResult<Prisma.$tipoDiocesePayload, S>

  type tipoDioceseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipoDioceseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoDioceseCountAggregateInputType | true
    }

  export interface tipoDioceseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipoDiocese'], meta: { name: 'tipoDiocese' } }
    /**
     * Find zero or one TipoDiocese that matches the filter.
     * @param {tipoDioceseFindUniqueArgs} args - Arguments to find a TipoDiocese
     * @example
     * // Get one TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipoDioceseFindUniqueArgs>(args: SelectSubset<T, tipoDioceseFindUniqueArgs<ExtArgs>>): Prisma__tipoDioceseClient<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoDiocese that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipoDioceseFindUniqueOrThrowArgs} args - Arguments to find a TipoDiocese
     * @example
     * // Get one TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipoDioceseFindUniqueOrThrowArgs>(args: SelectSubset<T, tipoDioceseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipoDioceseClient<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoDiocese that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoDioceseFindFirstArgs} args - Arguments to find a TipoDiocese
     * @example
     * // Get one TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipoDioceseFindFirstArgs>(args?: SelectSubset<T, tipoDioceseFindFirstArgs<ExtArgs>>): Prisma__tipoDioceseClient<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoDiocese that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoDioceseFindFirstOrThrowArgs} args - Arguments to find a TipoDiocese
     * @example
     * // Get one TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipoDioceseFindFirstOrThrowArgs>(args?: SelectSubset<T, tipoDioceseFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipoDioceseClient<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoDiocese that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoDioceseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.findMany()
     * 
     * // Get first 10 TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoDioceseWithIdOnly = await prisma.tipoDiocese.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tipoDioceseFindManyArgs>(args?: SelectSubset<T, tipoDioceseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoDiocese.
     * @param {tipoDioceseCreateArgs} args - Arguments to create a TipoDiocese.
     * @example
     * // Create one TipoDiocese
     * const TipoDiocese = await prisma.tipoDiocese.create({
     *   data: {
     *     // ... data to create a TipoDiocese
     *   }
     * })
     * 
     */
    create<T extends tipoDioceseCreateArgs>(args: SelectSubset<T, tipoDioceseCreateArgs<ExtArgs>>): Prisma__tipoDioceseClient<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoDiocese.
     * @param {tipoDioceseCreateManyArgs} args - Arguments to create many TipoDiocese.
     * @example
     * // Create many TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipoDioceseCreateManyArgs>(args?: SelectSubset<T, tipoDioceseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoDiocese and returns the data saved in the database.
     * @param {tipoDioceseCreateManyAndReturnArgs} args - Arguments to create many TipoDiocese.
     * @example
     * // Create many TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoDiocese and only return the `id`
     * const tipoDioceseWithIdOnly = await prisma.tipoDiocese.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tipoDioceseCreateManyAndReturnArgs>(args?: SelectSubset<T, tipoDioceseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoDiocese.
     * @param {tipoDioceseDeleteArgs} args - Arguments to delete one TipoDiocese.
     * @example
     * // Delete one TipoDiocese
     * const TipoDiocese = await prisma.tipoDiocese.delete({
     *   where: {
     *     // ... filter to delete one TipoDiocese
     *   }
     * })
     * 
     */
    delete<T extends tipoDioceseDeleteArgs>(args: SelectSubset<T, tipoDioceseDeleteArgs<ExtArgs>>): Prisma__tipoDioceseClient<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoDiocese.
     * @param {tipoDioceseUpdateArgs} args - Arguments to update one TipoDiocese.
     * @example
     * // Update one TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipoDioceseUpdateArgs>(args: SelectSubset<T, tipoDioceseUpdateArgs<ExtArgs>>): Prisma__tipoDioceseClient<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoDiocese.
     * @param {tipoDioceseDeleteManyArgs} args - Arguments to filter TipoDiocese to delete.
     * @example
     * // Delete a few TipoDiocese
     * const { count } = await prisma.tipoDiocese.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipoDioceseDeleteManyArgs>(args?: SelectSubset<T, tipoDioceseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoDiocese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoDioceseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipoDioceseUpdateManyArgs>(args: SelectSubset<T, tipoDioceseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoDiocese and returns the data updated in the database.
     * @param {tipoDioceseUpdateManyAndReturnArgs} args - Arguments to update many TipoDiocese.
     * @example
     * // Update many TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoDiocese and only return the `id`
     * const tipoDioceseWithIdOnly = await prisma.tipoDiocese.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tipoDioceseUpdateManyAndReturnArgs>(args: SelectSubset<T, tipoDioceseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoDiocese.
     * @param {tipoDioceseUpsertArgs} args - Arguments to update or create a TipoDiocese.
     * @example
     * // Update or create a TipoDiocese
     * const tipoDiocese = await prisma.tipoDiocese.upsert({
     *   create: {
     *     // ... data to create a TipoDiocese
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoDiocese we want to update
     *   }
     * })
     */
    upsert<T extends tipoDioceseUpsertArgs>(args: SelectSubset<T, tipoDioceseUpsertArgs<ExtArgs>>): Prisma__tipoDioceseClient<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoDiocese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoDioceseCountArgs} args - Arguments to filter TipoDiocese to count.
     * @example
     * // Count the number of TipoDiocese
     * const count = await prisma.tipoDiocese.count({
     *   where: {
     *     // ... the filter for the TipoDiocese we want to count
     *   }
     * })
    **/
    count<T extends tipoDioceseCountArgs>(
      args?: Subset<T, tipoDioceseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoDioceseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoDiocese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoDioceseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoDioceseAggregateArgs>(args: Subset<T, TipoDioceseAggregateArgs>): Prisma.PrismaPromise<GetTipoDioceseAggregateType<T>>

    /**
     * Group by TipoDiocese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoDioceseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipoDioceseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipoDioceseGroupByArgs['orderBy'] }
        : { orderBy?: tipoDioceseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipoDioceseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoDioceseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipoDiocese model
   */
  readonly fields: tipoDioceseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipoDiocese.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipoDioceseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dioceses<T extends tipoDiocese$diocesesArgs<ExtArgs> = {}>(args?: Subset<T, tipoDiocese$diocesesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipoDiocese model
   */
  interface tipoDioceseFieldRefs {
    readonly id: FieldRef<"tipoDiocese", 'Int'>
    readonly descricao: FieldRef<"tipoDiocese", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tipoDiocese findUnique
   */
  export type tipoDioceseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
    /**
     * Filter, which tipoDiocese to fetch.
     */
    where: tipoDioceseWhereUniqueInput
  }

  /**
   * tipoDiocese findUniqueOrThrow
   */
  export type tipoDioceseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
    /**
     * Filter, which tipoDiocese to fetch.
     */
    where: tipoDioceseWhereUniqueInput
  }

  /**
   * tipoDiocese findFirst
   */
  export type tipoDioceseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
    /**
     * Filter, which tipoDiocese to fetch.
     */
    where?: tipoDioceseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoDiocese to fetch.
     */
    orderBy?: tipoDioceseOrderByWithRelationInput | tipoDioceseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoDiocese.
     */
    cursor?: tipoDioceseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoDiocese from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoDiocese.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoDiocese.
     */
    distinct?: TipoDioceseScalarFieldEnum | TipoDioceseScalarFieldEnum[]
  }

  /**
   * tipoDiocese findFirstOrThrow
   */
  export type tipoDioceseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
    /**
     * Filter, which tipoDiocese to fetch.
     */
    where?: tipoDioceseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoDiocese to fetch.
     */
    orderBy?: tipoDioceseOrderByWithRelationInput | tipoDioceseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoDiocese.
     */
    cursor?: tipoDioceseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoDiocese from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoDiocese.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoDiocese.
     */
    distinct?: TipoDioceseScalarFieldEnum | TipoDioceseScalarFieldEnum[]
  }

  /**
   * tipoDiocese findMany
   */
  export type tipoDioceseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
    /**
     * Filter, which tipoDiocese to fetch.
     */
    where?: tipoDioceseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoDiocese to fetch.
     */
    orderBy?: tipoDioceseOrderByWithRelationInput | tipoDioceseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipoDiocese.
     */
    cursor?: tipoDioceseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoDiocese from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoDiocese.
     */
    skip?: number
    distinct?: TipoDioceseScalarFieldEnum | TipoDioceseScalarFieldEnum[]
  }

  /**
   * tipoDiocese create
   */
  export type tipoDioceseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
    /**
     * The data needed to create a tipoDiocese.
     */
    data: XOR<tipoDioceseCreateInput, tipoDioceseUncheckedCreateInput>
  }

  /**
   * tipoDiocese createMany
   */
  export type tipoDioceseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipoDiocese.
     */
    data: tipoDioceseCreateManyInput | tipoDioceseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoDiocese createManyAndReturn
   */
  export type tipoDioceseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * The data used to create many tipoDiocese.
     */
    data: tipoDioceseCreateManyInput | tipoDioceseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoDiocese update
   */
  export type tipoDioceseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
    /**
     * The data needed to update a tipoDiocese.
     */
    data: XOR<tipoDioceseUpdateInput, tipoDioceseUncheckedUpdateInput>
    /**
     * Choose, which tipoDiocese to update.
     */
    where: tipoDioceseWhereUniqueInput
  }

  /**
   * tipoDiocese updateMany
   */
  export type tipoDioceseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipoDiocese.
     */
    data: XOR<tipoDioceseUpdateManyMutationInput, tipoDioceseUncheckedUpdateManyInput>
    /**
     * Filter which tipoDiocese to update
     */
    where?: tipoDioceseWhereInput
    /**
     * Limit how many tipoDiocese to update.
     */
    limit?: number
  }

  /**
   * tipoDiocese updateManyAndReturn
   */
  export type tipoDioceseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * The data used to update tipoDiocese.
     */
    data: XOR<tipoDioceseUpdateManyMutationInput, tipoDioceseUncheckedUpdateManyInput>
    /**
     * Filter which tipoDiocese to update
     */
    where?: tipoDioceseWhereInput
    /**
     * Limit how many tipoDiocese to update.
     */
    limit?: number
  }

  /**
   * tipoDiocese upsert
   */
  export type tipoDioceseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
    /**
     * The filter to search for the tipoDiocese to update in case it exists.
     */
    where: tipoDioceseWhereUniqueInput
    /**
     * In case the tipoDiocese found by the `where` argument doesn't exist, create a new tipoDiocese with this data.
     */
    create: XOR<tipoDioceseCreateInput, tipoDioceseUncheckedCreateInput>
    /**
     * In case the tipoDiocese was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipoDioceseUpdateInput, tipoDioceseUncheckedUpdateInput>
  }

  /**
   * tipoDiocese delete
   */
  export type tipoDioceseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
    /**
     * Filter which tipoDiocese to delete.
     */
    where: tipoDioceseWhereUniqueInput
  }

  /**
   * tipoDiocese deleteMany
   */
  export type tipoDioceseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoDiocese to delete
     */
    where?: tipoDioceseWhereInput
    /**
     * Limit how many tipoDiocese to delete.
     */
    limit?: number
  }

  /**
   * tipoDiocese.dioceses
   */
  export type tipoDiocese$diocesesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    where?: dioceseWhereInput
    orderBy?: dioceseOrderByWithRelationInput | dioceseOrderByWithRelationInput[]
    cursor?: dioceseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DioceseScalarFieldEnum | DioceseScalarFieldEnum[]
  }

  /**
   * tipoDiocese without action
   */
  export type tipoDioceseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoDiocese
     */
    select?: tipoDioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoDiocese
     */
    omit?: tipoDioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoDioceseInclude<ExtArgs> | null
  }


  /**
   * Model diocese
   */

  export type AggregateDiocese = {
    _count: DioceseCountAggregateOutputType | null
    _avg: DioceseAvgAggregateOutputType | null
    _sum: DioceseSumAggregateOutputType | null
    _min: DioceseMinAggregateOutputType | null
    _max: DioceseMaxAggregateOutputType | null
  }

  export type DioceseAvgAggregateOutputType = {
    id: number | null
    tipoDioceseId: number | null
    enderecoId: number | null
  }

  export type DioceseSumAggregateOutputType = {
    id: number | null
    tipoDioceseId: number | null
    enderecoId: number | null
  }

  export type DioceseMinAggregateOutputType = {
    id: number | null
    tipoDioceseId: number | null
    descricao: string | null
    enderecoId: number | null
  }

  export type DioceseMaxAggregateOutputType = {
    id: number | null
    tipoDioceseId: number | null
    descricao: string | null
    enderecoId: number | null
  }

  export type DioceseCountAggregateOutputType = {
    id: number
    tipoDioceseId: number
    descricao: number
    enderecoId: number
    _all: number
  }


  export type DioceseAvgAggregateInputType = {
    id?: true
    tipoDioceseId?: true
    enderecoId?: true
  }

  export type DioceseSumAggregateInputType = {
    id?: true
    tipoDioceseId?: true
    enderecoId?: true
  }

  export type DioceseMinAggregateInputType = {
    id?: true
    tipoDioceseId?: true
    descricao?: true
    enderecoId?: true
  }

  export type DioceseMaxAggregateInputType = {
    id?: true
    tipoDioceseId?: true
    descricao?: true
    enderecoId?: true
  }

  export type DioceseCountAggregateInputType = {
    id?: true
    tipoDioceseId?: true
    descricao?: true
    enderecoId?: true
    _all?: true
  }

  export type DioceseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diocese to aggregate.
     */
    where?: dioceseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diocese to fetch.
     */
    orderBy?: dioceseOrderByWithRelationInput | dioceseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dioceseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diocese from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diocese.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned diocese
    **/
    _count?: true | DioceseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DioceseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DioceseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DioceseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DioceseMaxAggregateInputType
  }

  export type GetDioceseAggregateType<T extends DioceseAggregateArgs> = {
        [P in keyof T & keyof AggregateDiocese]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiocese[P]>
      : GetScalarType<T[P], AggregateDiocese[P]>
  }




  export type dioceseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dioceseWhereInput
    orderBy?: dioceseOrderByWithAggregationInput | dioceseOrderByWithAggregationInput[]
    by: DioceseScalarFieldEnum[] | DioceseScalarFieldEnum
    having?: dioceseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DioceseCountAggregateInputType | true
    _avg?: DioceseAvgAggregateInputType
    _sum?: DioceseSumAggregateInputType
    _min?: DioceseMinAggregateInputType
    _max?: DioceseMaxAggregateInputType
  }

  export type DioceseGroupByOutputType = {
    id: number
    tipoDioceseId: number
    descricao: string
    enderecoId: number
    _count: DioceseCountAggregateOutputType | null
    _avg: DioceseAvgAggregateOutputType | null
    _sum: DioceseSumAggregateOutputType | null
    _min: DioceseMinAggregateOutputType | null
    _max: DioceseMaxAggregateOutputType | null
  }

  type GetDioceseGroupByPayload<T extends dioceseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DioceseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DioceseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DioceseGroupByOutputType[P]>
            : GetScalarType<T[P], DioceseGroupByOutputType[P]>
        }
      >
    >


  export type dioceseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoDioceseId?: boolean
    descricao?: boolean
    enderecoId?: boolean
    tipoDiocese?: boolean | tipoDioceseDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    paroquias?: boolean | diocese$paroquiasArgs<ExtArgs>
    localidade?: boolean | diocese$localidadeArgs<ExtArgs>
    _count?: boolean | DioceseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diocese"]>

  export type dioceseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoDioceseId?: boolean
    descricao?: boolean
    enderecoId?: boolean
    tipoDiocese?: boolean | tipoDioceseDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diocese"]>

  export type dioceseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoDioceseId?: boolean
    descricao?: boolean
    enderecoId?: boolean
    tipoDiocese?: boolean | tipoDioceseDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diocese"]>

  export type dioceseSelectScalar = {
    id?: boolean
    tipoDioceseId?: boolean
    descricao?: boolean
    enderecoId?: boolean
  }

  export type dioceseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipoDioceseId" | "descricao" | "enderecoId", ExtArgs["result"]["diocese"]>
  export type dioceseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoDiocese?: boolean | tipoDioceseDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    paroquias?: boolean | diocese$paroquiasArgs<ExtArgs>
    localidade?: boolean | diocese$localidadeArgs<ExtArgs>
    _count?: boolean | DioceseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type dioceseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoDiocese?: boolean | tipoDioceseDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }
  export type dioceseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoDiocese?: boolean | tipoDioceseDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }

  export type $diocesePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "diocese"
    objects: {
      tipoDiocese: Prisma.$tipoDiocesePayload<ExtArgs>
      endereco: Prisma.$enderecoPayload<ExtArgs>
      paroquias: Prisma.$paroquiaPayload<ExtArgs>[]
      localidade: Prisma.$localidadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipoDioceseId: number
      descricao: string
      enderecoId: number
    }, ExtArgs["result"]["diocese"]>
    composites: {}
  }

  type dioceseGetPayload<S extends boolean | null | undefined | dioceseDefaultArgs> = $Result.GetResult<Prisma.$diocesePayload, S>

  type dioceseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<dioceseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DioceseCountAggregateInputType | true
    }

  export interface dioceseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['diocese'], meta: { name: 'diocese' } }
    /**
     * Find zero or one Diocese that matches the filter.
     * @param {dioceseFindUniqueArgs} args - Arguments to find a Diocese
     * @example
     * // Get one Diocese
     * const diocese = await prisma.diocese.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dioceseFindUniqueArgs>(args: SelectSubset<T, dioceseFindUniqueArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Diocese that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {dioceseFindUniqueOrThrowArgs} args - Arguments to find a Diocese
     * @example
     * // Get one Diocese
     * const diocese = await prisma.diocese.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dioceseFindUniqueOrThrowArgs>(args: SelectSubset<T, dioceseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diocese that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dioceseFindFirstArgs} args - Arguments to find a Diocese
     * @example
     * // Get one Diocese
     * const diocese = await prisma.diocese.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dioceseFindFirstArgs>(args?: SelectSubset<T, dioceseFindFirstArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Diocese that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dioceseFindFirstOrThrowArgs} args - Arguments to find a Diocese
     * @example
     * // Get one Diocese
     * const diocese = await prisma.diocese.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dioceseFindFirstOrThrowArgs>(args?: SelectSubset<T, dioceseFindFirstOrThrowArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Diocese that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dioceseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diocese
     * const diocese = await prisma.diocese.findMany()
     * 
     * // Get first 10 Diocese
     * const diocese = await prisma.diocese.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dioceseWithIdOnly = await prisma.diocese.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends dioceseFindManyArgs>(args?: SelectSubset<T, dioceseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Diocese.
     * @param {dioceseCreateArgs} args - Arguments to create a Diocese.
     * @example
     * // Create one Diocese
     * const Diocese = await prisma.diocese.create({
     *   data: {
     *     // ... data to create a Diocese
     *   }
     * })
     * 
     */
    create<T extends dioceseCreateArgs>(args: SelectSubset<T, dioceseCreateArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Diocese.
     * @param {dioceseCreateManyArgs} args - Arguments to create many Diocese.
     * @example
     * // Create many Diocese
     * const diocese = await prisma.diocese.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dioceseCreateManyArgs>(args?: SelectSubset<T, dioceseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diocese and returns the data saved in the database.
     * @param {dioceseCreateManyAndReturnArgs} args - Arguments to create many Diocese.
     * @example
     * // Create many Diocese
     * const diocese = await prisma.diocese.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diocese and only return the `id`
     * const dioceseWithIdOnly = await prisma.diocese.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends dioceseCreateManyAndReturnArgs>(args?: SelectSubset<T, dioceseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Diocese.
     * @param {dioceseDeleteArgs} args - Arguments to delete one Diocese.
     * @example
     * // Delete one Diocese
     * const Diocese = await prisma.diocese.delete({
     *   where: {
     *     // ... filter to delete one Diocese
     *   }
     * })
     * 
     */
    delete<T extends dioceseDeleteArgs>(args: SelectSubset<T, dioceseDeleteArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Diocese.
     * @param {dioceseUpdateArgs} args - Arguments to update one Diocese.
     * @example
     * // Update one Diocese
     * const diocese = await prisma.diocese.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dioceseUpdateArgs>(args: SelectSubset<T, dioceseUpdateArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Diocese.
     * @param {dioceseDeleteManyArgs} args - Arguments to filter Diocese to delete.
     * @example
     * // Delete a few Diocese
     * const { count } = await prisma.diocese.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dioceseDeleteManyArgs>(args?: SelectSubset<T, dioceseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diocese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dioceseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diocese
     * const diocese = await prisma.diocese.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dioceseUpdateManyArgs>(args: SelectSubset<T, dioceseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diocese and returns the data updated in the database.
     * @param {dioceseUpdateManyAndReturnArgs} args - Arguments to update many Diocese.
     * @example
     * // Update many Diocese
     * const diocese = await prisma.diocese.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Diocese and only return the `id`
     * const dioceseWithIdOnly = await prisma.diocese.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends dioceseUpdateManyAndReturnArgs>(args: SelectSubset<T, dioceseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Diocese.
     * @param {dioceseUpsertArgs} args - Arguments to update or create a Diocese.
     * @example
     * // Update or create a Diocese
     * const diocese = await prisma.diocese.upsert({
     *   create: {
     *     // ... data to create a Diocese
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diocese we want to update
     *   }
     * })
     */
    upsert<T extends dioceseUpsertArgs>(args: SelectSubset<T, dioceseUpsertArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Diocese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dioceseCountArgs} args - Arguments to filter Diocese to count.
     * @example
     * // Count the number of Diocese
     * const count = await prisma.diocese.count({
     *   where: {
     *     // ... the filter for the Diocese we want to count
     *   }
     * })
    **/
    count<T extends dioceseCountArgs>(
      args?: Subset<T, dioceseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DioceseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diocese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DioceseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DioceseAggregateArgs>(args: Subset<T, DioceseAggregateArgs>): Prisma.PrismaPromise<GetDioceseAggregateType<T>>

    /**
     * Group by Diocese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dioceseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dioceseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dioceseGroupByArgs['orderBy'] }
        : { orderBy?: dioceseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dioceseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDioceseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the diocese model
   */
  readonly fields: dioceseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for diocese.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dioceseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tipoDiocese<T extends tipoDioceseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipoDioceseDefaultArgs<ExtArgs>>): Prisma__tipoDioceseClient<$Result.GetResult<Prisma.$tipoDiocesePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    endereco<T extends enderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, enderecoDefaultArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paroquias<T extends diocese$paroquiasArgs<ExtArgs> = {}>(args?: Subset<T, diocese$paroquiasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    localidade<T extends diocese$localidadeArgs<ExtArgs> = {}>(args?: Subset<T, diocese$localidadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the diocese model
   */
  interface dioceseFieldRefs {
    readonly id: FieldRef<"diocese", 'Int'>
    readonly tipoDioceseId: FieldRef<"diocese", 'Int'>
    readonly descricao: FieldRef<"diocese", 'String'>
    readonly enderecoId: FieldRef<"diocese", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * diocese findUnique
   */
  export type dioceseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    /**
     * Filter, which diocese to fetch.
     */
    where: dioceseWhereUniqueInput
  }

  /**
   * diocese findUniqueOrThrow
   */
  export type dioceseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    /**
     * Filter, which diocese to fetch.
     */
    where: dioceseWhereUniqueInput
  }

  /**
   * diocese findFirst
   */
  export type dioceseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    /**
     * Filter, which diocese to fetch.
     */
    where?: dioceseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diocese to fetch.
     */
    orderBy?: dioceseOrderByWithRelationInput | dioceseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diocese.
     */
    cursor?: dioceseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diocese from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diocese.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diocese.
     */
    distinct?: DioceseScalarFieldEnum | DioceseScalarFieldEnum[]
  }

  /**
   * diocese findFirstOrThrow
   */
  export type dioceseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    /**
     * Filter, which diocese to fetch.
     */
    where?: dioceseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diocese to fetch.
     */
    orderBy?: dioceseOrderByWithRelationInput | dioceseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for diocese.
     */
    cursor?: dioceseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diocese from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diocese.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of diocese.
     */
    distinct?: DioceseScalarFieldEnum | DioceseScalarFieldEnum[]
  }

  /**
   * diocese findMany
   */
  export type dioceseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    /**
     * Filter, which diocese to fetch.
     */
    where?: dioceseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of diocese to fetch.
     */
    orderBy?: dioceseOrderByWithRelationInput | dioceseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing diocese.
     */
    cursor?: dioceseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` diocese from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` diocese.
     */
    skip?: number
    distinct?: DioceseScalarFieldEnum | DioceseScalarFieldEnum[]
  }

  /**
   * diocese create
   */
  export type dioceseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    /**
     * The data needed to create a diocese.
     */
    data: XOR<dioceseCreateInput, dioceseUncheckedCreateInput>
  }

  /**
   * diocese createMany
   */
  export type dioceseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many diocese.
     */
    data: dioceseCreateManyInput | dioceseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * diocese createManyAndReturn
   */
  export type dioceseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * The data used to create many diocese.
     */
    data: dioceseCreateManyInput | dioceseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * diocese update
   */
  export type dioceseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    /**
     * The data needed to update a diocese.
     */
    data: XOR<dioceseUpdateInput, dioceseUncheckedUpdateInput>
    /**
     * Choose, which diocese to update.
     */
    where: dioceseWhereUniqueInput
  }

  /**
   * diocese updateMany
   */
  export type dioceseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update diocese.
     */
    data: XOR<dioceseUpdateManyMutationInput, dioceseUncheckedUpdateManyInput>
    /**
     * Filter which diocese to update
     */
    where?: dioceseWhereInput
    /**
     * Limit how many diocese to update.
     */
    limit?: number
  }

  /**
   * diocese updateManyAndReturn
   */
  export type dioceseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * The data used to update diocese.
     */
    data: XOR<dioceseUpdateManyMutationInput, dioceseUncheckedUpdateManyInput>
    /**
     * Filter which diocese to update
     */
    where?: dioceseWhereInput
    /**
     * Limit how many diocese to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * diocese upsert
   */
  export type dioceseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    /**
     * The filter to search for the diocese to update in case it exists.
     */
    where: dioceseWhereUniqueInput
    /**
     * In case the diocese found by the `where` argument doesn't exist, create a new diocese with this data.
     */
    create: XOR<dioceseCreateInput, dioceseUncheckedCreateInput>
    /**
     * In case the diocese was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dioceseUpdateInput, dioceseUncheckedUpdateInput>
  }

  /**
   * diocese delete
   */
  export type dioceseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
    /**
     * Filter which diocese to delete.
     */
    where: dioceseWhereUniqueInput
  }

  /**
   * diocese deleteMany
   */
  export type dioceseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which diocese to delete
     */
    where?: dioceseWhereInput
    /**
     * Limit how many diocese to delete.
     */
    limit?: number
  }

  /**
   * diocese.paroquias
   */
  export type diocese$paroquiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    where?: paroquiaWhereInput
    orderBy?: paroquiaOrderByWithRelationInput | paroquiaOrderByWithRelationInput[]
    cursor?: paroquiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParoquiaScalarFieldEnum | ParoquiaScalarFieldEnum[]
  }

  /**
   * diocese.localidade
   */
  export type diocese$localidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    where?: localidadeWhereInput
    orderBy?: localidadeOrderByWithRelationInput | localidadeOrderByWithRelationInput[]
    cursor?: localidadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalidadeScalarFieldEnum | LocalidadeScalarFieldEnum[]
  }

  /**
   * diocese without action
   */
  export type dioceseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the diocese
     */
    select?: dioceseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the diocese
     */
    omit?: dioceseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dioceseInclude<ExtArgs> | null
  }


  /**
   * Model paroquia
   */

  export type AggregateParoquia = {
    _count: ParoquiaCountAggregateOutputType | null
    _avg: ParoquiaAvgAggregateOutputType | null
    _sum: ParoquiaSumAggregateOutputType | null
    _min: ParoquiaMinAggregateOutputType | null
    _max: ParoquiaMaxAggregateOutputType | null
  }

  export type ParoquiaAvgAggregateOutputType = {
    id: number | null
    enderecoId: number | null
    dioceseId: number | null
  }

  export type ParoquiaSumAggregateOutputType = {
    id: number | null
    enderecoId: number | null
    dioceseId: number | null
  }

  export type ParoquiaMinAggregateOutputType = {
    id: number | null
    enderecoId: number | null
    dioceseId: number | null
    descricao: string | null
  }

  export type ParoquiaMaxAggregateOutputType = {
    id: number | null
    enderecoId: number | null
    dioceseId: number | null
    descricao: string | null
  }

  export type ParoquiaCountAggregateOutputType = {
    id: number
    enderecoId: number
    dioceseId: number
    descricao: number
    _all: number
  }


  export type ParoquiaAvgAggregateInputType = {
    id?: true
    enderecoId?: true
    dioceseId?: true
  }

  export type ParoquiaSumAggregateInputType = {
    id?: true
    enderecoId?: true
    dioceseId?: true
  }

  export type ParoquiaMinAggregateInputType = {
    id?: true
    enderecoId?: true
    dioceseId?: true
    descricao?: true
  }

  export type ParoquiaMaxAggregateInputType = {
    id?: true
    enderecoId?: true
    dioceseId?: true
    descricao?: true
  }

  export type ParoquiaCountAggregateInputType = {
    id?: true
    enderecoId?: true
    dioceseId?: true
    descricao?: true
    _all?: true
  }

  export type ParoquiaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paroquia to aggregate.
     */
    where?: paroquiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paroquias to fetch.
     */
    orderBy?: paroquiaOrderByWithRelationInput | paroquiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paroquiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paroquias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paroquias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paroquias
    **/
    _count?: true | ParoquiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParoquiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParoquiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParoquiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParoquiaMaxAggregateInputType
  }

  export type GetParoquiaAggregateType<T extends ParoquiaAggregateArgs> = {
        [P in keyof T & keyof AggregateParoquia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParoquia[P]>
      : GetScalarType<T[P], AggregateParoquia[P]>
  }




  export type paroquiaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paroquiaWhereInput
    orderBy?: paroquiaOrderByWithAggregationInput | paroquiaOrderByWithAggregationInput[]
    by: ParoquiaScalarFieldEnum[] | ParoquiaScalarFieldEnum
    having?: paroquiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParoquiaCountAggregateInputType | true
    _avg?: ParoquiaAvgAggregateInputType
    _sum?: ParoquiaSumAggregateInputType
    _min?: ParoquiaMinAggregateInputType
    _max?: ParoquiaMaxAggregateInputType
  }

  export type ParoquiaGroupByOutputType = {
    id: number
    enderecoId: number
    dioceseId: number
    descricao: string
    _count: ParoquiaCountAggregateOutputType | null
    _avg: ParoquiaAvgAggregateOutputType | null
    _sum: ParoquiaSumAggregateOutputType | null
    _min: ParoquiaMinAggregateOutputType | null
    _max: ParoquiaMaxAggregateOutputType | null
  }

  type GetParoquiaGroupByPayload<T extends paroquiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParoquiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParoquiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParoquiaGroupByOutputType[P]>
            : GetScalarType<T[P], ParoquiaGroupByOutputType[P]>
        }
      >
    >


  export type paroquiaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enderecoId?: boolean
    dioceseId?: boolean
    descricao?: boolean
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
    pessoas?: boolean | paroquia$pessoasArgs<ExtArgs>
    _count?: boolean | ParoquiaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paroquia"]>

  export type paroquiaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enderecoId?: boolean
    dioceseId?: boolean
    descricao?: boolean
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paroquia"]>

  export type paroquiaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enderecoId?: boolean
    dioceseId?: boolean
    descricao?: boolean
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paroquia"]>

  export type paroquiaSelectScalar = {
    id?: boolean
    enderecoId?: boolean
    dioceseId?: boolean
    descricao?: boolean
  }

  export type paroquiaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enderecoId" | "dioceseId" | "descricao", ExtArgs["result"]["paroquia"]>
  export type paroquiaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
    pessoas?: boolean | paroquia$pessoasArgs<ExtArgs>
    _count?: boolean | ParoquiaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type paroquiaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
  }
  export type paroquiaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
  }

  export type $paroquiaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paroquia"
    objects: {
      endereco: Prisma.$enderecoPayload<ExtArgs>
      diocese: Prisma.$diocesePayload<ExtArgs>
      pessoas: Prisma.$paroquiaPessoasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enderecoId: number
      dioceseId: number
      descricao: string
    }, ExtArgs["result"]["paroquia"]>
    composites: {}
  }

  type paroquiaGetPayload<S extends boolean | null | undefined | paroquiaDefaultArgs> = $Result.GetResult<Prisma.$paroquiaPayload, S>

  type paroquiaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paroquiaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParoquiaCountAggregateInputType | true
    }

  export interface paroquiaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paroquia'], meta: { name: 'paroquia' } }
    /**
     * Find zero or one Paroquia that matches the filter.
     * @param {paroquiaFindUniqueArgs} args - Arguments to find a Paroquia
     * @example
     * // Get one Paroquia
     * const paroquia = await prisma.paroquia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paroquiaFindUniqueArgs>(args: SelectSubset<T, paroquiaFindUniqueArgs<ExtArgs>>): Prisma__paroquiaClient<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Paroquia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paroquiaFindUniqueOrThrowArgs} args - Arguments to find a Paroquia
     * @example
     * // Get one Paroquia
     * const paroquia = await prisma.paroquia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paroquiaFindUniqueOrThrowArgs>(args: SelectSubset<T, paroquiaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paroquiaClient<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paroquia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaFindFirstArgs} args - Arguments to find a Paroquia
     * @example
     * // Get one Paroquia
     * const paroquia = await prisma.paroquia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paroquiaFindFirstArgs>(args?: SelectSubset<T, paroquiaFindFirstArgs<ExtArgs>>): Prisma__paroquiaClient<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Paroquia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaFindFirstOrThrowArgs} args - Arguments to find a Paroquia
     * @example
     * // Get one Paroquia
     * const paroquia = await prisma.paroquia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paroquiaFindFirstOrThrowArgs>(args?: SelectSubset<T, paroquiaFindFirstOrThrowArgs<ExtArgs>>): Prisma__paroquiaClient<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Paroquias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Paroquias
     * const paroquias = await prisma.paroquia.findMany()
     * 
     * // Get first 10 Paroquias
     * const paroquias = await prisma.paroquia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paroquiaWithIdOnly = await prisma.paroquia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paroquiaFindManyArgs>(args?: SelectSubset<T, paroquiaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Paroquia.
     * @param {paroquiaCreateArgs} args - Arguments to create a Paroquia.
     * @example
     * // Create one Paroquia
     * const Paroquia = await prisma.paroquia.create({
     *   data: {
     *     // ... data to create a Paroquia
     *   }
     * })
     * 
     */
    create<T extends paroquiaCreateArgs>(args: SelectSubset<T, paroquiaCreateArgs<ExtArgs>>): Prisma__paroquiaClient<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Paroquias.
     * @param {paroquiaCreateManyArgs} args - Arguments to create many Paroquias.
     * @example
     * // Create many Paroquias
     * const paroquia = await prisma.paroquia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paroquiaCreateManyArgs>(args?: SelectSubset<T, paroquiaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Paroquias and returns the data saved in the database.
     * @param {paroquiaCreateManyAndReturnArgs} args - Arguments to create many Paroquias.
     * @example
     * // Create many Paroquias
     * const paroquia = await prisma.paroquia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Paroquias and only return the `id`
     * const paroquiaWithIdOnly = await prisma.paroquia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paroquiaCreateManyAndReturnArgs>(args?: SelectSubset<T, paroquiaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Paroquia.
     * @param {paroquiaDeleteArgs} args - Arguments to delete one Paroquia.
     * @example
     * // Delete one Paroquia
     * const Paroquia = await prisma.paroquia.delete({
     *   where: {
     *     // ... filter to delete one Paroquia
     *   }
     * })
     * 
     */
    delete<T extends paroquiaDeleteArgs>(args: SelectSubset<T, paroquiaDeleteArgs<ExtArgs>>): Prisma__paroquiaClient<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Paroquia.
     * @param {paroquiaUpdateArgs} args - Arguments to update one Paroquia.
     * @example
     * // Update one Paroquia
     * const paroquia = await prisma.paroquia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paroquiaUpdateArgs>(args: SelectSubset<T, paroquiaUpdateArgs<ExtArgs>>): Prisma__paroquiaClient<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Paroquias.
     * @param {paroquiaDeleteManyArgs} args - Arguments to filter Paroquias to delete.
     * @example
     * // Delete a few Paroquias
     * const { count } = await prisma.paroquia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paroquiaDeleteManyArgs>(args?: SelectSubset<T, paroquiaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paroquias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Paroquias
     * const paroquia = await prisma.paroquia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paroquiaUpdateManyArgs>(args: SelectSubset<T, paroquiaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Paroquias and returns the data updated in the database.
     * @param {paroquiaUpdateManyAndReturnArgs} args - Arguments to update many Paroquias.
     * @example
     * // Update many Paroquias
     * const paroquia = await prisma.paroquia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Paroquias and only return the `id`
     * const paroquiaWithIdOnly = await prisma.paroquia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paroquiaUpdateManyAndReturnArgs>(args: SelectSubset<T, paroquiaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Paroquia.
     * @param {paroquiaUpsertArgs} args - Arguments to update or create a Paroquia.
     * @example
     * // Update or create a Paroquia
     * const paroquia = await prisma.paroquia.upsert({
     *   create: {
     *     // ... data to create a Paroquia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Paroquia we want to update
     *   }
     * })
     */
    upsert<T extends paroquiaUpsertArgs>(args: SelectSubset<T, paroquiaUpsertArgs<ExtArgs>>): Prisma__paroquiaClient<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Paroquias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaCountArgs} args - Arguments to filter Paroquias to count.
     * @example
     * // Count the number of Paroquias
     * const count = await prisma.paroquia.count({
     *   where: {
     *     // ... the filter for the Paroquias we want to count
     *   }
     * })
    **/
    count<T extends paroquiaCountArgs>(
      args?: Subset<T, paroquiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParoquiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Paroquia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParoquiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParoquiaAggregateArgs>(args: Subset<T, ParoquiaAggregateArgs>): Prisma.PrismaPromise<GetParoquiaAggregateType<T>>

    /**
     * Group by Paroquia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paroquiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paroquiaGroupByArgs['orderBy'] }
        : { orderBy?: paroquiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paroquiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParoquiaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paroquia model
   */
  readonly fields: paroquiaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paroquia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paroquiaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endereco<T extends enderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, enderecoDefaultArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    diocese<T extends dioceseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, dioceseDefaultArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pessoas<T extends paroquia$pessoasArgs<ExtArgs> = {}>(args?: Subset<T, paroquia$pessoasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paroquia model
   */
  interface paroquiaFieldRefs {
    readonly id: FieldRef<"paroquia", 'Int'>
    readonly enderecoId: FieldRef<"paroquia", 'Int'>
    readonly dioceseId: FieldRef<"paroquia", 'Int'>
    readonly descricao: FieldRef<"paroquia", 'String'>
  }
    

  // Custom InputTypes
  /**
   * paroquia findUnique
   */
  export type paroquiaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    /**
     * Filter, which paroquia to fetch.
     */
    where: paroquiaWhereUniqueInput
  }

  /**
   * paroquia findUniqueOrThrow
   */
  export type paroquiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    /**
     * Filter, which paroquia to fetch.
     */
    where: paroquiaWhereUniqueInput
  }

  /**
   * paroquia findFirst
   */
  export type paroquiaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    /**
     * Filter, which paroquia to fetch.
     */
    where?: paroquiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paroquias to fetch.
     */
    orderBy?: paroquiaOrderByWithRelationInput | paroquiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paroquias.
     */
    cursor?: paroquiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paroquias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paroquias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paroquias.
     */
    distinct?: ParoquiaScalarFieldEnum | ParoquiaScalarFieldEnum[]
  }

  /**
   * paroquia findFirstOrThrow
   */
  export type paroquiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    /**
     * Filter, which paroquia to fetch.
     */
    where?: paroquiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paroquias to fetch.
     */
    orderBy?: paroquiaOrderByWithRelationInput | paroquiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paroquias.
     */
    cursor?: paroquiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paroquias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paroquias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paroquias.
     */
    distinct?: ParoquiaScalarFieldEnum | ParoquiaScalarFieldEnum[]
  }

  /**
   * paroquia findMany
   */
  export type paroquiaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    /**
     * Filter, which paroquias to fetch.
     */
    where?: paroquiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paroquias to fetch.
     */
    orderBy?: paroquiaOrderByWithRelationInput | paroquiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paroquias.
     */
    cursor?: paroquiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paroquias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paroquias.
     */
    skip?: number
    distinct?: ParoquiaScalarFieldEnum | ParoquiaScalarFieldEnum[]
  }

  /**
   * paroquia create
   */
  export type paroquiaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    /**
     * The data needed to create a paroquia.
     */
    data: XOR<paroquiaCreateInput, paroquiaUncheckedCreateInput>
  }

  /**
   * paroquia createMany
   */
  export type paroquiaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paroquias.
     */
    data: paroquiaCreateManyInput | paroquiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paroquia createManyAndReturn
   */
  export type paroquiaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * The data used to create many paroquias.
     */
    data: paroquiaCreateManyInput | paroquiaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * paroquia update
   */
  export type paroquiaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    /**
     * The data needed to update a paroquia.
     */
    data: XOR<paroquiaUpdateInput, paroquiaUncheckedUpdateInput>
    /**
     * Choose, which paroquia to update.
     */
    where: paroquiaWhereUniqueInput
  }

  /**
   * paroquia updateMany
   */
  export type paroquiaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paroquias.
     */
    data: XOR<paroquiaUpdateManyMutationInput, paroquiaUncheckedUpdateManyInput>
    /**
     * Filter which paroquias to update
     */
    where?: paroquiaWhereInput
    /**
     * Limit how many paroquias to update.
     */
    limit?: number
  }

  /**
   * paroquia updateManyAndReturn
   */
  export type paroquiaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * The data used to update paroquias.
     */
    data: XOR<paroquiaUpdateManyMutationInput, paroquiaUncheckedUpdateManyInput>
    /**
     * Filter which paroquias to update
     */
    where?: paroquiaWhereInput
    /**
     * Limit how many paroquias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * paroquia upsert
   */
  export type paroquiaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    /**
     * The filter to search for the paroquia to update in case it exists.
     */
    where: paroquiaWhereUniqueInput
    /**
     * In case the paroquia found by the `where` argument doesn't exist, create a new paroquia with this data.
     */
    create: XOR<paroquiaCreateInput, paroquiaUncheckedCreateInput>
    /**
     * In case the paroquia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paroquiaUpdateInput, paroquiaUncheckedUpdateInput>
  }

  /**
   * paroquia delete
   */
  export type paroquiaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
    /**
     * Filter which paroquia to delete.
     */
    where: paroquiaWhereUniqueInput
  }

  /**
   * paroquia deleteMany
   */
  export type paroquiaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paroquias to delete
     */
    where?: paroquiaWhereInput
    /**
     * Limit how many paroquias to delete.
     */
    limit?: number
  }

  /**
   * paroquia.pessoas
   */
  export type paroquia$pessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    where?: paroquiaPessoasWhereInput
    orderBy?: paroquiaPessoasOrderByWithRelationInput | paroquiaPessoasOrderByWithRelationInput[]
    cursor?: paroquiaPessoasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParoquiaPessoasScalarFieldEnum | ParoquiaPessoasScalarFieldEnum[]
  }

  /**
   * paroquia without action
   */
  export type paroquiaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquia
     */
    select?: paroquiaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquia
     */
    omit?: paroquiaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaInclude<ExtArgs> | null
  }


  /**
   * Model paroquiaPessoas
   */

  export type AggregateParoquiaPessoas = {
    _count: ParoquiaPessoasCountAggregateOutputType | null
    _avg: ParoquiaPessoasAvgAggregateOutputType | null
    _sum: ParoquiaPessoasSumAggregateOutputType | null
    _min: ParoquiaPessoasMinAggregateOutputType | null
    _max: ParoquiaPessoasMaxAggregateOutputType | null
  }

  export type ParoquiaPessoasAvgAggregateOutputType = {
    pessoaId: number | null
    paroquiaId: number | null
  }

  export type ParoquiaPessoasSumAggregateOutputType = {
    pessoaId: number | null
    paroquiaId: number | null
  }

  export type ParoquiaPessoasMinAggregateOutputType = {
    pessoaId: number | null
    paroquiaId: number | null
  }

  export type ParoquiaPessoasMaxAggregateOutputType = {
    pessoaId: number | null
    paroquiaId: number | null
  }

  export type ParoquiaPessoasCountAggregateOutputType = {
    pessoaId: number
    paroquiaId: number
    _all: number
  }


  export type ParoquiaPessoasAvgAggregateInputType = {
    pessoaId?: true
    paroquiaId?: true
  }

  export type ParoquiaPessoasSumAggregateInputType = {
    pessoaId?: true
    paroquiaId?: true
  }

  export type ParoquiaPessoasMinAggregateInputType = {
    pessoaId?: true
    paroquiaId?: true
  }

  export type ParoquiaPessoasMaxAggregateInputType = {
    pessoaId?: true
    paroquiaId?: true
  }

  export type ParoquiaPessoasCountAggregateInputType = {
    pessoaId?: true
    paroquiaId?: true
    _all?: true
  }

  export type ParoquiaPessoasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paroquiaPessoas to aggregate.
     */
    where?: paroquiaPessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paroquiaPessoas to fetch.
     */
    orderBy?: paroquiaPessoasOrderByWithRelationInput | paroquiaPessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paroquiaPessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paroquiaPessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paroquiaPessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned paroquiaPessoas
    **/
    _count?: true | ParoquiaPessoasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParoquiaPessoasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParoquiaPessoasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParoquiaPessoasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParoquiaPessoasMaxAggregateInputType
  }

  export type GetParoquiaPessoasAggregateType<T extends ParoquiaPessoasAggregateArgs> = {
        [P in keyof T & keyof AggregateParoquiaPessoas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParoquiaPessoas[P]>
      : GetScalarType<T[P], AggregateParoquiaPessoas[P]>
  }




  export type paroquiaPessoasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paroquiaPessoasWhereInput
    orderBy?: paroquiaPessoasOrderByWithAggregationInput | paroquiaPessoasOrderByWithAggregationInput[]
    by: ParoquiaPessoasScalarFieldEnum[] | ParoquiaPessoasScalarFieldEnum
    having?: paroquiaPessoasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParoquiaPessoasCountAggregateInputType | true
    _avg?: ParoquiaPessoasAvgAggregateInputType
    _sum?: ParoquiaPessoasSumAggregateInputType
    _min?: ParoquiaPessoasMinAggregateInputType
    _max?: ParoquiaPessoasMaxAggregateInputType
  }

  export type ParoquiaPessoasGroupByOutputType = {
    pessoaId: number
    paroquiaId: number
    _count: ParoquiaPessoasCountAggregateOutputType | null
    _avg: ParoquiaPessoasAvgAggregateOutputType | null
    _sum: ParoquiaPessoasSumAggregateOutputType | null
    _min: ParoquiaPessoasMinAggregateOutputType | null
    _max: ParoquiaPessoasMaxAggregateOutputType | null
  }

  type GetParoquiaPessoasGroupByPayload<T extends paroquiaPessoasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParoquiaPessoasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParoquiaPessoasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParoquiaPessoasGroupByOutputType[P]>
            : GetScalarType<T[P], ParoquiaPessoasGroupByOutputType[P]>
        }
      >
    >


  export type paroquiaPessoasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pessoaId?: boolean
    paroquiaId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    paroquia?: boolean | paroquiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paroquiaPessoas"]>

  export type paroquiaPessoasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pessoaId?: boolean
    paroquiaId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    paroquia?: boolean | paroquiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paroquiaPessoas"]>

  export type paroquiaPessoasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    pessoaId?: boolean
    paroquiaId?: boolean
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    paroquia?: boolean | paroquiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paroquiaPessoas"]>

  export type paroquiaPessoasSelectScalar = {
    pessoaId?: boolean
    paroquiaId?: boolean
  }

  export type paroquiaPessoasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"pessoaId" | "paroquiaId", ExtArgs["result"]["paroquiaPessoas"]>
  export type paroquiaPessoasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    paroquia?: boolean | paroquiaDefaultArgs<ExtArgs>
  }
  export type paroquiaPessoasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    paroquia?: boolean | paroquiaDefaultArgs<ExtArgs>
  }
  export type paroquiaPessoasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
    paroquia?: boolean | paroquiaDefaultArgs<ExtArgs>
  }

  export type $paroquiaPessoasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "paroquiaPessoas"
    objects: {
      pessoa: Prisma.$pessoaPayload<ExtArgs>
      paroquia: Prisma.$paroquiaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      pessoaId: number
      paroquiaId: number
    }, ExtArgs["result"]["paroquiaPessoas"]>
    composites: {}
  }

  type paroquiaPessoasGetPayload<S extends boolean | null | undefined | paroquiaPessoasDefaultArgs> = $Result.GetResult<Prisma.$paroquiaPessoasPayload, S>

  type paroquiaPessoasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paroquiaPessoasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParoquiaPessoasCountAggregateInputType | true
    }

  export interface paroquiaPessoasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['paroquiaPessoas'], meta: { name: 'paroquiaPessoas' } }
    /**
     * Find zero or one ParoquiaPessoas that matches the filter.
     * @param {paroquiaPessoasFindUniqueArgs} args - Arguments to find a ParoquiaPessoas
     * @example
     * // Get one ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paroquiaPessoasFindUniqueArgs>(args: SelectSubset<T, paroquiaPessoasFindUniqueArgs<ExtArgs>>): Prisma__paroquiaPessoasClient<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParoquiaPessoas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paroquiaPessoasFindUniqueOrThrowArgs} args - Arguments to find a ParoquiaPessoas
     * @example
     * // Get one ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paroquiaPessoasFindUniqueOrThrowArgs>(args: SelectSubset<T, paroquiaPessoasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paroquiaPessoasClient<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParoquiaPessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaPessoasFindFirstArgs} args - Arguments to find a ParoquiaPessoas
     * @example
     * // Get one ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paroquiaPessoasFindFirstArgs>(args?: SelectSubset<T, paroquiaPessoasFindFirstArgs<ExtArgs>>): Prisma__paroquiaPessoasClient<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParoquiaPessoas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaPessoasFindFirstOrThrowArgs} args - Arguments to find a ParoquiaPessoas
     * @example
     * // Get one ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paroquiaPessoasFindFirstOrThrowArgs>(args?: SelectSubset<T, paroquiaPessoasFindFirstOrThrowArgs<ExtArgs>>): Prisma__paroquiaPessoasClient<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParoquiaPessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaPessoasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.findMany()
     * 
     * // Get first 10 ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.findMany({ take: 10 })
     * 
     * // Only select the `pessoaId`
     * const paroquiaPessoasWithPessoaIdOnly = await prisma.paroquiaPessoas.findMany({ select: { pessoaId: true } })
     * 
     */
    findMany<T extends paroquiaPessoasFindManyArgs>(args?: SelectSubset<T, paroquiaPessoasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParoquiaPessoas.
     * @param {paroquiaPessoasCreateArgs} args - Arguments to create a ParoquiaPessoas.
     * @example
     * // Create one ParoquiaPessoas
     * const ParoquiaPessoas = await prisma.paroquiaPessoas.create({
     *   data: {
     *     // ... data to create a ParoquiaPessoas
     *   }
     * })
     * 
     */
    create<T extends paroquiaPessoasCreateArgs>(args: SelectSubset<T, paroquiaPessoasCreateArgs<ExtArgs>>): Prisma__paroquiaPessoasClient<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParoquiaPessoas.
     * @param {paroquiaPessoasCreateManyArgs} args - Arguments to create many ParoquiaPessoas.
     * @example
     * // Create many ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paroquiaPessoasCreateManyArgs>(args?: SelectSubset<T, paroquiaPessoasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParoquiaPessoas and returns the data saved in the database.
     * @param {paroquiaPessoasCreateManyAndReturnArgs} args - Arguments to create many ParoquiaPessoas.
     * @example
     * // Create many ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParoquiaPessoas and only return the `pessoaId`
     * const paroquiaPessoasWithPessoaIdOnly = await prisma.paroquiaPessoas.createManyAndReturn({
     *   select: { pessoaId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paroquiaPessoasCreateManyAndReturnArgs>(args?: SelectSubset<T, paroquiaPessoasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParoquiaPessoas.
     * @param {paroquiaPessoasDeleteArgs} args - Arguments to delete one ParoquiaPessoas.
     * @example
     * // Delete one ParoquiaPessoas
     * const ParoquiaPessoas = await prisma.paroquiaPessoas.delete({
     *   where: {
     *     // ... filter to delete one ParoquiaPessoas
     *   }
     * })
     * 
     */
    delete<T extends paroquiaPessoasDeleteArgs>(args: SelectSubset<T, paroquiaPessoasDeleteArgs<ExtArgs>>): Prisma__paroquiaPessoasClient<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParoquiaPessoas.
     * @param {paroquiaPessoasUpdateArgs} args - Arguments to update one ParoquiaPessoas.
     * @example
     * // Update one ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paroquiaPessoasUpdateArgs>(args: SelectSubset<T, paroquiaPessoasUpdateArgs<ExtArgs>>): Prisma__paroquiaPessoasClient<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParoquiaPessoas.
     * @param {paroquiaPessoasDeleteManyArgs} args - Arguments to filter ParoquiaPessoas to delete.
     * @example
     * // Delete a few ParoquiaPessoas
     * const { count } = await prisma.paroquiaPessoas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paroquiaPessoasDeleteManyArgs>(args?: SelectSubset<T, paroquiaPessoasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParoquiaPessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaPessoasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paroquiaPessoasUpdateManyArgs>(args: SelectSubset<T, paroquiaPessoasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParoquiaPessoas and returns the data updated in the database.
     * @param {paroquiaPessoasUpdateManyAndReturnArgs} args - Arguments to update many ParoquiaPessoas.
     * @example
     * // Update many ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParoquiaPessoas and only return the `pessoaId`
     * const paroquiaPessoasWithPessoaIdOnly = await prisma.paroquiaPessoas.updateManyAndReturn({
     *   select: { pessoaId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paroquiaPessoasUpdateManyAndReturnArgs>(args: SelectSubset<T, paroquiaPessoasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParoquiaPessoas.
     * @param {paroquiaPessoasUpsertArgs} args - Arguments to update or create a ParoquiaPessoas.
     * @example
     * // Update or create a ParoquiaPessoas
     * const paroquiaPessoas = await prisma.paroquiaPessoas.upsert({
     *   create: {
     *     // ... data to create a ParoquiaPessoas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParoquiaPessoas we want to update
     *   }
     * })
     */
    upsert<T extends paroquiaPessoasUpsertArgs>(args: SelectSubset<T, paroquiaPessoasUpsertArgs<ExtArgs>>): Prisma__paroquiaPessoasClient<$Result.GetResult<Prisma.$paroquiaPessoasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParoquiaPessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaPessoasCountArgs} args - Arguments to filter ParoquiaPessoas to count.
     * @example
     * // Count the number of ParoquiaPessoas
     * const count = await prisma.paroquiaPessoas.count({
     *   where: {
     *     // ... the filter for the ParoquiaPessoas we want to count
     *   }
     * })
    **/
    count<T extends paroquiaPessoasCountArgs>(
      args?: Subset<T, paroquiaPessoasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParoquiaPessoasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParoquiaPessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParoquiaPessoasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParoquiaPessoasAggregateArgs>(args: Subset<T, ParoquiaPessoasAggregateArgs>): Prisma.PrismaPromise<GetParoquiaPessoasAggregateType<T>>

    /**
     * Group by ParoquiaPessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paroquiaPessoasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paroquiaPessoasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paroquiaPessoasGroupByArgs['orderBy'] }
        : { orderBy?: paroquiaPessoasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paroquiaPessoasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParoquiaPessoasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the paroquiaPessoas model
   */
  readonly fields: paroquiaPessoasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for paroquiaPessoas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paroquiaPessoasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    paroquia<T extends paroquiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paroquiaDefaultArgs<ExtArgs>>): Prisma__paroquiaClient<$Result.GetResult<Prisma.$paroquiaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the paroquiaPessoas model
   */
  interface paroquiaPessoasFieldRefs {
    readonly pessoaId: FieldRef<"paroquiaPessoas", 'Int'>
    readonly paroquiaId: FieldRef<"paroquiaPessoas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * paroquiaPessoas findUnique
   */
  export type paroquiaPessoasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    /**
     * Filter, which paroquiaPessoas to fetch.
     */
    where: paroquiaPessoasWhereUniqueInput
  }

  /**
   * paroquiaPessoas findUniqueOrThrow
   */
  export type paroquiaPessoasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    /**
     * Filter, which paroquiaPessoas to fetch.
     */
    where: paroquiaPessoasWhereUniqueInput
  }

  /**
   * paroquiaPessoas findFirst
   */
  export type paroquiaPessoasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    /**
     * Filter, which paroquiaPessoas to fetch.
     */
    where?: paroquiaPessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paroquiaPessoas to fetch.
     */
    orderBy?: paroquiaPessoasOrderByWithRelationInput | paroquiaPessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paroquiaPessoas.
     */
    cursor?: paroquiaPessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paroquiaPessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paroquiaPessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paroquiaPessoas.
     */
    distinct?: ParoquiaPessoasScalarFieldEnum | ParoquiaPessoasScalarFieldEnum[]
  }

  /**
   * paroquiaPessoas findFirstOrThrow
   */
  export type paroquiaPessoasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    /**
     * Filter, which paroquiaPessoas to fetch.
     */
    where?: paroquiaPessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paroquiaPessoas to fetch.
     */
    orderBy?: paroquiaPessoasOrderByWithRelationInput | paroquiaPessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for paroquiaPessoas.
     */
    cursor?: paroquiaPessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paroquiaPessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paroquiaPessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of paroquiaPessoas.
     */
    distinct?: ParoquiaPessoasScalarFieldEnum | ParoquiaPessoasScalarFieldEnum[]
  }

  /**
   * paroquiaPessoas findMany
   */
  export type paroquiaPessoasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    /**
     * Filter, which paroquiaPessoas to fetch.
     */
    where?: paroquiaPessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of paroquiaPessoas to fetch.
     */
    orderBy?: paroquiaPessoasOrderByWithRelationInput | paroquiaPessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing paroquiaPessoas.
     */
    cursor?: paroquiaPessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` paroquiaPessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` paroquiaPessoas.
     */
    skip?: number
    distinct?: ParoquiaPessoasScalarFieldEnum | ParoquiaPessoasScalarFieldEnum[]
  }

  /**
   * paroquiaPessoas create
   */
  export type paroquiaPessoasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    /**
     * The data needed to create a paroquiaPessoas.
     */
    data: XOR<paroquiaPessoasCreateInput, paroquiaPessoasUncheckedCreateInput>
  }

  /**
   * paroquiaPessoas createMany
   */
  export type paroquiaPessoasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many paroquiaPessoas.
     */
    data: paroquiaPessoasCreateManyInput | paroquiaPessoasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * paroquiaPessoas createManyAndReturn
   */
  export type paroquiaPessoasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * The data used to create many paroquiaPessoas.
     */
    data: paroquiaPessoasCreateManyInput | paroquiaPessoasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * paroquiaPessoas update
   */
  export type paroquiaPessoasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    /**
     * The data needed to update a paroquiaPessoas.
     */
    data: XOR<paroquiaPessoasUpdateInput, paroquiaPessoasUncheckedUpdateInput>
    /**
     * Choose, which paroquiaPessoas to update.
     */
    where: paroquiaPessoasWhereUniqueInput
  }

  /**
   * paroquiaPessoas updateMany
   */
  export type paroquiaPessoasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update paroquiaPessoas.
     */
    data: XOR<paroquiaPessoasUpdateManyMutationInput, paroquiaPessoasUncheckedUpdateManyInput>
    /**
     * Filter which paroquiaPessoas to update
     */
    where?: paroquiaPessoasWhereInput
    /**
     * Limit how many paroquiaPessoas to update.
     */
    limit?: number
  }

  /**
   * paroquiaPessoas updateManyAndReturn
   */
  export type paroquiaPessoasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * The data used to update paroquiaPessoas.
     */
    data: XOR<paroquiaPessoasUpdateManyMutationInput, paroquiaPessoasUncheckedUpdateManyInput>
    /**
     * Filter which paroquiaPessoas to update
     */
    where?: paroquiaPessoasWhereInput
    /**
     * Limit how many paroquiaPessoas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * paroquiaPessoas upsert
   */
  export type paroquiaPessoasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    /**
     * The filter to search for the paroquiaPessoas to update in case it exists.
     */
    where: paroquiaPessoasWhereUniqueInput
    /**
     * In case the paroquiaPessoas found by the `where` argument doesn't exist, create a new paroquiaPessoas with this data.
     */
    create: XOR<paroquiaPessoasCreateInput, paroquiaPessoasUncheckedCreateInput>
    /**
     * In case the paroquiaPessoas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paroquiaPessoasUpdateInput, paroquiaPessoasUncheckedUpdateInput>
  }

  /**
   * paroquiaPessoas delete
   */
  export type paroquiaPessoasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
    /**
     * Filter which paroquiaPessoas to delete.
     */
    where: paroquiaPessoasWhereUniqueInput
  }

  /**
   * paroquiaPessoas deleteMany
   */
  export type paroquiaPessoasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which paroquiaPessoas to delete
     */
    where?: paroquiaPessoasWhereInput
    /**
     * Limit how many paroquiaPessoas to delete.
     */
    limit?: number
  }

  /**
   * paroquiaPessoas without action
   */
  export type paroquiaPessoasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the paroquiaPessoas
     */
    select?: paroquiaPessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the paroquiaPessoas
     */
    omit?: paroquiaPessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paroquiaPessoasInclude<ExtArgs> | null
  }


  /**
   * Model etapa
   */

  export type AggregateEtapa = {
    _count: EtapaCountAggregateOutputType | null
    _avg: EtapaAvgAggregateOutputType | null
    _sum: EtapaSumAggregateOutputType | null
    _min: EtapaMinAggregateOutputType | null
    _max: EtapaMaxAggregateOutputType | null
  }

  export type EtapaAvgAggregateOutputType = {
    id: number | null
  }

  export type EtapaSumAggregateOutputType = {
    id: number | null
  }

  export type EtapaMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type EtapaMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type EtapaCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type EtapaAvgAggregateInputType = {
    id?: true
  }

  export type EtapaSumAggregateInputType = {
    id?: true
  }

  export type EtapaMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type EtapaMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type EtapaCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type EtapaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which etapa to aggregate.
     */
    where?: etapaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etapas to fetch.
     */
    orderBy?: etapaOrderByWithRelationInput | etapaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: etapaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etapas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etapas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned etapas
    **/
    _count?: true | EtapaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EtapaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EtapaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtapaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtapaMaxAggregateInputType
  }

  export type GetEtapaAggregateType<T extends EtapaAggregateArgs> = {
        [P in keyof T & keyof AggregateEtapa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtapa[P]>
      : GetScalarType<T[P], AggregateEtapa[P]>
  }




  export type etapaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: etapaWhereInput
    orderBy?: etapaOrderByWithAggregationInput | etapaOrderByWithAggregationInput[]
    by: EtapaScalarFieldEnum[] | EtapaScalarFieldEnum
    having?: etapaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtapaCountAggregateInputType | true
    _avg?: EtapaAvgAggregateInputType
    _sum?: EtapaSumAggregateInputType
    _min?: EtapaMinAggregateInputType
    _max?: EtapaMaxAggregateInputType
  }

  export type EtapaGroupByOutputType = {
    id: number
    descricao: string
    _count: EtapaCountAggregateOutputType | null
    _avg: EtapaAvgAggregateOutputType | null
    _sum: EtapaSumAggregateOutputType | null
    _min: EtapaMinAggregateOutputType | null
    _max: EtapaMaxAggregateOutputType | null
  }

  type GetEtapaGroupByPayload<T extends etapaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtapaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtapaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtapaGroupByOutputType[P]>
            : GetScalarType<T[P], EtapaGroupByOutputType[P]>
        }
      >
    >


  export type etapaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["etapa"]>

  export type etapaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["etapa"]>

  export type etapaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["etapa"]>

  export type etapaSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type etapaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["etapa"]>

  export type $etapaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "etapa"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["etapa"]>
    composites: {}
  }

  type etapaGetPayload<S extends boolean | null | undefined | etapaDefaultArgs> = $Result.GetResult<Prisma.$etapaPayload, S>

  type etapaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<etapaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EtapaCountAggregateInputType | true
    }

  export interface etapaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['etapa'], meta: { name: 'etapa' } }
    /**
     * Find zero or one Etapa that matches the filter.
     * @param {etapaFindUniqueArgs} args - Arguments to find a Etapa
     * @example
     * // Get one Etapa
     * const etapa = await prisma.etapa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends etapaFindUniqueArgs>(args: SelectSubset<T, etapaFindUniqueArgs<ExtArgs>>): Prisma__etapaClient<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Etapa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {etapaFindUniqueOrThrowArgs} args - Arguments to find a Etapa
     * @example
     * // Get one Etapa
     * const etapa = await prisma.etapa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends etapaFindUniqueOrThrowArgs>(args: SelectSubset<T, etapaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__etapaClient<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Etapa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etapaFindFirstArgs} args - Arguments to find a Etapa
     * @example
     * // Get one Etapa
     * const etapa = await prisma.etapa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends etapaFindFirstArgs>(args?: SelectSubset<T, etapaFindFirstArgs<ExtArgs>>): Prisma__etapaClient<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Etapa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etapaFindFirstOrThrowArgs} args - Arguments to find a Etapa
     * @example
     * // Get one Etapa
     * const etapa = await prisma.etapa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends etapaFindFirstOrThrowArgs>(args?: SelectSubset<T, etapaFindFirstOrThrowArgs<ExtArgs>>): Prisma__etapaClient<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Etapas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etapaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etapas
     * const etapas = await prisma.etapa.findMany()
     * 
     * // Get first 10 Etapas
     * const etapas = await prisma.etapa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const etapaWithIdOnly = await prisma.etapa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends etapaFindManyArgs>(args?: SelectSubset<T, etapaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Etapa.
     * @param {etapaCreateArgs} args - Arguments to create a Etapa.
     * @example
     * // Create one Etapa
     * const Etapa = await prisma.etapa.create({
     *   data: {
     *     // ... data to create a Etapa
     *   }
     * })
     * 
     */
    create<T extends etapaCreateArgs>(args: SelectSubset<T, etapaCreateArgs<ExtArgs>>): Prisma__etapaClient<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Etapas.
     * @param {etapaCreateManyArgs} args - Arguments to create many Etapas.
     * @example
     * // Create many Etapas
     * const etapa = await prisma.etapa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends etapaCreateManyArgs>(args?: SelectSubset<T, etapaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Etapas and returns the data saved in the database.
     * @param {etapaCreateManyAndReturnArgs} args - Arguments to create many Etapas.
     * @example
     * // Create many Etapas
     * const etapa = await prisma.etapa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Etapas and only return the `id`
     * const etapaWithIdOnly = await prisma.etapa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends etapaCreateManyAndReturnArgs>(args?: SelectSubset<T, etapaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Etapa.
     * @param {etapaDeleteArgs} args - Arguments to delete one Etapa.
     * @example
     * // Delete one Etapa
     * const Etapa = await prisma.etapa.delete({
     *   where: {
     *     // ... filter to delete one Etapa
     *   }
     * })
     * 
     */
    delete<T extends etapaDeleteArgs>(args: SelectSubset<T, etapaDeleteArgs<ExtArgs>>): Prisma__etapaClient<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Etapa.
     * @param {etapaUpdateArgs} args - Arguments to update one Etapa.
     * @example
     * // Update one Etapa
     * const etapa = await prisma.etapa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends etapaUpdateArgs>(args: SelectSubset<T, etapaUpdateArgs<ExtArgs>>): Prisma__etapaClient<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Etapas.
     * @param {etapaDeleteManyArgs} args - Arguments to filter Etapas to delete.
     * @example
     * // Delete a few Etapas
     * const { count } = await prisma.etapa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends etapaDeleteManyArgs>(args?: SelectSubset<T, etapaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etapas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etapaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etapas
     * const etapa = await prisma.etapa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends etapaUpdateManyArgs>(args: SelectSubset<T, etapaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etapas and returns the data updated in the database.
     * @param {etapaUpdateManyAndReturnArgs} args - Arguments to update many Etapas.
     * @example
     * // Update many Etapas
     * const etapa = await prisma.etapa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Etapas and only return the `id`
     * const etapaWithIdOnly = await prisma.etapa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends etapaUpdateManyAndReturnArgs>(args: SelectSubset<T, etapaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Etapa.
     * @param {etapaUpsertArgs} args - Arguments to update or create a Etapa.
     * @example
     * // Update or create a Etapa
     * const etapa = await prisma.etapa.upsert({
     *   create: {
     *     // ... data to create a Etapa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Etapa we want to update
     *   }
     * })
     */
    upsert<T extends etapaUpsertArgs>(args: SelectSubset<T, etapaUpsertArgs<ExtArgs>>): Prisma__etapaClient<$Result.GetResult<Prisma.$etapaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Etapas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etapaCountArgs} args - Arguments to filter Etapas to count.
     * @example
     * // Count the number of Etapas
     * const count = await prisma.etapa.count({
     *   where: {
     *     // ... the filter for the Etapas we want to count
     *   }
     * })
    **/
    count<T extends etapaCountArgs>(
      args?: Subset<T, etapaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtapaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etapa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtapaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtapaAggregateArgs>(args: Subset<T, EtapaAggregateArgs>): Prisma.PrismaPromise<GetEtapaAggregateType<T>>

    /**
     * Group by Etapa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etapaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends etapaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: etapaGroupByArgs['orderBy'] }
        : { orderBy?: etapaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, etapaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtapaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the etapa model
   */
  readonly fields: etapaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for etapa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__etapaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the etapa model
   */
  interface etapaFieldRefs {
    readonly id: FieldRef<"etapa", 'Int'>
    readonly descricao: FieldRef<"etapa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * etapa findUnique
   */
  export type etapaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * Filter, which etapa to fetch.
     */
    where: etapaWhereUniqueInput
  }

  /**
   * etapa findUniqueOrThrow
   */
  export type etapaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * Filter, which etapa to fetch.
     */
    where: etapaWhereUniqueInput
  }

  /**
   * etapa findFirst
   */
  export type etapaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * Filter, which etapa to fetch.
     */
    where?: etapaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etapas to fetch.
     */
    orderBy?: etapaOrderByWithRelationInput | etapaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for etapas.
     */
    cursor?: etapaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etapas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etapas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of etapas.
     */
    distinct?: EtapaScalarFieldEnum | EtapaScalarFieldEnum[]
  }

  /**
   * etapa findFirstOrThrow
   */
  export type etapaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * Filter, which etapa to fetch.
     */
    where?: etapaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etapas to fetch.
     */
    orderBy?: etapaOrderByWithRelationInput | etapaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for etapas.
     */
    cursor?: etapaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etapas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etapas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of etapas.
     */
    distinct?: EtapaScalarFieldEnum | EtapaScalarFieldEnum[]
  }

  /**
   * etapa findMany
   */
  export type etapaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * Filter, which etapas to fetch.
     */
    where?: etapaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etapas to fetch.
     */
    orderBy?: etapaOrderByWithRelationInput | etapaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing etapas.
     */
    cursor?: etapaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etapas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etapas.
     */
    skip?: number
    distinct?: EtapaScalarFieldEnum | EtapaScalarFieldEnum[]
  }

  /**
   * etapa create
   */
  export type etapaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * The data needed to create a etapa.
     */
    data: XOR<etapaCreateInput, etapaUncheckedCreateInput>
  }

  /**
   * etapa createMany
   */
  export type etapaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many etapas.
     */
    data: etapaCreateManyInput | etapaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * etapa createManyAndReturn
   */
  export type etapaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * The data used to create many etapas.
     */
    data: etapaCreateManyInput | etapaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * etapa update
   */
  export type etapaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * The data needed to update a etapa.
     */
    data: XOR<etapaUpdateInput, etapaUncheckedUpdateInput>
    /**
     * Choose, which etapa to update.
     */
    where: etapaWhereUniqueInput
  }

  /**
   * etapa updateMany
   */
  export type etapaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update etapas.
     */
    data: XOR<etapaUpdateManyMutationInput, etapaUncheckedUpdateManyInput>
    /**
     * Filter which etapas to update
     */
    where?: etapaWhereInput
    /**
     * Limit how many etapas to update.
     */
    limit?: number
  }

  /**
   * etapa updateManyAndReturn
   */
  export type etapaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * The data used to update etapas.
     */
    data: XOR<etapaUpdateManyMutationInput, etapaUncheckedUpdateManyInput>
    /**
     * Filter which etapas to update
     */
    where?: etapaWhereInput
    /**
     * Limit how many etapas to update.
     */
    limit?: number
  }

  /**
   * etapa upsert
   */
  export type etapaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * The filter to search for the etapa to update in case it exists.
     */
    where: etapaWhereUniqueInput
    /**
     * In case the etapa found by the `where` argument doesn't exist, create a new etapa with this data.
     */
    create: XOR<etapaCreateInput, etapaUncheckedCreateInput>
    /**
     * In case the etapa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<etapaUpdateInput, etapaUncheckedUpdateInput>
  }

  /**
   * etapa delete
   */
  export type etapaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
    /**
     * Filter which etapa to delete.
     */
    where: etapaWhereUniqueInput
  }

  /**
   * etapa deleteMany
   */
  export type etapaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which etapas to delete
     */
    where?: etapaWhereInput
    /**
     * Limit how many etapas to delete.
     */
    limit?: number
  }

  /**
   * etapa without action
   */
  export type etapaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etapa
     */
    select?: etapaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the etapa
     */
    omit?: etapaOmit<ExtArgs> | null
  }


  /**
   * Model regiao
   */

  export type AggregateRegiao = {
    _count: RegiaoCountAggregateOutputType | null
    _avg: RegiaoAvgAggregateOutputType | null
    _sum: RegiaoSumAggregateOutputType | null
    _min: RegiaoMinAggregateOutputType | null
    _max: RegiaoMaxAggregateOutputType | null
  }

  export type RegiaoAvgAggregateOutputType = {
    id: number | null
  }

  export type RegiaoSumAggregateOutputType = {
    id: number | null
  }

  export type RegiaoMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    macroRegiao: boolean | null
  }

  export type RegiaoMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    macroRegiao: boolean | null
  }

  export type RegiaoCountAggregateOutputType = {
    id: number
    descricao: number
    macroRegiao: number
    _all: number
  }


  export type RegiaoAvgAggregateInputType = {
    id?: true
  }

  export type RegiaoSumAggregateInputType = {
    id?: true
  }

  export type RegiaoMinAggregateInputType = {
    id?: true
    descricao?: true
    macroRegiao?: true
  }

  export type RegiaoMaxAggregateInputType = {
    id?: true
    descricao?: true
    macroRegiao?: true
  }

  export type RegiaoCountAggregateInputType = {
    id?: true
    descricao?: true
    macroRegiao?: true
    _all?: true
  }

  export type RegiaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which regiao to aggregate.
     */
    where?: regiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiaos to fetch.
     */
    orderBy?: regiaoOrderByWithRelationInput | regiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: regiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned regiaos
    **/
    _count?: true | RegiaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegiaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegiaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegiaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegiaoMaxAggregateInputType
  }

  export type GetRegiaoAggregateType<T extends RegiaoAggregateArgs> = {
        [P in keyof T & keyof AggregateRegiao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegiao[P]>
      : GetScalarType<T[P], AggregateRegiao[P]>
  }




  export type regiaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: regiaoWhereInput
    orderBy?: regiaoOrderByWithAggregationInput | regiaoOrderByWithAggregationInput[]
    by: RegiaoScalarFieldEnum[] | RegiaoScalarFieldEnum
    having?: regiaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegiaoCountAggregateInputType | true
    _avg?: RegiaoAvgAggregateInputType
    _sum?: RegiaoSumAggregateInputType
    _min?: RegiaoMinAggregateInputType
    _max?: RegiaoMaxAggregateInputType
  }

  export type RegiaoGroupByOutputType = {
    id: number
    descricao: string
    macroRegiao: boolean
    _count: RegiaoCountAggregateOutputType | null
    _avg: RegiaoAvgAggregateOutputType | null
    _sum: RegiaoSumAggregateOutputType | null
    _min: RegiaoMinAggregateOutputType | null
    _max: RegiaoMaxAggregateOutputType | null
  }

  type GetRegiaoGroupByPayload<T extends regiaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegiaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegiaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegiaoGroupByOutputType[P]>
            : GetScalarType<T[P], RegiaoGroupByOutputType[P]>
        }
      >
    >


  export type regiaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    macroRegiao?: boolean
    equipes?: boolean | regiao$equipesArgs<ExtArgs>
    localidadeRegiao?: boolean | regiao$localidadeRegiaoArgs<ExtArgs>
    _count?: boolean | RegiaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regiao"]>

  export type regiaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    macroRegiao?: boolean
  }, ExtArgs["result"]["regiao"]>

  export type regiaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    macroRegiao?: boolean
  }, ExtArgs["result"]["regiao"]>

  export type regiaoSelectScalar = {
    id?: boolean
    descricao?: boolean
    macroRegiao?: boolean
  }

  export type regiaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "macroRegiao", ExtArgs["result"]["regiao"]>
  export type regiaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipes?: boolean | regiao$equipesArgs<ExtArgs>
    localidadeRegiao?: boolean | regiao$localidadeRegiaoArgs<ExtArgs>
    _count?: boolean | RegiaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type regiaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type regiaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $regiaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "regiao"
    objects: {
      equipes: Prisma.$equipeRegiaoPayload<ExtArgs>[]
      localidadeRegiao: Prisma.$localidadeRegiaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      macroRegiao: boolean
    }, ExtArgs["result"]["regiao"]>
    composites: {}
  }

  type regiaoGetPayload<S extends boolean | null | undefined | regiaoDefaultArgs> = $Result.GetResult<Prisma.$regiaoPayload, S>

  type regiaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<regiaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegiaoCountAggregateInputType | true
    }

  export interface regiaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['regiao'], meta: { name: 'regiao' } }
    /**
     * Find zero or one Regiao that matches the filter.
     * @param {regiaoFindUniqueArgs} args - Arguments to find a Regiao
     * @example
     * // Get one Regiao
     * const regiao = await prisma.regiao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends regiaoFindUniqueArgs>(args: SelectSubset<T, regiaoFindUniqueArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Regiao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {regiaoFindUniqueOrThrowArgs} args - Arguments to find a Regiao
     * @example
     * // Get one Regiao
     * const regiao = await prisma.regiao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends regiaoFindUniqueOrThrowArgs>(args: SelectSubset<T, regiaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Regiao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiaoFindFirstArgs} args - Arguments to find a Regiao
     * @example
     * // Get one Regiao
     * const regiao = await prisma.regiao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends regiaoFindFirstArgs>(args?: SelectSubset<T, regiaoFindFirstArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Regiao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiaoFindFirstOrThrowArgs} args - Arguments to find a Regiao
     * @example
     * // Get one Regiao
     * const regiao = await prisma.regiao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends regiaoFindFirstOrThrowArgs>(args?: SelectSubset<T, regiaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regiaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regiaos
     * const regiaos = await prisma.regiao.findMany()
     * 
     * // Get first 10 Regiaos
     * const regiaos = await prisma.regiao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regiaoWithIdOnly = await prisma.regiao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends regiaoFindManyArgs>(args?: SelectSubset<T, regiaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Regiao.
     * @param {regiaoCreateArgs} args - Arguments to create a Regiao.
     * @example
     * // Create one Regiao
     * const Regiao = await prisma.regiao.create({
     *   data: {
     *     // ... data to create a Regiao
     *   }
     * })
     * 
     */
    create<T extends regiaoCreateArgs>(args: SelectSubset<T, regiaoCreateArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regiaos.
     * @param {regiaoCreateManyArgs} args - Arguments to create many Regiaos.
     * @example
     * // Create many Regiaos
     * const regiao = await prisma.regiao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends regiaoCreateManyArgs>(args?: SelectSubset<T, regiaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regiaos and returns the data saved in the database.
     * @param {regiaoCreateManyAndReturnArgs} args - Arguments to create many Regiaos.
     * @example
     * // Create many Regiaos
     * const regiao = await prisma.regiao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regiaos and only return the `id`
     * const regiaoWithIdOnly = await prisma.regiao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends regiaoCreateManyAndReturnArgs>(args?: SelectSubset<T, regiaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Regiao.
     * @param {regiaoDeleteArgs} args - Arguments to delete one Regiao.
     * @example
     * // Delete one Regiao
     * const Regiao = await prisma.regiao.delete({
     *   where: {
     *     // ... filter to delete one Regiao
     *   }
     * })
     * 
     */
    delete<T extends regiaoDeleteArgs>(args: SelectSubset<T, regiaoDeleteArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Regiao.
     * @param {regiaoUpdateArgs} args - Arguments to update one Regiao.
     * @example
     * // Update one Regiao
     * const regiao = await prisma.regiao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends regiaoUpdateArgs>(args: SelectSubset<T, regiaoUpdateArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regiaos.
     * @param {regiaoDeleteManyArgs} args - Arguments to filter Regiaos to delete.
     * @example
     * // Delete a few Regiaos
     * const { count } = await prisma.regiao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends regiaoDeleteManyArgs>(args?: SelectSubset<T, regiaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regiaos
     * const regiao = await prisma.regiao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends regiaoUpdateManyArgs>(args: SelectSubset<T, regiaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regiaos and returns the data updated in the database.
     * @param {regiaoUpdateManyAndReturnArgs} args - Arguments to update many Regiaos.
     * @example
     * // Update many Regiaos
     * const regiao = await prisma.regiao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Regiaos and only return the `id`
     * const regiaoWithIdOnly = await prisma.regiao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends regiaoUpdateManyAndReturnArgs>(args: SelectSubset<T, regiaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Regiao.
     * @param {regiaoUpsertArgs} args - Arguments to update or create a Regiao.
     * @example
     * // Update or create a Regiao
     * const regiao = await prisma.regiao.upsert({
     *   create: {
     *     // ... data to create a Regiao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regiao we want to update
     *   }
     * })
     */
    upsert<T extends regiaoUpsertArgs>(args: SelectSubset<T, regiaoUpsertArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiaoCountArgs} args - Arguments to filter Regiaos to count.
     * @example
     * // Count the number of Regiaos
     * const count = await prisma.regiao.count({
     *   where: {
     *     // ... the filter for the Regiaos we want to count
     *   }
     * })
    **/
    count<T extends regiaoCountArgs>(
      args?: Subset<T, regiaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegiaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegiaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegiaoAggregateArgs>(args: Subset<T, RegiaoAggregateArgs>): Prisma.PrismaPromise<GetRegiaoAggregateType<T>>

    /**
     * Group by Regiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regiaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends regiaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: regiaoGroupByArgs['orderBy'] }
        : { orderBy?: regiaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, regiaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegiaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the regiao model
   */
  readonly fields: regiaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for regiao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__regiaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipes<T extends regiao$equipesArgs<ExtArgs> = {}>(args?: Subset<T, regiao$equipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    localidadeRegiao<T extends regiao$localidadeRegiaoArgs<ExtArgs> = {}>(args?: Subset<T, regiao$localidadeRegiaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the regiao model
   */
  interface regiaoFieldRefs {
    readonly id: FieldRef<"regiao", 'Int'>
    readonly descricao: FieldRef<"regiao", 'String'>
    readonly macroRegiao: FieldRef<"regiao", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * regiao findUnique
   */
  export type regiaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
    /**
     * Filter, which regiao to fetch.
     */
    where: regiaoWhereUniqueInput
  }

  /**
   * regiao findUniqueOrThrow
   */
  export type regiaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
    /**
     * Filter, which regiao to fetch.
     */
    where: regiaoWhereUniqueInput
  }

  /**
   * regiao findFirst
   */
  export type regiaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
    /**
     * Filter, which regiao to fetch.
     */
    where?: regiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiaos to fetch.
     */
    orderBy?: regiaoOrderByWithRelationInput | regiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regiaos.
     */
    cursor?: regiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regiaos.
     */
    distinct?: RegiaoScalarFieldEnum | RegiaoScalarFieldEnum[]
  }

  /**
   * regiao findFirstOrThrow
   */
  export type regiaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
    /**
     * Filter, which regiao to fetch.
     */
    where?: regiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiaos to fetch.
     */
    orderBy?: regiaoOrderByWithRelationInput | regiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regiaos.
     */
    cursor?: regiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regiaos.
     */
    distinct?: RegiaoScalarFieldEnum | RegiaoScalarFieldEnum[]
  }

  /**
   * regiao findMany
   */
  export type regiaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
    /**
     * Filter, which regiaos to fetch.
     */
    where?: regiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regiaos to fetch.
     */
    orderBy?: regiaoOrderByWithRelationInput | regiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing regiaos.
     */
    cursor?: regiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regiaos.
     */
    skip?: number
    distinct?: RegiaoScalarFieldEnum | RegiaoScalarFieldEnum[]
  }

  /**
   * regiao create
   */
  export type regiaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
    /**
     * The data needed to create a regiao.
     */
    data: XOR<regiaoCreateInput, regiaoUncheckedCreateInput>
  }

  /**
   * regiao createMany
   */
  export type regiaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many regiaos.
     */
    data: regiaoCreateManyInput | regiaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * regiao createManyAndReturn
   */
  export type regiaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * The data used to create many regiaos.
     */
    data: regiaoCreateManyInput | regiaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * regiao update
   */
  export type regiaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
    /**
     * The data needed to update a regiao.
     */
    data: XOR<regiaoUpdateInput, regiaoUncheckedUpdateInput>
    /**
     * Choose, which regiao to update.
     */
    where: regiaoWhereUniqueInput
  }

  /**
   * regiao updateMany
   */
  export type regiaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update regiaos.
     */
    data: XOR<regiaoUpdateManyMutationInput, regiaoUncheckedUpdateManyInput>
    /**
     * Filter which regiaos to update
     */
    where?: regiaoWhereInput
    /**
     * Limit how many regiaos to update.
     */
    limit?: number
  }

  /**
   * regiao updateManyAndReturn
   */
  export type regiaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * The data used to update regiaos.
     */
    data: XOR<regiaoUpdateManyMutationInput, regiaoUncheckedUpdateManyInput>
    /**
     * Filter which regiaos to update
     */
    where?: regiaoWhereInput
    /**
     * Limit how many regiaos to update.
     */
    limit?: number
  }

  /**
   * regiao upsert
   */
  export type regiaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
    /**
     * The filter to search for the regiao to update in case it exists.
     */
    where: regiaoWhereUniqueInput
    /**
     * In case the regiao found by the `where` argument doesn't exist, create a new regiao with this data.
     */
    create: XOR<regiaoCreateInput, regiaoUncheckedCreateInput>
    /**
     * In case the regiao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<regiaoUpdateInput, regiaoUncheckedUpdateInput>
  }

  /**
   * regiao delete
   */
  export type regiaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
    /**
     * Filter which regiao to delete.
     */
    where: regiaoWhereUniqueInput
  }

  /**
   * regiao deleteMany
   */
  export type regiaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which regiaos to delete
     */
    where?: regiaoWhereInput
    /**
     * Limit how many regiaos to delete.
     */
    limit?: number
  }

  /**
   * regiao.equipes
   */
  export type regiao$equipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    where?: equipeRegiaoWhereInput
    orderBy?: equipeRegiaoOrderByWithRelationInput | equipeRegiaoOrderByWithRelationInput[]
    cursor?: equipeRegiaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipeRegiaoScalarFieldEnum | EquipeRegiaoScalarFieldEnum[]
  }

  /**
   * regiao.localidadeRegiao
   */
  export type regiao$localidadeRegiaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    where?: localidadeRegiaoWhereInput
    orderBy?: localidadeRegiaoOrderByWithRelationInput | localidadeRegiaoOrderByWithRelationInput[]
    cursor?: localidadeRegiaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalidadeRegiaoScalarFieldEnum | LocalidadeRegiaoScalarFieldEnum[]
  }

  /**
   * regiao without action
   */
  export type regiaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regiao
     */
    select?: regiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regiao
     */
    omit?: regiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regiaoInclude<ExtArgs> | null
  }


  /**
   * Model tipoEquipe
   */

  export type AggregateTipoEquipe = {
    _count: TipoEquipeCountAggregateOutputType | null
    _avg: TipoEquipeAvgAggregateOutputType | null
    _sum: TipoEquipeSumAggregateOutputType | null
    _min: TipoEquipeMinAggregateOutputType | null
    _max: TipoEquipeMaxAggregateOutputType | null
  }

  export type TipoEquipeAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoEquipeSumAggregateOutputType = {
    id: number | null
  }

  export type TipoEquipeMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoEquipeMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoEquipeCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type TipoEquipeAvgAggregateInputType = {
    id?: true
  }

  export type TipoEquipeSumAggregateInputType = {
    id?: true
  }

  export type TipoEquipeMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoEquipeMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoEquipeCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type TipoEquipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoEquipe to aggregate.
     */
    where?: tipoEquipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoEquipes to fetch.
     */
    orderBy?: tipoEquipeOrderByWithRelationInput | tipoEquipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipoEquipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoEquipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipoEquipes
    **/
    _count?: true | TipoEquipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoEquipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoEquipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoEquipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoEquipeMaxAggregateInputType
  }

  export type GetTipoEquipeAggregateType<T extends TipoEquipeAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoEquipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoEquipe[P]>
      : GetScalarType<T[P], AggregateTipoEquipe[P]>
  }




  export type tipoEquipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipoEquipeWhereInput
    orderBy?: tipoEquipeOrderByWithAggregationInput | tipoEquipeOrderByWithAggregationInput[]
    by: TipoEquipeScalarFieldEnum[] | TipoEquipeScalarFieldEnum
    having?: tipoEquipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoEquipeCountAggregateInputType | true
    _avg?: TipoEquipeAvgAggregateInputType
    _sum?: TipoEquipeSumAggregateInputType
    _min?: TipoEquipeMinAggregateInputType
    _max?: TipoEquipeMaxAggregateInputType
  }

  export type TipoEquipeGroupByOutputType = {
    id: number
    descricao: string
    _count: TipoEquipeCountAggregateOutputType | null
    _avg: TipoEquipeAvgAggregateOutputType | null
    _sum: TipoEquipeSumAggregateOutputType | null
    _min: TipoEquipeMinAggregateOutputType | null
    _max: TipoEquipeMaxAggregateOutputType | null
  }

  type GetTipoEquipeGroupByPayload<T extends tipoEquipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoEquipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoEquipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoEquipeGroupByOutputType[P]>
            : GetScalarType<T[P], TipoEquipeGroupByOutputType[P]>
        }
      >
    >


  export type tipoEquipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    equipes?: boolean | tipoEquipe$equipesArgs<ExtArgs>
    _count?: boolean | TipoEquipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoEquipe"]>

  export type tipoEquipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoEquipe"]>

  export type tipoEquipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoEquipe"]>

  export type tipoEquipeSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type tipoEquipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["tipoEquipe"]>
  export type tipoEquipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipes?: boolean | tipoEquipe$equipesArgs<ExtArgs>
    _count?: boolean | TipoEquipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tipoEquipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tipoEquipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tipoEquipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipoEquipe"
    objects: {
      equipes: Prisma.$equipeTipoEquipePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["tipoEquipe"]>
    composites: {}
  }

  type tipoEquipeGetPayload<S extends boolean | null | undefined | tipoEquipeDefaultArgs> = $Result.GetResult<Prisma.$tipoEquipePayload, S>

  type tipoEquipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipoEquipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoEquipeCountAggregateInputType | true
    }

  export interface tipoEquipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipoEquipe'], meta: { name: 'tipoEquipe' } }
    /**
     * Find zero or one TipoEquipe that matches the filter.
     * @param {tipoEquipeFindUniqueArgs} args - Arguments to find a TipoEquipe
     * @example
     * // Get one TipoEquipe
     * const tipoEquipe = await prisma.tipoEquipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipoEquipeFindUniqueArgs>(args: SelectSubset<T, tipoEquipeFindUniqueArgs<ExtArgs>>): Prisma__tipoEquipeClient<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoEquipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipoEquipeFindUniqueOrThrowArgs} args - Arguments to find a TipoEquipe
     * @example
     * // Get one TipoEquipe
     * const tipoEquipe = await prisma.tipoEquipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipoEquipeFindUniqueOrThrowArgs>(args: SelectSubset<T, tipoEquipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipoEquipeClient<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoEquipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoEquipeFindFirstArgs} args - Arguments to find a TipoEquipe
     * @example
     * // Get one TipoEquipe
     * const tipoEquipe = await prisma.tipoEquipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipoEquipeFindFirstArgs>(args?: SelectSubset<T, tipoEquipeFindFirstArgs<ExtArgs>>): Prisma__tipoEquipeClient<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoEquipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoEquipeFindFirstOrThrowArgs} args - Arguments to find a TipoEquipe
     * @example
     * // Get one TipoEquipe
     * const tipoEquipe = await prisma.tipoEquipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipoEquipeFindFirstOrThrowArgs>(args?: SelectSubset<T, tipoEquipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipoEquipeClient<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoEquipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoEquipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoEquipes
     * const tipoEquipes = await prisma.tipoEquipe.findMany()
     * 
     * // Get first 10 TipoEquipes
     * const tipoEquipes = await prisma.tipoEquipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoEquipeWithIdOnly = await prisma.tipoEquipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tipoEquipeFindManyArgs>(args?: SelectSubset<T, tipoEquipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoEquipe.
     * @param {tipoEquipeCreateArgs} args - Arguments to create a TipoEquipe.
     * @example
     * // Create one TipoEquipe
     * const TipoEquipe = await prisma.tipoEquipe.create({
     *   data: {
     *     // ... data to create a TipoEquipe
     *   }
     * })
     * 
     */
    create<T extends tipoEquipeCreateArgs>(args: SelectSubset<T, tipoEquipeCreateArgs<ExtArgs>>): Prisma__tipoEquipeClient<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoEquipes.
     * @param {tipoEquipeCreateManyArgs} args - Arguments to create many TipoEquipes.
     * @example
     * // Create many TipoEquipes
     * const tipoEquipe = await prisma.tipoEquipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipoEquipeCreateManyArgs>(args?: SelectSubset<T, tipoEquipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoEquipes and returns the data saved in the database.
     * @param {tipoEquipeCreateManyAndReturnArgs} args - Arguments to create many TipoEquipes.
     * @example
     * // Create many TipoEquipes
     * const tipoEquipe = await prisma.tipoEquipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoEquipes and only return the `id`
     * const tipoEquipeWithIdOnly = await prisma.tipoEquipe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tipoEquipeCreateManyAndReturnArgs>(args?: SelectSubset<T, tipoEquipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoEquipe.
     * @param {tipoEquipeDeleteArgs} args - Arguments to delete one TipoEquipe.
     * @example
     * // Delete one TipoEquipe
     * const TipoEquipe = await prisma.tipoEquipe.delete({
     *   where: {
     *     // ... filter to delete one TipoEquipe
     *   }
     * })
     * 
     */
    delete<T extends tipoEquipeDeleteArgs>(args: SelectSubset<T, tipoEquipeDeleteArgs<ExtArgs>>): Prisma__tipoEquipeClient<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoEquipe.
     * @param {tipoEquipeUpdateArgs} args - Arguments to update one TipoEquipe.
     * @example
     * // Update one TipoEquipe
     * const tipoEquipe = await prisma.tipoEquipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipoEquipeUpdateArgs>(args: SelectSubset<T, tipoEquipeUpdateArgs<ExtArgs>>): Prisma__tipoEquipeClient<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoEquipes.
     * @param {tipoEquipeDeleteManyArgs} args - Arguments to filter TipoEquipes to delete.
     * @example
     * // Delete a few TipoEquipes
     * const { count } = await prisma.tipoEquipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipoEquipeDeleteManyArgs>(args?: SelectSubset<T, tipoEquipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoEquipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoEquipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoEquipes
     * const tipoEquipe = await prisma.tipoEquipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipoEquipeUpdateManyArgs>(args: SelectSubset<T, tipoEquipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoEquipes and returns the data updated in the database.
     * @param {tipoEquipeUpdateManyAndReturnArgs} args - Arguments to update many TipoEquipes.
     * @example
     * // Update many TipoEquipes
     * const tipoEquipe = await prisma.tipoEquipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoEquipes and only return the `id`
     * const tipoEquipeWithIdOnly = await prisma.tipoEquipe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tipoEquipeUpdateManyAndReturnArgs>(args: SelectSubset<T, tipoEquipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoEquipe.
     * @param {tipoEquipeUpsertArgs} args - Arguments to update or create a TipoEquipe.
     * @example
     * // Update or create a TipoEquipe
     * const tipoEquipe = await prisma.tipoEquipe.upsert({
     *   create: {
     *     // ... data to create a TipoEquipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoEquipe we want to update
     *   }
     * })
     */
    upsert<T extends tipoEquipeUpsertArgs>(args: SelectSubset<T, tipoEquipeUpsertArgs<ExtArgs>>): Prisma__tipoEquipeClient<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoEquipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoEquipeCountArgs} args - Arguments to filter TipoEquipes to count.
     * @example
     * // Count the number of TipoEquipes
     * const count = await prisma.tipoEquipe.count({
     *   where: {
     *     // ... the filter for the TipoEquipes we want to count
     *   }
     * })
    **/
    count<T extends tipoEquipeCountArgs>(
      args?: Subset<T, tipoEquipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoEquipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoEquipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEquipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoEquipeAggregateArgs>(args: Subset<T, TipoEquipeAggregateArgs>): Prisma.PrismaPromise<GetTipoEquipeAggregateType<T>>

    /**
     * Group by TipoEquipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoEquipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipoEquipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipoEquipeGroupByArgs['orderBy'] }
        : { orderBy?: tipoEquipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipoEquipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoEquipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipoEquipe model
   */
  readonly fields: tipoEquipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipoEquipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipoEquipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipes<T extends tipoEquipe$equipesArgs<ExtArgs> = {}>(args?: Subset<T, tipoEquipe$equipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipoEquipe model
   */
  interface tipoEquipeFieldRefs {
    readonly id: FieldRef<"tipoEquipe", 'Int'>
    readonly descricao: FieldRef<"tipoEquipe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tipoEquipe findUnique
   */
  export type tipoEquipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which tipoEquipe to fetch.
     */
    where: tipoEquipeWhereUniqueInput
  }

  /**
   * tipoEquipe findUniqueOrThrow
   */
  export type tipoEquipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which tipoEquipe to fetch.
     */
    where: tipoEquipeWhereUniqueInput
  }

  /**
   * tipoEquipe findFirst
   */
  export type tipoEquipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which tipoEquipe to fetch.
     */
    where?: tipoEquipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoEquipes to fetch.
     */
    orderBy?: tipoEquipeOrderByWithRelationInput | tipoEquipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoEquipes.
     */
    cursor?: tipoEquipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoEquipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoEquipes.
     */
    distinct?: TipoEquipeScalarFieldEnum | TipoEquipeScalarFieldEnum[]
  }

  /**
   * tipoEquipe findFirstOrThrow
   */
  export type tipoEquipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which tipoEquipe to fetch.
     */
    where?: tipoEquipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoEquipes to fetch.
     */
    orderBy?: tipoEquipeOrderByWithRelationInput | tipoEquipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoEquipes.
     */
    cursor?: tipoEquipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoEquipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoEquipes.
     */
    distinct?: TipoEquipeScalarFieldEnum | TipoEquipeScalarFieldEnum[]
  }

  /**
   * tipoEquipe findMany
   */
  export type tipoEquipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which tipoEquipes to fetch.
     */
    where?: tipoEquipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoEquipes to fetch.
     */
    orderBy?: tipoEquipeOrderByWithRelationInput | tipoEquipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipoEquipes.
     */
    cursor?: tipoEquipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoEquipes.
     */
    skip?: number
    distinct?: TipoEquipeScalarFieldEnum | TipoEquipeScalarFieldEnum[]
  }

  /**
   * tipoEquipe create
   */
  export type tipoEquipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
    /**
     * The data needed to create a tipoEquipe.
     */
    data: XOR<tipoEquipeCreateInput, tipoEquipeUncheckedCreateInput>
  }

  /**
   * tipoEquipe createMany
   */
  export type tipoEquipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipoEquipes.
     */
    data: tipoEquipeCreateManyInput | tipoEquipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoEquipe createManyAndReturn
   */
  export type tipoEquipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * The data used to create many tipoEquipes.
     */
    data: tipoEquipeCreateManyInput | tipoEquipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoEquipe update
   */
  export type tipoEquipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
    /**
     * The data needed to update a tipoEquipe.
     */
    data: XOR<tipoEquipeUpdateInput, tipoEquipeUncheckedUpdateInput>
    /**
     * Choose, which tipoEquipe to update.
     */
    where: tipoEquipeWhereUniqueInput
  }

  /**
   * tipoEquipe updateMany
   */
  export type tipoEquipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipoEquipes.
     */
    data: XOR<tipoEquipeUpdateManyMutationInput, tipoEquipeUncheckedUpdateManyInput>
    /**
     * Filter which tipoEquipes to update
     */
    where?: tipoEquipeWhereInput
    /**
     * Limit how many tipoEquipes to update.
     */
    limit?: number
  }

  /**
   * tipoEquipe updateManyAndReturn
   */
  export type tipoEquipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * The data used to update tipoEquipes.
     */
    data: XOR<tipoEquipeUpdateManyMutationInput, tipoEquipeUncheckedUpdateManyInput>
    /**
     * Filter which tipoEquipes to update
     */
    where?: tipoEquipeWhereInput
    /**
     * Limit how many tipoEquipes to update.
     */
    limit?: number
  }

  /**
   * tipoEquipe upsert
   */
  export type tipoEquipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
    /**
     * The filter to search for the tipoEquipe to update in case it exists.
     */
    where: tipoEquipeWhereUniqueInput
    /**
     * In case the tipoEquipe found by the `where` argument doesn't exist, create a new tipoEquipe with this data.
     */
    create: XOR<tipoEquipeCreateInput, tipoEquipeUncheckedCreateInput>
    /**
     * In case the tipoEquipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipoEquipeUpdateInput, tipoEquipeUncheckedUpdateInput>
  }

  /**
   * tipoEquipe delete
   */
  export type tipoEquipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
    /**
     * Filter which tipoEquipe to delete.
     */
    where: tipoEquipeWhereUniqueInput
  }

  /**
   * tipoEquipe deleteMany
   */
  export type tipoEquipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoEquipes to delete
     */
    where?: tipoEquipeWhereInput
    /**
     * Limit how many tipoEquipes to delete.
     */
    limit?: number
  }

  /**
   * tipoEquipe.equipes
   */
  export type tipoEquipe$equipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    where?: equipeTipoEquipeWhereInput
    orderBy?: equipeTipoEquipeOrderByWithRelationInput | equipeTipoEquipeOrderByWithRelationInput[]
    cursor?: equipeTipoEquipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipeTipoEquipeScalarFieldEnum | EquipeTipoEquipeScalarFieldEnum[]
  }

  /**
   * tipoEquipe without action
   */
  export type tipoEquipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoEquipe
     */
    select?: tipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoEquipe
     */
    omit?: tipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoEquipeInclude<ExtArgs> | null
  }


  /**
   * Model equipe
   */

  export type AggregateEquipe = {
    _count: EquipeCountAggregateOutputType | null
    _avg: EquipeAvgAggregateOutputType | null
    _sum: EquipeSumAggregateOutputType | null
    _min: EquipeMinAggregateOutputType | null
    _max: EquipeMaxAggregateOutputType | null
  }

  export type EquipeAvgAggregateOutputType = {
    id: number | null
  }

  export type EquipeSumAggregateOutputType = {
    id: number | null
  }

  export type EquipeMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type EquipeMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type EquipeCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type EquipeAvgAggregateInputType = {
    id?: true
  }

  export type EquipeSumAggregateInputType = {
    id?: true
  }

  export type EquipeMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type EquipeMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type EquipeCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type EquipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipe to aggregate.
     */
    where?: equipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipes to fetch.
     */
    orderBy?: equipeOrderByWithRelationInput | equipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipes
    **/
    _count?: true | EquipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipeMaxAggregateInputType
  }

  export type GetEquipeAggregateType<T extends EquipeAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipe[P]>
      : GetScalarType<T[P], AggregateEquipe[P]>
  }




  export type equipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipeWhereInput
    orderBy?: equipeOrderByWithAggregationInput | equipeOrderByWithAggregationInput[]
    by: EquipeScalarFieldEnum[] | EquipeScalarFieldEnum
    having?: equipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipeCountAggregateInputType | true
    _avg?: EquipeAvgAggregateInputType
    _sum?: EquipeSumAggregateInputType
    _min?: EquipeMinAggregateInputType
    _max?: EquipeMaxAggregateInputType
  }

  export type EquipeGroupByOutputType = {
    id: number
    descricao: string
    _count: EquipeCountAggregateOutputType | null
    _avg: EquipeAvgAggregateOutputType | null
    _sum: EquipeSumAggregateOutputType | null
    _min: EquipeMinAggregateOutputType | null
    _max: EquipeMaxAggregateOutputType | null
  }

  type GetEquipeGroupByPayload<T extends equipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipeGroupByOutputType[P]>
            : GetScalarType<T[P], EquipeGroupByOutputType[P]>
        }
      >
    >


  export type equipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    regioes?: boolean | equipe$regioesArgs<ExtArgs>
    equipePessoas?: boolean | equipe$equipePessoasArgs<ExtArgs>
    tipos?: boolean | equipe$tiposArgs<ExtArgs>
    _count?: boolean | EquipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipe"]>

  export type equipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["equipe"]>

  export type equipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["equipe"]>

  export type equipeSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type equipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["equipe"]>
  export type equipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regioes?: boolean | equipe$regioesArgs<ExtArgs>
    equipePessoas?: boolean | equipe$equipePessoasArgs<ExtArgs>
    tipos?: boolean | equipe$tiposArgs<ExtArgs>
    _count?: boolean | EquipeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type equipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type equipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $equipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "equipe"
    objects: {
      regioes: Prisma.$equipeRegiaoPayload<ExtArgs>[]
      equipePessoas: Prisma.$equipePessoasPayload<ExtArgs>[]
      tipos: Prisma.$equipeTipoEquipePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["equipe"]>
    composites: {}
  }

  type equipeGetPayload<S extends boolean | null | undefined | equipeDefaultArgs> = $Result.GetResult<Prisma.$equipePayload, S>

  type equipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<equipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipeCountAggregateInputType | true
    }

  export interface equipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipe'], meta: { name: 'equipe' } }
    /**
     * Find zero or one Equipe that matches the filter.
     * @param {equipeFindUniqueArgs} args - Arguments to find a Equipe
     * @example
     * // Get one Equipe
     * const equipe = await prisma.equipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends equipeFindUniqueArgs>(args: SelectSubset<T, equipeFindUniqueArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {equipeFindUniqueOrThrowArgs} args - Arguments to find a Equipe
     * @example
     * // Get one Equipe
     * const equipe = await prisma.equipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends equipeFindUniqueOrThrowArgs>(args: SelectSubset<T, equipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeFindFirstArgs} args - Arguments to find a Equipe
     * @example
     * // Get one Equipe
     * const equipe = await prisma.equipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends equipeFindFirstArgs>(args?: SelectSubset<T, equipeFindFirstArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeFindFirstOrThrowArgs} args - Arguments to find a Equipe
     * @example
     * // Get one Equipe
     * const equipe = await prisma.equipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends equipeFindFirstOrThrowArgs>(args?: SelectSubset<T, equipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipes
     * const equipes = await prisma.equipe.findMany()
     * 
     * // Get first 10 Equipes
     * const equipes = await prisma.equipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipeWithIdOnly = await prisma.equipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends equipeFindManyArgs>(args?: SelectSubset<T, equipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipe.
     * @param {equipeCreateArgs} args - Arguments to create a Equipe.
     * @example
     * // Create one Equipe
     * const Equipe = await prisma.equipe.create({
     *   data: {
     *     // ... data to create a Equipe
     *   }
     * })
     * 
     */
    create<T extends equipeCreateArgs>(args: SelectSubset<T, equipeCreateArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipes.
     * @param {equipeCreateManyArgs} args - Arguments to create many Equipes.
     * @example
     * // Create many Equipes
     * const equipe = await prisma.equipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends equipeCreateManyArgs>(args?: SelectSubset<T, equipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipes and returns the data saved in the database.
     * @param {equipeCreateManyAndReturnArgs} args - Arguments to create many Equipes.
     * @example
     * // Create many Equipes
     * const equipe = await prisma.equipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipes and only return the `id`
     * const equipeWithIdOnly = await prisma.equipe.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends equipeCreateManyAndReturnArgs>(args?: SelectSubset<T, equipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipe.
     * @param {equipeDeleteArgs} args - Arguments to delete one Equipe.
     * @example
     * // Delete one Equipe
     * const Equipe = await prisma.equipe.delete({
     *   where: {
     *     // ... filter to delete one Equipe
     *   }
     * })
     * 
     */
    delete<T extends equipeDeleteArgs>(args: SelectSubset<T, equipeDeleteArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipe.
     * @param {equipeUpdateArgs} args - Arguments to update one Equipe.
     * @example
     * // Update one Equipe
     * const equipe = await prisma.equipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends equipeUpdateArgs>(args: SelectSubset<T, equipeUpdateArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipes.
     * @param {equipeDeleteManyArgs} args - Arguments to filter Equipes to delete.
     * @example
     * // Delete a few Equipes
     * const { count } = await prisma.equipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends equipeDeleteManyArgs>(args?: SelectSubset<T, equipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipes
     * const equipe = await prisma.equipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends equipeUpdateManyArgs>(args: SelectSubset<T, equipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipes and returns the data updated in the database.
     * @param {equipeUpdateManyAndReturnArgs} args - Arguments to update many Equipes.
     * @example
     * // Update many Equipes
     * const equipe = await prisma.equipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipes and only return the `id`
     * const equipeWithIdOnly = await prisma.equipe.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends equipeUpdateManyAndReturnArgs>(args: SelectSubset<T, equipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipe.
     * @param {equipeUpsertArgs} args - Arguments to update or create a Equipe.
     * @example
     * // Update or create a Equipe
     * const equipe = await prisma.equipe.upsert({
     *   create: {
     *     // ... data to create a Equipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipe we want to update
     *   }
     * })
     */
    upsert<T extends equipeUpsertArgs>(args: SelectSubset<T, equipeUpsertArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeCountArgs} args - Arguments to filter Equipes to count.
     * @example
     * // Count the number of Equipes
     * const count = await prisma.equipe.count({
     *   where: {
     *     // ... the filter for the Equipes we want to count
     *   }
     * })
    **/
    count<T extends equipeCountArgs>(
      args?: Subset<T, equipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipeAggregateArgs>(args: Subset<T, EquipeAggregateArgs>): Prisma.PrismaPromise<GetEquipeAggregateType<T>>

    /**
     * Group by Equipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipeGroupByArgs['orderBy'] }
        : { orderBy?: equipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipe model
   */
  readonly fields: equipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__equipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    regioes<T extends equipe$regioesArgs<ExtArgs> = {}>(args?: Subset<T, equipe$regioesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipePessoas<T extends equipe$equipePessoasArgs<ExtArgs> = {}>(args?: Subset<T, equipe$equipePessoasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tipos<T extends equipe$tiposArgs<ExtArgs> = {}>(args?: Subset<T, equipe$tiposArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the equipe model
   */
  interface equipeFieldRefs {
    readonly id: FieldRef<"equipe", 'Int'>
    readonly descricao: FieldRef<"equipe", 'String'>
  }
    

  // Custom InputTypes
  /**
   * equipe findUnique
   */
  export type equipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
    /**
     * Filter, which equipe to fetch.
     */
    where: equipeWhereUniqueInput
  }

  /**
   * equipe findUniqueOrThrow
   */
  export type equipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
    /**
     * Filter, which equipe to fetch.
     */
    where: equipeWhereUniqueInput
  }

  /**
   * equipe findFirst
   */
  export type equipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
    /**
     * Filter, which equipe to fetch.
     */
    where?: equipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipes to fetch.
     */
    orderBy?: equipeOrderByWithRelationInput | equipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipes.
     */
    cursor?: equipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipes.
     */
    distinct?: EquipeScalarFieldEnum | EquipeScalarFieldEnum[]
  }

  /**
   * equipe findFirstOrThrow
   */
  export type equipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
    /**
     * Filter, which equipe to fetch.
     */
    where?: equipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipes to fetch.
     */
    orderBy?: equipeOrderByWithRelationInput | equipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipes.
     */
    cursor?: equipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipes.
     */
    distinct?: EquipeScalarFieldEnum | EquipeScalarFieldEnum[]
  }

  /**
   * equipe findMany
   */
  export type equipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
    /**
     * Filter, which equipes to fetch.
     */
    where?: equipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipes to fetch.
     */
    orderBy?: equipeOrderByWithRelationInput | equipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipes.
     */
    cursor?: equipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipes.
     */
    skip?: number
    distinct?: EquipeScalarFieldEnum | EquipeScalarFieldEnum[]
  }

  /**
   * equipe create
   */
  export type equipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
    /**
     * The data needed to create a equipe.
     */
    data: XOR<equipeCreateInput, equipeUncheckedCreateInput>
  }

  /**
   * equipe createMany
   */
  export type equipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipes.
     */
    data: equipeCreateManyInput | equipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * equipe createManyAndReturn
   */
  export type equipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * The data used to create many equipes.
     */
    data: equipeCreateManyInput | equipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * equipe update
   */
  export type equipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
    /**
     * The data needed to update a equipe.
     */
    data: XOR<equipeUpdateInput, equipeUncheckedUpdateInput>
    /**
     * Choose, which equipe to update.
     */
    where: equipeWhereUniqueInput
  }

  /**
   * equipe updateMany
   */
  export type equipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipes.
     */
    data: XOR<equipeUpdateManyMutationInput, equipeUncheckedUpdateManyInput>
    /**
     * Filter which equipes to update
     */
    where?: equipeWhereInput
    /**
     * Limit how many equipes to update.
     */
    limit?: number
  }

  /**
   * equipe updateManyAndReturn
   */
  export type equipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * The data used to update equipes.
     */
    data: XOR<equipeUpdateManyMutationInput, equipeUncheckedUpdateManyInput>
    /**
     * Filter which equipes to update
     */
    where?: equipeWhereInput
    /**
     * Limit how many equipes to update.
     */
    limit?: number
  }

  /**
   * equipe upsert
   */
  export type equipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
    /**
     * The filter to search for the equipe to update in case it exists.
     */
    where: equipeWhereUniqueInput
    /**
     * In case the equipe found by the `where` argument doesn't exist, create a new equipe with this data.
     */
    create: XOR<equipeCreateInput, equipeUncheckedCreateInput>
    /**
     * In case the equipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipeUpdateInput, equipeUncheckedUpdateInput>
  }

  /**
   * equipe delete
   */
  export type equipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
    /**
     * Filter which equipe to delete.
     */
    where: equipeWhereUniqueInput
  }

  /**
   * equipe deleteMany
   */
  export type equipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipes to delete
     */
    where?: equipeWhereInput
    /**
     * Limit how many equipes to delete.
     */
    limit?: number
  }

  /**
   * equipe.regioes
   */
  export type equipe$regioesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    where?: equipeRegiaoWhereInput
    orderBy?: equipeRegiaoOrderByWithRelationInput | equipeRegiaoOrderByWithRelationInput[]
    cursor?: equipeRegiaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipeRegiaoScalarFieldEnum | EquipeRegiaoScalarFieldEnum[]
  }

  /**
   * equipe.equipePessoas
   */
  export type equipe$equipePessoasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    where?: equipePessoasWhereInput
    orderBy?: equipePessoasOrderByWithRelationInput | equipePessoasOrderByWithRelationInput[]
    cursor?: equipePessoasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipePessoasScalarFieldEnum | EquipePessoasScalarFieldEnum[]
  }

  /**
   * equipe.tipos
   */
  export type equipe$tiposArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    where?: equipeTipoEquipeWhereInput
    orderBy?: equipeTipoEquipeOrderByWithRelationInput | equipeTipoEquipeOrderByWithRelationInput[]
    cursor?: equipeTipoEquipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipeTipoEquipeScalarFieldEnum | EquipeTipoEquipeScalarFieldEnum[]
  }

  /**
   * equipe without action
   */
  export type equipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipe
     */
    select?: equipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipe
     */
    omit?: equipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeInclude<ExtArgs> | null
  }


  /**
   * Model equipeTipoEquipe
   */

  export type AggregateEquipeTipoEquipe = {
    _count: EquipeTipoEquipeCountAggregateOutputType | null
    _avg: EquipeTipoEquipeAvgAggregateOutputType | null
    _sum: EquipeTipoEquipeSumAggregateOutputType | null
    _min: EquipeTipoEquipeMinAggregateOutputType | null
    _max: EquipeTipoEquipeMaxAggregateOutputType | null
  }

  export type EquipeTipoEquipeAvgAggregateOutputType = {
    equipeId: number | null
    tipoEquipeId: number | null
  }

  export type EquipeTipoEquipeSumAggregateOutputType = {
    equipeId: number | null
    tipoEquipeId: number | null
  }

  export type EquipeTipoEquipeMinAggregateOutputType = {
    equipeId: number | null
    tipoEquipeId: number | null
  }

  export type EquipeTipoEquipeMaxAggregateOutputType = {
    equipeId: number | null
    tipoEquipeId: number | null
  }

  export type EquipeTipoEquipeCountAggregateOutputType = {
    equipeId: number
    tipoEquipeId: number
    _all: number
  }


  export type EquipeTipoEquipeAvgAggregateInputType = {
    equipeId?: true
    tipoEquipeId?: true
  }

  export type EquipeTipoEquipeSumAggregateInputType = {
    equipeId?: true
    tipoEquipeId?: true
  }

  export type EquipeTipoEquipeMinAggregateInputType = {
    equipeId?: true
    tipoEquipeId?: true
  }

  export type EquipeTipoEquipeMaxAggregateInputType = {
    equipeId?: true
    tipoEquipeId?: true
  }

  export type EquipeTipoEquipeCountAggregateInputType = {
    equipeId?: true
    tipoEquipeId?: true
    _all?: true
  }

  export type EquipeTipoEquipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipeTipoEquipe to aggregate.
     */
    where?: equipeTipoEquipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipeTipoEquipes to fetch.
     */
    orderBy?: equipeTipoEquipeOrderByWithRelationInput | equipeTipoEquipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipeTipoEquipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipeTipoEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipeTipoEquipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipeTipoEquipes
    **/
    _count?: true | EquipeTipoEquipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipeTipoEquipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipeTipoEquipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipeTipoEquipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipeTipoEquipeMaxAggregateInputType
  }

  export type GetEquipeTipoEquipeAggregateType<T extends EquipeTipoEquipeAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipeTipoEquipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipeTipoEquipe[P]>
      : GetScalarType<T[P], AggregateEquipeTipoEquipe[P]>
  }




  export type equipeTipoEquipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipeTipoEquipeWhereInput
    orderBy?: equipeTipoEquipeOrderByWithAggregationInput | equipeTipoEquipeOrderByWithAggregationInput[]
    by: EquipeTipoEquipeScalarFieldEnum[] | EquipeTipoEquipeScalarFieldEnum
    having?: equipeTipoEquipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipeTipoEquipeCountAggregateInputType | true
    _avg?: EquipeTipoEquipeAvgAggregateInputType
    _sum?: EquipeTipoEquipeSumAggregateInputType
    _min?: EquipeTipoEquipeMinAggregateInputType
    _max?: EquipeTipoEquipeMaxAggregateInputType
  }

  export type EquipeTipoEquipeGroupByOutputType = {
    equipeId: number
    tipoEquipeId: number
    _count: EquipeTipoEquipeCountAggregateOutputType | null
    _avg: EquipeTipoEquipeAvgAggregateOutputType | null
    _sum: EquipeTipoEquipeSumAggregateOutputType | null
    _min: EquipeTipoEquipeMinAggregateOutputType | null
    _max: EquipeTipoEquipeMaxAggregateOutputType | null
  }

  type GetEquipeTipoEquipeGroupByPayload<T extends equipeTipoEquipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipeTipoEquipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipeTipoEquipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipeTipoEquipeGroupByOutputType[P]>
            : GetScalarType<T[P], EquipeTipoEquipeGroupByOutputType[P]>
        }
      >
    >


  export type equipeTipoEquipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeId?: boolean
    tipoEquipeId?: boolean
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    tipoEquipe?: boolean | tipoEquipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeTipoEquipe"]>

  export type equipeTipoEquipeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeId?: boolean
    tipoEquipeId?: boolean
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    tipoEquipe?: boolean | tipoEquipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeTipoEquipe"]>

  export type equipeTipoEquipeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeId?: boolean
    tipoEquipeId?: boolean
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    tipoEquipe?: boolean | tipoEquipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeTipoEquipe"]>

  export type equipeTipoEquipeSelectScalar = {
    equipeId?: boolean
    tipoEquipeId?: boolean
  }

  export type equipeTipoEquipeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"equipeId" | "tipoEquipeId", ExtArgs["result"]["equipeTipoEquipe"]>
  export type equipeTipoEquipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    tipoEquipe?: boolean | tipoEquipeDefaultArgs<ExtArgs>
  }
  export type equipeTipoEquipeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    tipoEquipe?: boolean | tipoEquipeDefaultArgs<ExtArgs>
  }
  export type equipeTipoEquipeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    tipoEquipe?: boolean | tipoEquipeDefaultArgs<ExtArgs>
  }

  export type $equipeTipoEquipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "equipeTipoEquipe"
    objects: {
      equipe: Prisma.$equipePayload<ExtArgs>
      tipoEquipe: Prisma.$tipoEquipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      equipeId: number
      tipoEquipeId: number
    }, ExtArgs["result"]["equipeTipoEquipe"]>
    composites: {}
  }

  type equipeTipoEquipeGetPayload<S extends boolean | null | undefined | equipeTipoEquipeDefaultArgs> = $Result.GetResult<Prisma.$equipeTipoEquipePayload, S>

  type equipeTipoEquipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<equipeTipoEquipeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipeTipoEquipeCountAggregateInputType | true
    }

  export interface equipeTipoEquipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipeTipoEquipe'], meta: { name: 'equipeTipoEquipe' } }
    /**
     * Find zero or one EquipeTipoEquipe that matches the filter.
     * @param {equipeTipoEquipeFindUniqueArgs} args - Arguments to find a EquipeTipoEquipe
     * @example
     * // Get one EquipeTipoEquipe
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends equipeTipoEquipeFindUniqueArgs>(args: SelectSubset<T, equipeTipoEquipeFindUniqueArgs<ExtArgs>>): Prisma__equipeTipoEquipeClient<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipeTipoEquipe that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {equipeTipoEquipeFindUniqueOrThrowArgs} args - Arguments to find a EquipeTipoEquipe
     * @example
     * // Get one EquipeTipoEquipe
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends equipeTipoEquipeFindUniqueOrThrowArgs>(args: SelectSubset<T, equipeTipoEquipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__equipeTipoEquipeClient<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipeTipoEquipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeTipoEquipeFindFirstArgs} args - Arguments to find a EquipeTipoEquipe
     * @example
     * // Get one EquipeTipoEquipe
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends equipeTipoEquipeFindFirstArgs>(args?: SelectSubset<T, equipeTipoEquipeFindFirstArgs<ExtArgs>>): Prisma__equipeTipoEquipeClient<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipeTipoEquipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeTipoEquipeFindFirstOrThrowArgs} args - Arguments to find a EquipeTipoEquipe
     * @example
     * // Get one EquipeTipoEquipe
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends equipeTipoEquipeFindFirstOrThrowArgs>(args?: SelectSubset<T, equipeTipoEquipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__equipeTipoEquipeClient<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipeTipoEquipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeTipoEquipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipeTipoEquipes
     * const equipeTipoEquipes = await prisma.equipeTipoEquipe.findMany()
     * 
     * // Get first 10 EquipeTipoEquipes
     * const equipeTipoEquipes = await prisma.equipeTipoEquipe.findMany({ take: 10 })
     * 
     * // Only select the `equipeId`
     * const equipeTipoEquipeWithEquipeIdOnly = await prisma.equipeTipoEquipe.findMany({ select: { equipeId: true } })
     * 
     */
    findMany<T extends equipeTipoEquipeFindManyArgs>(args?: SelectSubset<T, equipeTipoEquipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipeTipoEquipe.
     * @param {equipeTipoEquipeCreateArgs} args - Arguments to create a EquipeTipoEquipe.
     * @example
     * // Create one EquipeTipoEquipe
     * const EquipeTipoEquipe = await prisma.equipeTipoEquipe.create({
     *   data: {
     *     // ... data to create a EquipeTipoEquipe
     *   }
     * })
     * 
     */
    create<T extends equipeTipoEquipeCreateArgs>(args: SelectSubset<T, equipeTipoEquipeCreateArgs<ExtArgs>>): Prisma__equipeTipoEquipeClient<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipeTipoEquipes.
     * @param {equipeTipoEquipeCreateManyArgs} args - Arguments to create many EquipeTipoEquipes.
     * @example
     * // Create many EquipeTipoEquipes
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends equipeTipoEquipeCreateManyArgs>(args?: SelectSubset<T, equipeTipoEquipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipeTipoEquipes and returns the data saved in the database.
     * @param {equipeTipoEquipeCreateManyAndReturnArgs} args - Arguments to create many EquipeTipoEquipes.
     * @example
     * // Create many EquipeTipoEquipes
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipeTipoEquipes and only return the `equipeId`
     * const equipeTipoEquipeWithEquipeIdOnly = await prisma.equipeTipoEquipe.createManyAndReturn({
     *   select: { equipeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends equipeTipoEquipeCreateManyAndReturnArgs>(args?: SelectSubset<T, equipeTipoEquipeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipeTipoEquipe.
     * @param {equipeTipoEquipeDeleteArgs} args - Arguments to delete one EquipeTipoEquipe.
     * @example
     * // Delete one EquipeTipoEquipe
     * const EquipeTipoEquipe = await prisma.equipeTipoEquipe.delete({
     *   where: {
     *     // ... filter to delete one EquipeTipoEquipe
     *   }
     * })
     * 
     */
    delete<T extends equipeTipoEquipeDeleteArgs>(args: SelectSubset<T, equipeTipoEquipeDeleteArgs<ExtArgs>>): Prisma__equipeTipoEquipeClient<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipeTipoEquipe.
     * @param {equipeTipoEquipeUpdateArgs} args - Arguments to update one EquipeTipoEquipe.
     * @example
     * // Update one EquipeTipoEquipe
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends equipeTipoEquipeUpdateArgs>(args: SelectSubset<T, equipeTipoEquipeUpdateArgs<ExtArgs>>): Prisma__equipeTipoEquipeClient<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipeTipoEquipes.
     * @param {equipeTipoEquipeDeleteManyArgs} args - Arguments to filter EquipeTipoEquipes to delete.
     * @example
     * // Delete a few EquipeTipoEquipes
     * const { count } = await prisma.equipeTipoEquipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends equipeTipoEquipeDeleteManyArgs>(args?: SelectSubset<T, equipeTipoEquipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipeTipoEquipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeTipoEquipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipeTipoEquipes
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends equipeTipoEquipeUpdateManyArgs>(args: SelectSubset<T, equipeTipoEquipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipeTipoEquipes and returns the data updated in the database.
     * @param {equipeTipoEquipeUpdateManyAndReturnArgs} args - Arguments to update many EquipeTipoEquipes.
     * @example
     * // Update many EquipeTipoEquipes
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipeTipoEquipes and only return the `equipeId`
     * const equipeTipoEquipeWithEquipeIdOnly = await prisma.equipeTipoEquipe.updateManyAndReturn({
     *   select: { equipeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends equipeTipoEquipeUpdateManyAndReturnArgs>(args: SelectSubset<T, equipeTipoEquipeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipeTipoEquipe.
     * @param {equipeTipoEquipeUpsertArgs} args - Arguments to update or create a EquipeTipoEquipe.
     * @example
     * // Update or create a EquipeTipoEquipe
     * const equipeTipoEquipe = await prisma.equipeTipoEquipe.upsert({
     *   create: {
     *     // ... data to create a EquipeTipoEquipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipeTipoEquipe we want to update
     *   }
     * })
     */
    upsert<T extends equipeTipoEquipeUpsertArgs>(args: SelectSubset<T, equipeTipoEquipeUpsertArgs<ExtArgs>>): Prisma__equipeTipoEquipeClient<$Result.GetResult<Prisma.$equipeTipoEquipePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipeTipoEquipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeTipoEquipeCountArgs} args - Arguments to filter EquipeTipoEquipes to count.
     * @example
     * // Count the number of EquipeTipoEquipes
     * const count = await prisma.equipeTipoEquipe.count({
     *   where: {
     *     // ... the filter for the EquipeTipoEquipes we want to count
     *   }
     * })
    **/
    count<T extends equipeTipoEquipeCountArgs>(
      args?: Subset<T, equipeTipoEquipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipeTipoEquipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipeTipoEquipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeTipoEquipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipeTipoEquipeAggregateArgs>(args: Subset<T, EquipeTipoEquipeAggregateArgs>): Prisma.PrismaPromise<GetEquipeTipoEquipeAggregateType<T>>

    /**
     * Group by EquipeTipoEquipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeTipoEquipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipeTipoEquipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipeTipoEquipeGroupByArgs['orderBy'] }
        : { orderBy?: equipeTipoEquipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipeTipoEquipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipeTipoEquipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipeTipoEquipe model
   */
  readonly fields: equipeTipoEquipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipeTipoEquipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__equipeTipoEquipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipe<T extends equipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, equipeDefaultArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tipoEquipe<T extends tipoEquipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipoEquipeDefaultArgs<ExtArgs>>): Prisma__tipoEquipeClient<$Result.GetResult<Prisma.$tipoEquipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the equipeTipoEquipe model
   */
  interface equipeTipoEquipeFieldRefs {
    readonly equipeId: FieldRef<"equipeTipoEquipe", 'Int'>
    readonly tipoEquipeId: FieldRef<"equipeTipoEquipe", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * equipeTipoEquipe findUnique
   */
  export type equipeTipoEquipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which equipeTipoEquipe to fetch.
     */
    where: equipeTipoEquipeWhereUniqueInput
  }

  /**
   * equipeTipoEquipe findUniqueOrThrow
   */
  export type equipeTipoEquipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which equipeTipoEquipe to fetch.
     */
    where: equipeTipoEquipeWhereUniqueInput
  }

  /**
   * equipeTipoEquipe findFirst
   */
  export type equipeTipoEquipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which equipeTipoEquipe to fetch.
     */
    where?: equipeTipoEquipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipeTipoEquipes to fetch.
     */
    orderBy?: equipeTipoEquipeOrderByWithRelationInput | equipeTipoEquipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipeTipoEquipes.
     */
    cursor?: equipeTipoEquipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipeTipoEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipeTipoEquipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipeTipoEquipes.
     */
    distinct?: EquipeTipoEquipeScalarFieldEnum | EquipeTipoEquipeScalarFieldEnum[]
  }

  /**
   * equipeTipoEquipe findFirstOrThrow
   */
  export type equipeTipoEquipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which equipeTipoEquipe to fetch.
     */
    where?: equipeTipoEquipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipeTipoEquipes to fetch.
     */
    orderBy?: equipeTipoEquipeOrderByWithRelationInput | equipeTipoEquipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipeTipoEquipes.
     */
    cursor?: equipeTipoEquipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipeTipoEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipeTipoEquipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipeTipoEquipes.
     */
    distinct?: EquipeTipoEquipeScalarFieldEnum | EquipeTipoEquipeScalarFieldEnum[]
  }

  /**
   * equipeTipoEquipe findMany
   */
  export type equipeTipoEquipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    /**
     * Filter, which equipeTipoEquipes to fetch.
     */
    where?: equipeTipoEquipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipeTipoEquipes to fetch.
     */
    orderBy?: equipeTipoEquipeOrderByWithRelationInput | equipeTipoEquipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipeTipoEquipes.
     */
    cursor?: equipeTipoEquipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipeTipoEquipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipeTipoEquipes.
     */
    skip?: number
    distinct?: EquipeTipoEquipeScalarFieldEnum | EquipeTipoEquipeScalarFieldEnum[]
  }

  /**
   * equipeTipoEquipe create
   */
  export type equipeTipoEquipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    /**
     * The data needed to create a equipeTipoEquipe.
     */
    data: XOR<equipeTipoEquipeCreateInput, equipeTipoEquipeUncheckedCreateInput>
  }

  /**
   * equipeTipoEquipe createMany
   */
  export type equipeTipoEquipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipeTipoEquipes.
     */
    data: equipeTipoEquipeCreateManyInput | equipeTipoEquipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * equipeTipoEquipe createManyAndReturn
   */
  export type equipeTipoEquipeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * The data used to create many equipeTipoEquipes.
     */
    data: equipeTipoEquipeCreateManyInput | equipeTipoEquipeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * equipeTipoEquipe update
   */
  export type equipeTipoEquipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    /**
     * The data needed to update a equipeTipoEquipe.
     */
    data: XOR<equipeTipoEquipeUpdateInput, equipeTipoEquipeUncheckedUpdateInput>
    /**
     * Choose, which equipeTipoEquipe to update.
     */
    where: equipeTipoEquipeWhereUniqueInput
  }

  /**
   * equipeTipoEquipe updateMany
   */
  export type equipeTipoEquipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipeTipoEquipes.
     */
    data: XOR<equipeTipoEquipeUpdateManyMutationInput, equipeTipoEquipeUncheckedUpdateManyInput>
    /**
     * Filter which equipeTipoEquipes to update
     */
    where?: equipeTipoEquipeWhereInput
    /**
     * Limit how many equipeTipoEquipes to update.
     */
    limit?: number
  }

  /**
   * equipeTipoEquipe updateManyAndReturn
   */
  export type equipeTipoEquipeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * The data used to update equipeTipoEquipes.
     */
    data: XOR<equipeTipoEquipeUpdateManyMutationInput, equipeTipoEquipeUncheckedUpdateManyInput>
    /**
     * Filter which equipeTipoEquipes to update
     */
    where?: equipeTipoEquipeWhereInput
    /**
     * Limit how many equipeTipoEquipes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * equipeTipoEquipe upsert
   */
  export type equipeTipoEquipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    /**
     * The filter to search for the equipeTipoEquipe to update in case it exists.
     */
    where: equipeTipoEquipeWhereUniqueInput
    /**
     * In case the equipeTipoEquipe found by the `where` argument doesn't exist, create a new equipeTipoEquipe with this data.
     */
    create: XOR<equipeTipoEquipeCreateInput, equipeTipoEquipeUncheckedCreateInput>
    /**
     * In case the equipeTipoEquipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipeTipoEquipeUpdateInput, equipeTipoEquipeUncheckedUpdateInput>
  }

  /**
   * equipeTipoEquipe delete
   */
  export type equipeTipoEquipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
    /**
     * Filter which equipeTipoEquipe to delete.
     */
    where: equipeTipoEquipeWhereUniqueInput
  }

  /**
   * equipeTipoEquipe deleteMany
   */
  export type equipeTipoEquipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipeTipoEquipes to delete
     */
    where?: equipeTipoEquipeWhereInput
    /**
     * Limit how many equipeTipoEquipes to delete.
     */
    limit?: number
  }

  /**
   * equipeTipoEquipe without action
   */
  export type equipeTipoEquipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeTipoEquipe
     */
    select?: equipeTipoEquipeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeTipoEquipe
     */
    omit?: equipeTipoEquipeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeTipoEquipeInclude<ExtArgs> | null
  }


  /**
   * Model equipeRegiao
   */

  export type AggregateEquipeRegiao = {
    _count: EquipeRegiaoCountAggregateOutputType | null
    _avg: EquipeRegiaoAvgAggregateOutputType | null
    _sum: EquipeRegiaoSumAggregateOutputType | null
    _min: EquipeRegiaoMinAggregateOutputType | null
    _max: EquipeRegiaoMaxAggregateOutputType | null
  }

  export type EquipeRegiaoAvgAggregateOutputType = {
    equipeId: number | null
    regiaoId: number | null
  }

  export type EquipeRegiaoSumAggregateOutputType = {
    equipeId: number | null
    regiaoId: number | null
  }

  export type EquipeRegiaoMinAggregateOutputType = {
    equipeId: number | null
    regiaoId: number | null
  }

  export type EquipeRegiaoMaxAggregateOutputType = {
    equipeId: number | null
    regiaoId: number | null
  }

  export type EquipeRegiaoCountAggregateOutputType = {
    equipeId: number
    regiaoId: number
    _all: number
  }


  export type EquipeRegiaoAvgAggregateInputType = {
    equipeId?: true
    regiaoId?: true
  }

  export type EquipeRegiaoSumAggregateInputType = {
    equipeId?: true
    regiaoId?: true
  }

  export type EquipeRegiaoMinAggregateInputType = {
    equipeId?: true
    regiaoId?: true
  }

  export type EquipeRegiaoMaxAggregateInputType = {
    equipeId?: true
    regiaoId?: true
  }

  export type EquipeRegiaoCountAggregateInputType = {
    equipeId?: true
    regiaoId?: true
    _all?: true
  }

  export type EquipeRegiaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipeRegiao to aggregate.
     */
    where?: equipeRegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipeRegiaos to fetch.
     */
    orderBy?: equipeRegiaoOrderByWithRelationInput | equipeRegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipeRegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipeRegiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipeRegiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipeRegiaos
    **/
    _count?: true | EquipeRegiaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipeRegiaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipeRegiaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipeRegiaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipeRegiaoMaxAggregateInputType
  }

  export type GetEquipeRegiaoAggregateType<T extends EquipeRegiaoAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipeRegiao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipeRegiao[P]>
      : GetScalarType<T[P], AggregateEquipeRegiao[P]>
  }




  export type equipeRegiaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipeRegiaoWhereInput
    orderBy?: equipeRegiaoOrderByWithAggregationInput | equipeRegiaoOrderByWithAggregationInput[]
    by: EquipeRegiaoScalarFieldEnum[] | EquipeRegiaoScalarFieldEnum
    having?: equipeRegiaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipeRegiaoCountAggregateInputType | true
    _avg?: EquipeRegiaoAvgAggregateInputType
    _sum?: EquipeRegiaoSumAggregateInputType
    _min?: EquipeRegiaoMinAggregateInputType
    _max?: EquipeRegiaoMaxAggregateInputType
  }

  export type EquipeRegiaoGroupByOutputType = {
    equipeId: number
    regiaoId: number
    _count: EquipeRegiaoCountAggregateOutputType | null
    _avg: EquipeRegiaoAvgAggregateOutputType | null
    _sum: EquipeRegiaoSumAggregateOutputType | null
    _min: EquipeRegiaoMinAggregateOutputType | null
    _max: EquipeRegiaoMaxAggregateOutputType | null
  }

  type GetEquipeRegiaoGroupByPayload<T extends equipeRegiaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipeRegiaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipeRegiaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipeRegiaoGroupByOutputType[P]>
            : GetScalarType<T[P], EquipeRegiaoGroupByOutputType[P]>
        }
      >
    >


  export type equipeRegiaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeId?: boolean
    regiaoId?: boolean
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeRegiao"]>

  export type equipeRegiaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeId?: boolean
    regiaoId?: boolean
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeRegiao"]>

  export type equipeRegiaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeId?: boolean
    regiaoId?: boolean
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipeRegiao"]>

  export type equipeRegiaoSelectScalar = {
    equipeId?: boolean
    regiaoId?: boolean
  }

  export type equipeRegiaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"equipeId" | "regiaoId", ExtArgs["result"]["equipeRegiao"]>
  export type equipeRegiaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }
  export type equipeRegiaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }
  export type equipeRegiaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }

  export type $equipeRegiaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "equipeRegiao"
    objects: {
      equipe: Prisma.$equipePayload<ExtArgs>
      regiao: Prisma.$regiaoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      equipeId: number
      regiaoId: number
    }, ExtArgs["result"]["equipeRegiao"]>
    composites: {}
  }

  type equipeRegiaoGetPayload<S extends boolean | null | undefined | equipeRegiaoDefaultArgs> = $Result.GetResult<Prisma.$equipeRegiaoPayload, S>

  type equipeRegiaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<equipeRegiaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipeRegiaoCountAggregateInputType | true
    }

  export interface equipeRegiaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipeRegiao'], meta: { name: 'equipeRegiao' } }
    /**
     * Find zero or one EquipeRegiao that matches the filter.
     * @param {equipeRegiaoFindUniqueArgs} args - Arguments to find a EquipeRegiao
     * @example
     * // Get one EquipeRegiao
     * const equipeRegiao = await prisma.equipeRegiao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends equipeRegiaoFindUniqueArgs>(args: SelectSubset<T, equipeRegiaoFindUniqueArgs<ExtArgs>>): Prisma__equipeRegiaoClient<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipeRegiao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {equipeRegiaoFindUniqueOrThrowArgs} args - Arguments to find a EquipeRegiao
     * @example
     * // Get one EquipeRegiao
     * const equipeRegiao = await prisma.equipeRegiao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends equipeRegiaoFindUniqueOrThrowArgs>(args: SelectSubset<T, equipeRegiaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__equipeRegiaoClient<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipeRegiao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeRegiaoFindFirstArgs} args - Arguments to find a EquipeRegiao
     * @example
     * // Get one EquipeRegiao
     * const equipeRegiao = await prisma.equipeRegiao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends equipeRegiaoFindFirstArgs>(args?: SelectSubset<T, equipeRegiaoFindFirstArgs<ExtArgs>>): Prisma__equipeRegiaoClient<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipeRegiao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeRegiaoFindFirstOrThrowArgs} args - Arguments to find a EquipeRegiao
     * @example
     * // Get one EquipeRegiao
     * const equipeRegiao = await prisma.equipeRegiao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends equipeRegiaoFindFirstOrThrowArgs>(args?: SelectSubset<T, equipeRegiaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__equipeRegiaoClient<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipeRegiaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeRegiaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipeRegiaos
     * const equipeRegiaos = await prisma.equipeRegiao.findMany()
     * 
     * // Get first 10 EquipeRegiaos
     * const equipeRegiaos = await prisma.equipeRegiao.findMany({ take: 10 })
     * 
     * // Only select the `equipeId`
     * const equipeRegiaoWithEquipeIdOnly = await prisma.equipeRegiao.findMany({ select: { equipeId: true } })
     * 
     */
    findMany<T extends equipeRegiaoFindManyArgs>(args?: SelectSubset<T, equipeRegiaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipeRegiao.
     * @param {equipeRegiaoCreateArgs} args - Arguments to create a EquipeRegiao.
     * @example
     * // Create one EquipeRegiao
     * const EquipeRegiao = await prisma.equipeRegiao.create({
     *   data: {
     *     // ... data to create a EquipeRegiao
     *   }
     * })
     * 
     */
    create<T extends equipeRegiaoCreateArgs>(args: SelectSubset<T, equipeRegiaoCreateArgs<ExtArgs>>): Prisma__equipeRegiaoClient<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipeRegiaos.
     * @param {equipeRegiaoCreateManyArgs} args - Arguments to create many EquipeRegiaos.
     * @example
     * // Create many EquipeRegiaos
     * const equipeRegiao = await prisma.equipeRegiao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends equipeRegiaoCreateManyArgs>(args?: SelectSubset<T, equipeRegiaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipeRegiaos and returns the data saved in the database.
     * @param {equipeRegiaoCreateManyAndReturnArgs} args - Arguments to create many EquipeRegiaos.
     * @example
     * // Create many EquipeRegiaos
     * const equipeRegiao = await prisma.equipeRegiao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipeRegiaos and only return the `equipeId`
     * const equipeRegiaoWithEquipeIdOnly = await prisma.equipeRegiao.createManyAndReturn({
     *   select: { equipeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends equipeRegiaoCreateManyAndReturnArgs>(args?: SelectSubset<T, equipeRegiaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipeRegiao.
     * @param {equipeRegiaoDeleteArgs} args - Arguments to delete one EquipeRegiao.
     * @example
     * // Delete one EquipeRegiao
     * const EquipeRegiao = await prisma.equipeRegiao.delete({
     *   where: {
     *     // ... filter to delete one EquipeRegiao
     *   }
     * })
     * 
     */
    delete<T extends equipeRegiaoDeleteArgs>(args: SelectSubset<T, equipeRegiaoDeleteArgs<ExtArgs>>): Prisma__equipeRegiaoClient<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipeRegiao.
     * @param {equipeRegiaoUpdateArgs} args - Arguments to update one EquipeRegiao.
     * @example
     * // Update one EquipeRegiao
     * const equipeRegiao = await prisma.equipeRegiao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends equipeRegiaoUpdateArgs>(args: SelectSubset<T, equipeRegiaoUpdateArgs<ExtArgs>>): Prisma__equipeRegiaoClient<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipeRegiaos.
     * @param {equipeRegiaoDeleteManyArgs} args - Arguments to filter EquipeRegiaos to delete.
     * @example
     * // Delete a few EquipeRegiaos
     * const { count } = await prisma.equipeRegiao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends equipeRegiaoDeleteManyArgs>(args?: SelectSubset<T, equipeRegiaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipeRegiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeRegiaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipeRegiaos
     * const equipeRegiao = await prisma.equipeRegiao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends equipeRegiaoUpdateManyArgs>(args: SelectSubset<T, equipeRegiaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipeRegiaos and returns the data updated in the database.
     * @param {equipeRegiaoUpdateManyAndReturnArgs} args - Arguments to update many EquipeRegiaos.
     * @example
     * // Update many EquipeRegiaos
     * const equipeRegiao = await prisma.equipeRegiao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipeRegiaos and only return the `equipeId`
     * const equipeRegiaoWithEquipeIdOnly = await prisma.equipeRegiao.updateManyAndReturn({
     *   select: { equipeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends equipeRegiaoUpdateManyAndReturnArgs>(args: SelectSubset<T, equipeRegiaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipeRegiao.
     * @param {equipeRegiaoUpsertArgs} args - Arguments to update or create a EquipeRegiao.
     * @example
     * // Update or create a EquipeRegiao
     * const equipeRegiao = await prisma.equipeRegiao.upsert({
     *   create: {
     *     // ... data to create a EquipeRegiao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipeRegiao we want to update
     *   }
     * })
     */
    upsert<T extends equipeRegiaoUpsertArgs>(args: SelectSubset<T, equipeRegiaoUpsertArgs<ExtArgs>>): Prisma__equipeRegiaoClient<$Result.GetResult<Prisma.$equipeRegiaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipeRegiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeRegiaoCountArgs} args - Arguments to filter EquipeRegiaos to count.
     * @example
     * // Count the number of EquipeRegiaos
     * const count = await prisma.equipeRegiao.count({
     *   where: {
     *     // ... the filter for the EquipeRegiaos we want to count
     *   }
     * })
    **/
    count<T extends equipeRegiaoCountArgs>(
      args?: Subset<T, equipeRegiaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipeRegiaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipeRegiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipeRegiaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipeRegiaoAggregateArgs>(args: Subset<T, EquipeRegiaoAggregateArgs>): Prisma.PrismaPromise<GetEquipeRegiaoAggregateType<T>>

    /**
     * Group by EquipeRegiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipeRegiaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipeRegiaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipeRegiaoGroupByArgs['orderBy'] }
        : { orderBy?: equipeRegiaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipeRegiaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipeRegiaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipeRegiao model
   */
  readonly fields: equipeRegiaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipeRegiao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__equipeRegiaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipe<T extends equipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, equipeDefaultArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    regiao<T extends regiaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, regiaoDefaultArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the equipeRegiao model
   */
  interface equipeRegiaoFieldRefs {
    readonly equipeId: FieldRef<"equipeRegiao", 'Int'>
    readonly regiaoId: FieldRef<"equipeRegiao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * equipeRegiao findUnique
   */
  export type equipeRegiaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which equipeRegiao to fetch.
     */
    where: equipeRegiaoWhereUniqueInput
  }

  /**
   * equipeRegiao findUniqueOrThrow
   */
  export type equipeRegiaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which equipeRegiao to fetch.
     */
    where: equipeRegiaoWhereUniqueInput
  }

  /**
   * equipeRegiao findFirst
   */
  export type equipeRegiaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which equipeRegiao to fetch.
     */
    where?: equipeRegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipeRegiaos to fetch.
     */
    orderBy?: equipeRegiaoOrderByWithRelationInput | equipeRegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipeRegiaos.
     */
    cursor?: equipeRegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipeRegiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipeRegiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipeRegiaos.
     */
    distinct?: EquipeRegiaoScalarFieldEnum | EquipeRegiaoScalarFieldEnum[]
  }

  /**
   * equipeRegiao findFirstOrThrow
   */
  export type equipeRegiaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which equipeRegiao to fetch.
     */
    where?: equipeRegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipeRegiaos to fetch.
     */
    orderBy?: equipeRegiaoOrderByWithRelationInput | equipeRegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipeRegiaos.
     */
    cursor?: equipeRegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipeRegiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipeRegiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipeRegiaos.
     */
    distinct?: EquipeRegiaoScalarFieldEnum | EquipeRegiaoScalarFieldEnum[]
  }

  /**
   * equipeRegiao findMany
   */
  export type equipeRegiaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which equipeRegiaos to fetch.
     */
    where?: equipeRegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipeRegiaos to fetch.
     */
    orderBy?: equipeRegiaoOrderByWithRelationInput | equipeRegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipeRegiaos.
     */
    cursor?: equipeRegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipeRegiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipeRegiaos.
     */
    skip?: number
    distinct?: EquipeRegiaoScalarFieldEnum | EquipeRegiaoScalarFieldEnum[]
  }

  /**
   * equipeRegiao create
   */
  export type equipeRegiaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    /**
     * The data needed to create a equipeRegiao.
     */
    data: XOR<equipeRegiaoCreateInput, equipeRegiaoUncheckedCreateInput>
  }

  /**
   * equipeRegiao createMany
   */
  export type equipeRegiaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipeRegiaos.
     */
    data: equipeRegiaoCreateManyInput | equipeRegiaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * equipeRegiao createManyAndReturn
   */
  export type equipeRegiaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * The data used to create many equipeRegiaos.
     */
    data: equipeRegiaoCreateManyInput | equipeRegiaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * equipeRegiao update
   */
  export type equipeRegiaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    /**
     * The data needed to update a equipeRegiao.
     */
    data: XOR<equipeRegiaoUpdateInput, equipeRegiaoUncheckedUpdateInput>
    /**
     * Choose, which equipeRegiao to update.
     */
    where: equipeRegiaoWhereUniqueInput
  }

  /**
   * equipeRegiao updateMany
   */
  export type equipeRegiaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipeRegiaos.
     */
    data: XOR<equipeRegiaoUpdateManyMutationInput, equipeRegiaoUncheckedUpdateManyInput>
    /**
     * Filter which equipeRegiaos to update
     */
    where?: equipeRegiaoWhereInput
    /**
     * Limit how many equipeRegiaos to update.
     */
    limit?: number
  }

  /**
   * equipeRegiao updateManyAndReturn
   */
  export type equipeRegiaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * The data used to update equipeRegiaos.
     */
    data: XOR<equipeRegiaoUpdateManyMutationInput, equipeRegiaoUncheckedUpdateManyInput>
    /**
     * Filter which equipeRegiaos to update
     */
    where?: equipeRegiaoWhereInput
    /**
     * Limit how many equipeRegiaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * equipeRegiao upsert
   */
  export type equipeRegiaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    /**
     * The filter to search for the equipeRegiao to update in case it exists.
     */
    where: equipeRegiaoWhereUniqueInput
    /**
     * In case the equipeRegiao found by the `where` argument doesn't exist, create a new equipeRegiao with this data.
     */
    create: XOR<equipeRegiaoCreateInput, equipeRegiaoUncheckedCreateInput>
    /**
     * In case the equipeRegiao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipeRegiaoUpdateInput, equipeRegiaoUncheckedUpdateInput>
  }

  /**
   * equipeRegiao delete
   */
  export type equipeRegiaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
    /**
     * Filter which equipeRegiao to delete.
     */
    where: equipeRegiaoWhereUniqueInput
  }

  /**
   * equipeRegiao deleteMany
   */
  export type equipeRegiaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipeRegiaos to delete
     */
    where?: equipeRegiaoWhereInput
    /**
     * Limit how many equipeRegiaos to delete.
     */
    limit?: number
  }

  /**
   * equipeRegiao without action
   */
  export type equipeRegiaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipeRegiao
     */
    select?: equipeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipeRegiao
     */
    omit?: equipeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipeRegiaoInclude<ExtArgs> | null
  }


  /**
   * Model equipePessoas
   */

  export type AggregateEquipePessoas = {
    _count: EquipePessoasCountAggregateOutputType | null
    _avg: EquipePessoasAvgAggregateOutputType | null
    _sum: EquipePessoasSumAggregateOutputType | null
    _min: EquipePessoasMinAggregateOutputType | null
    _max: EquipePessoasMaxAggregateOutputType | null
  }

  export type EquipePessoasAvgAggregateOutputType = {
    equipeId: number | null
    pessoaId: number | null
  }

  export type EquipePessoasSumAggregateOutputType = {
    equipeId: number | null
    pessoaId: number | null
  }

  export type EquipePessoasMinAggregateOutputType = {
    equipeId: number | null
    pessoaId: number | null
  }

  export type EquipePessoasMaxAggregateOutputType = {
    equipeId: number | null
    pessoaId: number | null
  }

  export type EquipePessoasCountAggregateOutputType = {
    equipeId: number
    pessoaId: number
    _all: number
  }


  export type EquipePessoasAvgAggregateInputType = {
    equipeId?: true
    pessoaId?: true
  }

  export type EquipePessoasSumAggregateInputType = {
    equipeId?: true
    pessoaId?: true
  }

  export type EquipePessoasMinAggregateInputType = {
    equipeId?: true
    pessoaId?: true
  }

  export type EquipePessoasMaxAggregateInputType = {
    equipeId?: true
    pessoaId?: true
  }

  export type EquipePessoasCountAggregateInputType = {
    equipeId?: true
    pessoaId?: true
    _all?: true
  }

  export type EquipePessoasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipePessoas to aggregate.
     */
    where?: equipePessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipePessoas to fetch.
     */
    orderBy?: equipePessoasOrderByWithRelationInput | equipePessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: equipePessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipePessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipePessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned equipePessoas
    **/
    _count?: true | EquipePessoasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipePessoasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipePessoasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipePessoasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipePessoasMaxAggregateInputType
  }

  export type GetEquipePessoasAggregateType<T extends EquipePessoasAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipePessoas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipePessoas[P]>
      : GetScalarType<T[P], AggregateEquipePessoas[P]>
  }




  export type equipePessoasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: equipePessoasWhereInput
    orderBy?: equipePessoasOrderByWithAggregationInput | equipePessoasOrderByWithAggregationInput[]
    by: EquipePessoasScalarFieldEnum[] | EquipePessoasScalarFieldEnum
    having?: equipePessoasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipePessoasCountAggregateInputType | true
    _avg?: EquipePessoasAvgAggregateInputType
    _sum?: EquipePessoasSumAggregateInputType
    _min?: EquipePessoasMinAggregateInputType
    _max?: EquipePessoasMaxAggregateInputType
  }

  export type EquipePessoasGroupByOutputType = {
    equipeId: number
    pessoaId: number
    _count: EquipePessoasCountAggregateOutputType | null
    _avg: EquipePessoasAvgAggregateOutputType | null
    _sum: EquipePessoasSumAggregateOutputType | null
    _min: EquipePessoasMinAggregateOutputType | null
    _max: EquipePessoasMaxAggregateOutputType | null
  }

  type GetEquipePessoasGroupByPayload<T extends equipePessoasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipePessoasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipePessoasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipePessoasGroupByOutputType[P]>
            : GetScalarType<T[P], EquipePessoasGroupByOutputType[P]>
        }
      >
    >


  export type equipePessoasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeId?: boolean
    pessoaId?: boolean
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipePessoas"]>

  export type equipePessoasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeId?: boolean
    pessoaId?: boolean
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipePessoas"]>

  export type equipePessoasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    equipeId?: boolean
    pessoaId?: boolean
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipePessoas"]>

  export type equipePessoasSelectScalar = {
    equipeId?: boolean
    pessoaId?: boolean
  }

  export type equipePessoasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"equipeId" | "pessoaId", ExtArgs["result"]["equipePessoas"]>
  export type equipePessoasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type equipePessoasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }
  export type equipePessoasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    equipe?: boolean | equipeDefaultArgs<ExtArgs>
    pessoa?: boolean | pessoaDefaultArgs<ExtArgs>
  }

  export type $equipePessoasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "equipePessoas"
    objects: {
      equipe: Prisma.$equipePayload<ExtArgs>
      pessoa: Prisma.$pessoaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      equipeId: number
      pessoaId: number
    }, ExtArgs["result"]["equipePessoas"]>
    composites: {}
  }

  type equipePessoasGetPayload<S extends boolean | null | undefined | equipePessoasDefaultArgs> = $Result.GetResult<Prisma.$equipePessoasPayload, S>

  type equipePessoasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<equipePessoasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipePessoasCountAggregateInputType | true
    }

  export interface equipePessoasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['equipePessoas'], meta: { name: 'equipePessoas' } }
    /**
     * Find zero or one EquipePessoas that matches the filter.
     * @param {equipePessoasFindUniqueArgs} args - Arguments to find a EquipePessoas
     * @example
     * // Get one EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends equipePessoasFindUniqueArgs>(args: SelectSubset<T, equipePessoasFindUniqueArgs<ExtArgs>>): Prisma__equipePessoasClient<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipePessoas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {equipePessoasFindUniqueOrThrowArgs} args - Arguments to find a EquipePessoas
     * @example
     * // Get one EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends equipePessoasFindUniqueOrThrowArgs>(args: SelectSubset<T, equipePessoasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__equipePessoasClient<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipePessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipePessoasFindFirstArgs} args - Arguments to find a EquipePessoas
     * @example
     * // Get one EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends equipePessoasFindFirstArgs>(args?: SelectSubset<T, equipePessoasFindFirstArgs<ExtArgs>>): Prisma__equipePessoasClient<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipePessoas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipePessoasFindFirstOrThrowArgs} args - Arguments to find a EquipePessoas
     * @example
     * // Get one EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends equipePessoasFindFirstOrThrowArgs>(args?: SelectSubset<T, equipePessoasFindFirstOrThrowArgs<ExtArgs>>): Prisma__equipePessoasClient<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipePessoas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipePessoasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.findMany()
     * 
     * // Get first 10 EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.findMany({ take: 10 })
     * 
     * // Only select the `equipeId`
     * const equipePessoasWithEquipeIdOnly = await prisma.equipePessoas.findMany({ select: { equipeId: true } })
     * 
     */
    findMany<T extends equipePessoasFindManyArgs>(args?: SelectSubset<T, equipePessoasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipePessoas.
     * @param {equipePessoasCreateArgs} args - Arguments to create a EquipePessoas.
     * @example
     * // Create one EquipePessoas
     * const EquipePessoas = await prisma.equipePessoas.create({
     *   data: {
     *     // ... data to create a EquipePessoas
     *   }
     * })
     * 
     */
    create<T extends equipePessoasCreateArgs>(args: SelectSubset<T, equipePessoasCreateArgs<ExtArgs>>): Prisma__equipePessoasClient<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipePessoas.
     * @param {equipePessoasCreateManyArgs} args - Arguments to create many EquipePessoas.
     * @example
     * // Create many EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends equipePessoasCreateManyArgs>(args?: SelectSubset<T, equipePessoasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipePessoas and returns the data saved in the database.
     * @param {equipePessoasCreateManyAndReturnArgs} args - Arguments to create many EquipePessoas.
     * @example
     * // Create many EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipePessoas and only return the `equipeId`
     * const equipePessoasWithEquipeIdOnly = await prisma.equipePessoas.createManyAndReturn({
     *   select: { equipeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends equipePessoasCreateManyAndReturnArgs>(args?: SelectSubset<T, equipePessoasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipePessoas.
     * @param {equipePessoasDeleteArgs} args - Arguments to delete one EquipePessoas.
     * @example
     * // Delete one EquipePessoas
     * const EquipePessoas = await prisma.equipePessoas.delete({
     *   where: {
     *     // ... filter to delete one EquipePessoas
     *   }
     * })
     * 
     */
    delete<T extends equipePessoasDeleteArgs>(args: SelectSubset<T, equipePessoasDeleteArgs<ExtArgs>>): Prisma__equipePessoasClient<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipePessoas.
     * @param {equipePessoasUpdateArgs} args - Arguments to update one EquipePessoas.
     * @example
     * // Update one EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends equipePessoasUpdateArgs>(args: SelectSubset<T, equipePessoasUpdateArgs<ExtArgs>>): Prisma__equipePessoasClient<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipePessoas.
     * @param {equipePessoasDeleteManyArgs} args - Arguments to filter EquipePessoas to delete.
     * @example
     * // Delete a few EquipePessoas
     * const { count } = await prisma.equipePessoas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends equipePessoasDeleteManyArgs>(args?: SelectSubset<T, equipePessoasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipePessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipePessoasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends equipePessoasUpdateManyArgs>(args: SelectSubset<T, equipePessoasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipePessoas and returns the data updated in the database.
     * @param {equipePessoasUpdateManyAndReturnArgs} args - Arguments to update many EquipePessoas.
     * @example
     * // Update many EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipePessoas and only return the `equipeId`
     * const equipePessoasWithEquipeIdOnly = await prisma.equipePessoas.updateManyAndReturn({
     *   select: { equipeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends equipePessoasUpdateManyAndReturnArgs>(args: SelectSubset<T, equipePessoasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipePessoas.
     * @param {equipePessoasUpsertArgs} args - Arguments to update or create a EquipePessoas.
     * @example
     * // Update or create a EquipePessoas
     * const equipePessoas = await prisma.equipePessoas.upsert({
     *   create: {
     *     // ... data to create a EquipePessoas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipePessoas we want to update
     *   }
     * })
     */
    upsert<T extends equipePessoasUpsertArgs>(args: SelectSubset<T, equipePessoasUpsertArgs<ExtArgs>>): Prisma__equipePessoasClient<$Result.GetResult<Prisma.$equipePessoasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipePessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipePessoasCountArgs} args - Arguments to filter EquipePessoas to count.
     * @example
     * // Count the number of EquipePessoas
     * const count = await prisma.equipePessoas.count({
     *   where: {
     *     // ... the filter for the EquipePessoas we want to count
     *   }
     * })
    **/
    count<T extends equipePessoasCountArgs>(
      args?: Subset<T, equipePessoasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipePessoasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipePessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipePessoasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipePessoasAggregateArgs>(args: Subset<T, EquipePessoasAggregateArgs>): Prisma.PrismaPromise<GetEquipePessoasAggregateType<T>>

    /**
     * Group by EquipePessoas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {equipePessoasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends equipePessoasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: equipePessoasGroupByArgs['orderBy'] }
        : { orderBy?: equipePessoasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, equipePessoasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipePessoasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the equipePessoas model
   */
  readonly fields: equipePessoasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for equipePessoas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__equipePessoasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    equipe<T extends equipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, equipeDefaultArgs<ExtArgs>>): Prisma__equipeClient<$Result.GetResult<Prisma.$equipePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pessoa<T extends pessoaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, pessoaDefaultArgs<ExtArgs>>): Prisma__pessoaClient<$Result.GetResult<Prisma.$pessoaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the equipePessoas model
   */
  interface equipePessoasFieldRefs {
    readonly equipeId: FieldRef<"equipePessoas", 'Int'>
    readonly pessoaId: FieldRef<"equipePessoas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * equipePessoas findUnique
   */
  export type equipePessoasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    /**
     * Filter, which equipePessoas to fetch.
     */
    where: equipePessoasWhereUniqueInput
  }

  /**
   * equipePessoas findUniqueOrThrow
   */
  export type equipePessoasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    /**
     * Filter, which equipePessoas to fetch.
     */
    where: equipePessoasWhereUniqueInput
  }

  /**
   * equipePessoas findFirst
   */
  export type equipePessoasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    /**
     * Filter, which equipePessoas to fetch.
     */
    where?: equipePessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipePessoas to fetch.
     */
    orderBy?: equipePessoasOrderByWithRelationInput | equipePessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipePessoas.
     */
    cursor?: equipePessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipePessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipePessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipePessoas.
     */
    distinct?: EquipePessoasScalarFieldEnum | EquipePessoasScalarFieldEnum[]
  }

  /**
   * equipePessoas findFirstOrThrow
   */
  export type equipePessoasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    /**
     * Filter, which equipePessoas to fetch.
     */
    where?: equipePessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipePessoas to fetch.
     */
    orderBy?: equipePessoasOrderByWithRelationInput | equipePessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for equipePessoas.
     */
    cursor?: equipePessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipePessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipePessoas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of equipePessoas.
     */
    distinct?: EquipePessoasScalarFieldEnum | EquipePessoasScalarFieldEnum[]
  }

  /**
   * equipePessoas findMany
   */
  export type equipePessoasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    /**
     * Filter, which equipePessoas to fetch.
     */
    where?: equipePessoasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of equipePessoas to fetch.
     */
    orderBy?: equipePessoasOrderByWithRelationInput | equipePessoasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing equipePessoas.
     */
    cursor?: equipePessoasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` equipePessoas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` equipePessoas.
     */
    skip?: number
    distinct?: EquipePessoasScalarFieldEnum | EquipePessoasScalarFieldEnum[]
  }

  /**
   * equipePessoas create
   */
  export type equipePessoasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    /**
     * The data needed to create a equipePessoas.
     */
    data: XOR<equipePessoasCreateInput, equipePessoasUncheckedCreateInput>
  }

  /**
   * equipePessoas createMany
   */
  export type equipePessoasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many equipePessoas.
     */
    data: equipePessoasCreateManyInput | equipePessoasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * equipePessoas createManyAndReturn
   */
  export type equipePessoasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * The data used to create many equipePessoas.
     */
    data: equipePessoasCreateManyInput | equipePessoasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * equipePessoas update
   */
  export type equipePessoasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    /**
     * The data needed to update a equipePessoas.
     */
    data: XOR<equipePessoasUpdateInput, equipePessoasUncheckedUpdateInput>
    /**
     * Choose, which equipePessoas to update.
     */
    where: equipePessoasWhereUniqueInput
  }

  /**
   * equipePessoas updateMany
   */
  export type equipePessoasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update equipePessoas.
     */
    data: XOR<equipePessoasUpdateManyMutationInput, equipePessoasUncheckedUpdateManyInput>
    /**
     * Filter which equipePessoas to update
     */
    where?: equipePessoasWhereInput
    /**
     * Limit how many equipePessoas to update.
     */
    limit?: number
  }

  /**
   * equipePessoas updateManyAndReturn
   */
  export type equipePessoasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * The data used to update equipePessoas.
     */
    data: XOR<equipePessoasUpdateManyMutationInput, equipePessoasUncheckedUpdateManyInput>
    /**
     * Filter which equipePessoas to update
     */
    where?: equipePessoasWhereInput
    /**
     * Limit how many equipePessoas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * equipePessoas upsert
   */
  export type equipePessoasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    /**
     * The filter to search for the equipePessoas to update in case it exists.
     */
    where: equipePessoasWhereUniqueInput
    /**
     * In case the equipePessoas found by the `where` argument doesn't exist, create a new equipePessoas with this data.
     */
    create: XOR<equipePessoasCreateInput, equipePessoasUncheckedCreateInput>
    /**
     * In case the equipePessoas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<equipePessoasUpdateInput, equipePessoasUncheckedUpdateInput>
  }

  /**
   * equipePessoas delete
   */
  export type equipePessoasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
    /**
     * Filter which equipePessoas to delete.
     */
    where: equipePessoasWhereUniqueInput
  }

  /**
   * equipePessoas deleteMany
   */
  export type equipePessoasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which equipePessoas to delete
     */
    where?: equipePessoasWhereInput
    /**
     * Limit how many equipePessoas to delete.
     */
    limit?: number
  }

  /**
   * equipePessoas without action
   */
  export type equipePessoasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the equipePessoas
     */
    select?: equipePessoasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the equipePessoas
     */
    omit?: equipePessoasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: equipePessoasInclude<ExtArgs> | null
  }


  /**
   * Model localidade
   */

  export type AggregateLocalidade = {
    _count: LocalidadeCountAggregateOutputType | null
    _avg: LocalidadeAvgAggregateOutputType | null
    _sum: LocalidadeSumAggregateOutputType | null
    _min: LocalidadeMinAggregateOutputType | null
    _max: LocalidadeMaxAggregateOutputType | null
  }

  export type LocalidadeAvgAggregateOutputType = {
    id: number | null
    dioceseId: number | null
    tipoLocalidadeId: number | null
    enderecoId: number | null
  }

  export type LocalidadeSumAggregateOutputType = {
    id: number | null
    dioceseId: number | null
    tipoLocalidadeId: number | null
    enderecoId: number | null
  }

  export type LocalidadeMinAggregateOutputType = {
    id: number | null
    descricao: string | null
    dioceseId: number | null
    tipoLocalidadeId: number | null
    observacao: string | null
    enderecoId: number | null
  }

  export type LocalidadeMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
    dioceseId: number | null
    tipoLocalidadeId: number | null
    observacao: string | null
    enderecoId: number | null
  }

  export type LocalidadeCountAggregateOutputType = {
    id: number
    descricao: number
    dioceseId: number
    tipoLocalidadeId: number
    observacao: number
    enderecoId: number
    _all: number
  }


  export type LocalidadeAvgAggregateInputType = {
    id?: true
    dioceseId?: true
    tipoLocalidadeId?: true
    enderecoId?: true
  }

  export type LocalidadeSumAggregateInputType = {
    id?: true
    dioceseId?: true
    tipoLocalidadeId?: true
    enderecoId?: true
  }

  export type LocalidadeMinAggregateInputType = {
    id?: true
    descricao?: true
    dioceseId?: true
    tipoLocalidadeId?: true
    observacao?: true
    enderecoId?: true
  }

  export type LocalidadeMaxAggregateInputType = {
    id?: true
    descricao?: true
    dioceseId?: true
    tipoLocalidadeId?: true
    observacao?: true
    enderecoId?: true
  }

  export type LocalidadeCountAggregateInputType = {
    id?: true
    descricao?: true
    dioceseId?: true
    tipoLocalidadeId?: true
    observacao?: true
    enderecoId?: true
    _all?: true
  }

  export type LocalidadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which localidade to aggregate.
     */
    where?: localidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localidades to fetch.
     */
    orderBy?: localidadeOrderByWithRelationInput | localidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: localidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned localidades
    **/
    _count?: true | LocalidadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalidadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalidadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalidadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalidadeMaxAggregateInputType
  }

  export type GetLocalidadeAggregateType<T extends LocalidadeAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalidade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalidade[P]>
      : GetScalarType<T[P], AggregateLocalidade[P]>
  }




  export type localidadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localidadeWhereInput
    orderBy?: localidadeOrderByWithAggregationInput | localidadeOrderByWithAggregationInput[]
    by: LocalidadeScalarFieldEnum[] | LocalidadeScalarFieldEnum
    having?: localidadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalidadeCountAggregateInputType | true
    _avg?: LocalidadeAvgAggregateInputType
    _sum?: LocalidadeSumAggregateInputType
    _min?: LocalidadeMinAggregateInputType
    _max?: LocalidadeMaxAggregateInputType
  }

  export type LocalidadeGroupByOutputType = {
    id: number
    descricao: string
    dioceseId: number
    tipoLocalidadeId: number
    observacao: string | null
    enderecoId: number
    _count: LocalidadeCountAggregateOutputType | null
    _avg: LocalidadeAvgAggregateOutputType | null
    _sum: LocalidadeSumAggregateOutputType | null
    _min: LocalidadeMinAggregateOutputType | null
    _max: LocalidadeMaxAggregateOutputType | null
  }

  type GetLocalidadeGroupByPayload<T extends localidadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalidadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalidadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalidadeGroupByOutputType[P]>
            : GetScalarType<T[P], LocalidadeGroupByOutputType[P]>
        }
      >
    >


  export type localidadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    dioceseId?: boolean
    tipoLocalidadeId?: boolean
    observacao?: boolean
    enderecoId?: boolean
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
    tipoLocalidade?: boolean | tipoLocalidadeDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    localidadeRegiao?: boolean | localidade$localidadeRegiaoArgs<ExtArgs>
    _count?: boolean | LocalidadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localidade"]>

  export type localidadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    dioceseId?: boolean
    tipoLocalidadeId?: boolean
    observacao?: boolean
    enderecoId?: boolean
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
    tipoLocalidade?: boolean | tipoLocalidadeDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localidade"]>

  export type localidadeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    dioceseId?: boolean
    tipoLocalidadeId?: boolean
    observacao?: boolean
    enderecoId?: boolean
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
    tipoLocalidade?: boolean | tipoLocalidadeDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localidade"]>

  export type localidadeSelectScalar = {
    id?: boolean
    descricao?: boolean
    dioceseId?: boolean
    tipoLocalidadeId?: boolean
    observacao?: boolean
    enderecoId?: boolean
  }

  export type localidadeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao" | "dioceseId" | "tipoLocalidadeId" | "observacao" | "enderecoId", ExtArgs["result"]["localidade"]>
  export type localidadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
    tipoLocalidade?: boolean | tipoLocalidadeDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
    localidadeRegiao?: boolean | localidade$localidadeRegiaoArgs<ExtArgs>
    _count?: boolean | LocalidadeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type localidadeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
    tipoLocalidade?: boolean | tipoLocalidadeDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }
  export type localidadeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    diocese?: boolean | dioceseDefaultArgs<ExtArgs>
    tipoLocalidade?: boolean | tipoLocalidadeDefaultArgs<ExtArgs>
    endereco?: boolean | enderecoDefaultArgs<ExtArgs>
  }

  export type $localidadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "localidade"
    objects: {
      diocese: Prisma.$diocesePayload<ExtArgs>
      tipoLocalidade: Prisma.$tipoLocalidadePayload<ExtArgs>
      endereco: Prisma.$enderecoPayload<ExtArgs>
      localidadeRegiao: Prisma.$localidadeRegiaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
      dioceseId: number
      tipoLocalidadeId: number
      observacao: string | null
      enderecoId: number
    }, ExtArgs["result"]["localidade"]>
    composites: {}
  }

  type localidadeGetPayload<S extends boolean | null | undefined | localidadeDefaultArgs> = $Result.GetResult<Prisma.$localidadePayload, S>

  type localidadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<localidadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalidadeCountAggregateInputType | true
    }

  export interface localidadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['localidade'], meta: { name: 'localidade' } }
    /**
     * Find zero or one Localidade that matches the filter.
     * @param {localidadeFindUniqueArgs} args - Arguments to find a Localidade
     * @example
     * // Get one Localidade
     * const localidade = await prisma.localidade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends localidadeFindUniqueArgs>(args: SelectSubset<T, localidadeFindUniqueArgs<ExtArgs>>): Prisma__localidadeClient<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Localidade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {localidadeFindUniqueOrThrowArgs} args - Arguments to find a Localidade
     * @example
     * // Get one Localidade
     * const localidade = await prisma.localidade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends localidadeFindUniqueOrThrowArgs>(args: SelectSubset<T, localidadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__localidadeClient<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Localidade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeFindFirstArgs} args - Arguments to find a Localidade
     * @example
     * // Get one Localidade
     * const localidade = await prisma.localidade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends localidadeFindFirstArgs>(args?: SelectSubset<T, localidadeFindFirstArgs<ExtArgs>>): Prisma__localidadeClient<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Localidade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeFindFirstOrThrowArgs} args - Arguments to find a Localidade
     * @example
     * // Get one Localidade
     * const localidade = await prisma.localidade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends localidadeFindFirstOrThrowArgs>(args?: SelectSubset<T, localidadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__localidadeClient<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Localidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Localidades
     * const localidades = await prisma.localidade.findMany()
     * 
     * // Get first 10 Localidades
     * const localidades = await prisma.localidade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localidadeWithIdOnly = await prisma.localidade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends localidadeFindManyArgs>(args?: SelectSubset<T, localidadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Localidade.
     * @param {localidadeCreateArgs} args - Arguments to create a Localidade.
     * @example
     * // Create one Localidade
     * const Localidade = await prisma.localidade.create({
     *   data: {
     *     // ... data to create a Localidade
     *   }
     * })
     * 
     */
    create<T extends localidadeCreateArgs>(args: SelectSubset<T, localidadeCreateArgs<ExtArgs>>): Prisma__localidadeClient<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Localidades.
     * @param {localidadeCreateManyArgs} args - Arguments to create many Localidades.
     * @example
     * // Create many Localidades
     * const localidade = await prisma.localidade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends localidadeCreateManyArgs>(args?: SelectSubset<T, localidadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Localidades and returns the data saved in the database.
     * @param {localidadeCreateManyAndReturnArgs} args - Arguments to create many Localidades.
     * @example
     * // Create many Localidades
     * const localidade = await prisma.localidade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Localidades and only return the `id`
     * const localidadeWithIdOnly = await prisma.localidade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends localidadeCreateManyAndReturnArgs>(args?: SelectSubset<T, localidadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Localidade.
     * @param {localidadeDeleteArgs} args - Arguments to delete one Localidade.
     * @example
     * // Delete one Localidade
     * const Localidade = await prisma.localidade.delete({
     *   where: {
     *     // ... filter to delete one Localidade
     *   }
     * })
     * 
     */
    delete<T extends localidadeDeleteArgs>(args: SelectSubset<T, localidadeDeleteArgs<ExtArgs>>): Prisma__localidadeClient<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Localidade.
     * @param {localidadeUpdateArgs} args - Arguments to update one Localidade.
     * @example
     * // Update one Localidade
     * const localidade = await prisma.localidade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends localidadeUpdateArgs>(args: SelectSubset<T, localidadeUpdateArgs<ExtArgs>>): Prisma__localidadeClient<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Localidades.
     * @param {localidadeDeleteManyArgs} args - Arguments to filter Localidades to delete.
     * @example
     * // Delete a few Localidades
     * const { count } = await prisma.localidade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends localidadeDeleteManyArgs>(args?: SelectSubset<T, localidadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Localidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Localidades
     * const localidade = await prisma.localidade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends localidadeUpdateManyArgs>(args: SelectSubset<T, localidadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Localidades and returns the data updated in the database.
     * @param {localidadeUpdateManyAndReturnArgs} args - Arguments to update many Localidades.
     * @example
     * // Update many Localidades
     * const localidade = await prisma.localidade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Localidades and only return the `id`
     * const localidadeWithIdOnly = await prisma.localidade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends localidadeUpdateManyAndReturnArgs>(args: SelectSubset<T, localidadeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Localidade.
     * @param {localidadeUpsertArgs} args - Arguments to update or create a Localidade.
     * @example
     * // Update or create a Localidade
     * const localidade = await prisma.localidade.upsert({
     *   create: {
     *     // ... data to create a Localidade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Localidade we want to update
     *   }
     * })
     */
    upsert<T extends localidadeUpsertArgs>(args: SelectSubset<T, localidadeUpsertArgs<ExtArgs>>): Prisma__localidadeClient<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Localidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeCountArgs} args - Arguments to filter Localidades to count.
     * @example
     * // Count the number of Localidades
     * const count = await prisma.localidade.count({
     *   where: {
     *     // ... the filter for the Localidades we want to count
     *   }
     * })
    **/
    count<T extends localidadeCountArgs>(
      args?: Subset<T, localidadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalidadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Localidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalidadeAggregateArgs>(args: Subset<T, LocalidadeAggregateArgs>): Prisma.PrismaPromise<GetLocalidadeAggregateType<T>>

    /**
     * Group by Localidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends localidadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: localidadeGroupByArgs['orderBy'] }
        : { orderBy?: localidadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, localidadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalidadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the localidade model
   */
  readonly fields: localidadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for localidade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__localidadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    diocese<T extends dioceseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, dioceseDefaultArgs<ExtArgs>>): Prisma__dioceseClient<$Result.GetResult<Prisma.$diocesePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tipoLocalidade<T extends tipoLocalidadeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tipoLocalidadeDefaultArgs<ExtArgs>>): Prisma__tipoLocalidadeClient<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    endereco<T extends enderecoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, enderecoDefaultArgs<ExtArgs>>): Prisma__enderecoClient<$Result.GetResult<Prisma.$enderecoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    localidadeRegiao<T extends localidade$localidadeRegiaoArgs<ExtArgs> = {}>(args?: Subset<T, localidade$localidadeRegiaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the localidade model
   */
  interface localidadeFieldRefs {
    readonly id: FieldRef<"localidade", 'Int'>
    readonly descricao: FieldRef<"localidade", 'String'>
    readonly dioceseId: FieldRef<"localidade", 'Int'>
    readonly tipoLocalidadeId: FieldRef<"localidade", 'Int'>
    readonly observacao: FieldRef<"localidade", 'String'>
    readonly enderecoId: FieldRef<"localidade", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * localidade findUnique
   */
  export type localidadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    /**
     * Filter, which localidade to fetch.
     */
    where: localidadeWhereUniqueInput
  }

  /**
   * localidade findUniqueOrThrow
   */
  export type localidadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    /**
     * Filter, which localidade to fetch.
     */
    where: localidadeWhereUniqueInput
  }

  /**
   * localidade findFirst
   */
  export type localidadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    /**
     * Filter, which localidade to fetch.
     */
    where?: localidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localidades to fetch.
     */
    orderBy?: localidadeOrderByWithRelationInput | localidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localidades.
     */
    cursor?: localidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localidades.
     */
    distinct?: LocalidadeScalarFieldEnum | LocalidadeScalarFieldEnum[]
  }

  /**
   * localidade findFirstOrThrow
   */
  export type localidadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    /**
     * Filter, which localidade to fetch.
     */
    where?: localidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localidades to fetch.
     */
    orderBy?: localidadeOrderByWithRelationInput | localidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localidades.
     */
    cursor?: localidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localidades.
     */
    distinct?: LocalidadeScalarFieldEnum | LocalidadeScalarFieldEnum[]
  }

  /**
   * localidade findMany
   */
  export type localidadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    /**
     * Filter, which localidades to fetch.
     */
    where?: localidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localidades to fetch.
     */
    orderBy?: localidadeOrderByWithRelationInput | localidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing localidades.
     */
    cursor?: localidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localidades.
     */
    skip?: number
    distinct?: LocalidadeScalarFieldEnum | LocalidadeScalarFieldEnum[]
  }

  /**
   * localidade create
   */
  export type localidadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    /**
     * The data needed to create a localidade.
     */
    data: XOR<localidadeCreateInput, localidadeUncheckedCreateInput>
  }

  /**
   * localidade createMany
   */
  export type localidadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many localidades.
     */
    data: localidadeCreateManyInput | localidadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * localidade createManyAndReturn
   */
  export type localidadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * The data used to create many localidades.
     */
    data: localidadeCreateManyInput | localidadeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * localidade update
   */
  export type localidadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    /**
     * The data needed to update a localidade.
     */
    data: XOR<localidadeUpdateInput, localidadeUncheckedUpdateInput>
    /**
     * Choose, which localidade to update.
     */
    where: localidadeWhereUniqueInput
  }

  /**
   * localidade updateMany
   */
  export type localidadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update localidades.
     */
    data: XOR<localidadeUpdateManyMutationInput, localidadeUncheckedUpdateManyInput>
    /**
     * Filter which localidades to update
     */
    where?: localidadeWhereInput
    /**
     * Limit how many localidades to update.
     */
    limit?: number
  }

  /**
   * localidade updateManyAndReturn
   */
  export type localidadeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * The data used to update localidades.
     */
    data: XOR<localidadeUpdateManyMutationInput, localidadeUncheckedUpdateManyInput>
    /**
     * Filter which localidades to update
     */
    where?: localidadeWhereInput
    /**
     * Limit how many localidades to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * localidade upsert
   */
  export type localidadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    /**
     * The filter to search for the localidade to update in case it exists.
     */
    where: localidadeWhereUniqueInput
    /**
     * In case the localidade found by the `where` argument doesn't exist, create a new localidade with this data.
     */
    create: XOR<localidadeCreateInput, localidadeUncheckedCreateInput>
    /**
     * In case the localidade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<localidadeUpdateInput, localidadeUncheckedUpdateInput>
  }

  /**
   * localidade delete
   */
  export type localidadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    /**
     * Filter which localidade to delete.
     */
    where: localidadeWhereUniqueInput
  }

  /**
   * localidade deleteMany
   */
  export type localidadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which localidades to delete
     */
    where?: localidadeWhereInput
    /**
     * Limit how many localidades to delete.
     */
    limit?: number
  }

  /**
   * localidade.localidadeRegiao
   */
  export type localidade$localidadeRegiaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    where?: localidadeRegiaoWhereInput
    orderBy?: localidadeRegiaoOrderByWithRelationInput | localidadeRegiaoOrderByWithRelationInput[]
    cursor?: localidadeRegiaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalidadeRegiaoScalarFieldEnum | LocalidadeRegiaoScalarFieldEnum[]
  }

  /**
   * localidade without action
   */
  export type localidadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
  }


  /**
   * Model localidadeRegiao
   */

  export type AggregateLocalidadeRegiao = {
    _count: LocalidadeRegiaoCountAggregateOutputType | null
    _avg: LocalidadeRegiaoAvgAggregateOutputType | null
    _sum: LocalidadeRegiaoSumAggregateOutputType | null
    _min: LocalidadeRegiaoMinAggregateOutputType | null
    _max: LocalidadeRegiaoMaxAggregateOutputType | null
  }

  export type LocalidadeRegiaoAvgAggregateOutputType = {
    localidadeId: number | null
    regiaoId: number | null
  }

  export type LocalidadeRegiaoSumAggregateOutputType = {
    localidadeId: number | null
    regiaoId: number | null
  }

  export type LocalidadeRegiaoMinAggregateOutputType = {
    localidadeId: number | null
    regiaoId: number | null
  }

  export type LocalidadeRegiaoMaxAggregateOutputType = {
    localidadeId: number | null
    regiaoId: number | null
  }

  export type LocalidadeRegiaoCountAggregateOutputType = {
    localidadeId: number
    regiaoId: number
    _all: number
  }


  export type LocalidadeRegiaoAvgAggregateInputType = {
    localidadeId?: true
    regiaoId?: true
  }

  export type LocalidadeRegiaoSumAggregateInputType = {
    localidadeId?: true
    regiaoId?: true
  }

  export type LocalidadeRegiaoMinAggregateInputType = {
    localidadeId?: true
    regiaoId?: true
  }

  export type LocalidadeRegiaoMaxAggregateInputType = {
    localidadeId?: true
    regiaoId?: true
  }

  export type LocalidadeRegiaoCountAggregateInputType = {
    localidadeId?: true
    regiaoId?: true
    _all?: true
  }

  export type LocalidadeRegiaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which localidadeRegiao to aggregate.
     */
    where?: localidadeRegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localidadeRegiaos to fetch.
     */
    orderBy?: localidadeRegiaoOrderByWithRelationInput | localidadeRegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: localidadeRegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localidadeRegiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localidadeRegiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned localidadeRegiaos
    **/
    _count?: true | LocalidadeRegiaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalidadeRegiaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalidadeRegiaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalidadeRegiaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalidadeRegiaoMaxAggregateInputType
  }

  export type GetLocalidadeRegiaoAggregateType<T extends LocalidadeRegiaoAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalidadeRegiao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalidadeRegiao[P]>
      : GetScalarType<T[P], AggregateLocalidadeRegiao[P]>
  }




  export type localidadeRegiaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: localidadeRegiaoWhereInput
    orderBy?: localidadeRegiaoOrderByWithAggregationInput | localidadeRegiaoOrderByWithAggregationInput[]
    by: LocalidadeRegiaoScalarFieldEnum[] | LocalidadeRegiaoScalarFieldEnum
    having?: localidadeRegiaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalidadeRegiaoCountAggregateInputType | true
    _avg?: LocalidadeRegiaoAvgAggregateInputType
    _sum?: LocalidadeRegiaoSumAggregateInputType
    _min?: LocalidadeRegiaoMinAggregateInputType
    _max?: LocalidadeRegiaoMaxAggregateInputType
  }

  export type LocalidadeRegiaoGroupByOutputType = {
    localidadeId: number
    regiaoId: number
    _count: LocalidadeRegiaoCountAggregateOutputType | null
    _avg: LocalidadeRegiaoAvgAggregateOutputType | null
    _sum: LocalidadeRegiaoSumAggregateOutputType | null
    _min: LocalidadeRegiaoMinAggregateOutputType | null
    _max: LocalidadeRegiaoMaxAggregateOutputType | null
  }

  type GetLocalidadeRegiaoGroupByPayload<T extends localidadeRegiaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalidadeRegiaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalidadeRegiaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalidadeRegiaoGroupByOutputType[P]>
            : GetScalarType<T[P], LocalidadeRegiaoGroupByOutputType[P]>
        }
      >
    >


  export type localidadeRegiaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    localidadeId?: boolean
    regiaoId?: boolean
    localidade?: boolean | localidadeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localidadeRegiao"]>

  export type localidadeRegiaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    localidadeId?: boolean
    regiaoId?: boolean
    localidade?: boolean | localidadeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localidadeRegiao"]>

  export type localidadeRegiaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    localidadeId?: boolean
    regiaoId?: boolean
    localidade?: boolean | localidadeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localidadeRegiao"]>

  export type localidadeRegiaoSelectScalar = {
    localidadeId?: boolean
    regiaoId?: boolean
  }

  export type localidadeRegiaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"localidadeId" | "regiaoId", ExtArgs["result"]["localidadeRegiao"]>
  export type localidadeRegiaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localidade?: boolean | localidadeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }
  export type localidadeRegiaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localidade?: boolean | localidadeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }
  export type localidadeRegiaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localidade?: boolean | localidadeDefaultArgs<ExtArgs>
    regiao?: boolean | regiaoDefaultArgs<ExtArgs>
  }

  export type $localidadeRegiaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "localidadeRegiao"
    objects: {
      localidade: Prisma.$localidadePayload<ExtArgs>
      regiao: Prisma.$regiaoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      localidadeId: number
      regiaoId: number
    }, ExtArgs["result"]["localidadeRegiao"]>
    composites: {}
  }

  type localidadeRegiaoGetPayload<S extends boolean | null | undefined | localidadeRegiaoDefaultArgs> = $Result.GetResult<Prisma.$localidadeRegiaoPayload, S>

  type localidadeRegiaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<localidadeRegiaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalidadeRegiaoCountAggregateInputType | true
    }

  export interface localidadeRegiaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['localidadeRegiao'], meta: { name: 'localidadeRegiao' } }
    /**
     * Find zero or one LocalidadeRegiao that matches the filter.
     * @param {localidadeRegiaoFindUniqueArgs} args - Arguments to find a LocalidadeRegiao
     * @example
     * // Get one LocalidadeRegiao
     * const localidadeRegiao = await prisma.localidadeRegiao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends localidadeRegiaoFindUniqueArgs>(args: SelectSubset<T, localidadeRegiaoFindUniqueArgs<ExtArgs>>): Prisma__localidadeRegiaoClient<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocalidadeRegiao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {localidadeRegiaoFindUniqueOrThrowArgs} args - Arguments to find a LocalidadeRegiao
     * @example
     * // Get one LocalidadeRegiao
     * const localidadeRegiao = await prisma.localidadeRegiao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends localidadeRegiaoFindUniqueOrThrowArgs>(args: SelectSubset<T, localidadeRegiaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__localidadeRegiaoClient<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalidadeRegiao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeRegiaoFindFirstArgs} args - Arguments to find a LocalidadeRegiao
     * @example
     * // Get one LocalidadeRegiao
     * const localidadeRegiao = await prisma.localidadeRegiao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends localidadeRegiaoFindFirstArgs>(args?: SelectSubset<T, localidadeRegiaoFindFirstArgs<ExtArgs>>): Prisma__localidadeRegiaoClient<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalidadeRegiao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeRegiaoFindFirstOrThrowArgs} args - Arguments to find a LocalidadeRegiao
     * @example
     * // Get one LocalidadeRegiao
     * const localidadeRegiao = await prisma.localidadeRegiao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends localidadeRegiaoFindFirstOrThrowArgs>(args?: SelectSubset<T, localidadeRegiaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__localidadeRegiaoClient<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocalidadeRegiaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeRegiaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalidadeRegiaos
     * const localidadeRegiaos = await prisma.localidadeRegiao.findMany()
     * 
     * // Get first 10 LocalidadeRegiaos
     * const localidadeRegiaos = await prisma.localidadeRegiao.findMany({ take: 10 })
     * 
     * // Only select the `localidadeId`
     * const localidadeRegiaoWithLocalidadeIdOnly = await prisma.localidadeRegiao.findMany({ select: { localidadeId: true } })
     * 
     */
    findMany<T extends localidadeRegiaoFindManyArgs>(args?: SelectSubset<T, localidadeRegiaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocalidadeRegiao.
     * @param {localidadeRegiaoCreateArgs} args - Arguments to create a LocalidadeRegiao.
     * @example
     * // Create one LocalidadeRegiao
     * const LocalidadeRegiao = await prisma.localidadeRegiao.create({
     *   data: {
     *     // ... data to create a LocalidadeRegiao
     *   }
     * })
     * 
     */
    create<T extends localidadeRegiaoCreateArgs>(args: SelectSubset<T, localidadeRegiaoCreateArgs<ExtArgs>>): Prisma__localidadeRegiaoClient<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocalidadeRegiaos.
     * @param {localidadeRegiaoCreateManyArgs} args - Arguments to create many LocalidadeRegiaos.
     * @example
     * // Create many LocalidadeRegiaos
     * const localidadeRegiao = await prisma.localidadeRegiao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends localidadeRegiaoCreateManyArgs>(args?: SelectSubset<T, localidadeRegiaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalidadeRegiaos and returns the data saved in the database.
     * @param {localidadeRegiaoCreateManyAndReturnArgs} args - Arguments to create many LocalidadeRegiaos.
     * @example
     * // Create many LocalidadeRegiaos
     * const localidadeRegiao = await prisma.localidadeRegiao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalidadeRegiaos and only return the `localidadeId`
     * const localidadeRegiaoWithLocalidadeIdOnly = await prisma.localidadeRegiao.createManyAndReturn({
     *   select: { localidadeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends localidadeRegiaoCreateManyAndReturnArgs>(args?: SelectSubset<T, localidadeRegiaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LocalidadeRegiao.
     * @param {localidadeRegiaoDeleteArgs} args - Arguments to delete one LocalidadeRegiao.
     * @example
     * // Delete one LocalidadeRegiao
     * const LocalidadeRegiao = await prisma.localidadeRegiao.delete({
     *   where: {
     *     // ... filter to delete one LocalidadeRegiao
     *   }
     * })
     * 
     */
    delete<T extends localidadeRegiaoDeleteArgs>(args: SelectSubset<T, localidadeRegiaoDeleteArgs<ExtArgs>>): Prisma__localidadeRegiaoClient<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocalidadeRegiao.
     * @param {localidadeRegiaoUpdateArgs} args - Arguments to update one LocalidadeRegiao.
     * @example
     * // Update one LocalidadeRegiao
     * const localidadeRegiao = await prisma.localidadeRegiao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends localidadeRegiaoUpdateArgs>(args: SelectSubset<T, localidadeRegiaoUpdateArgs<ExtArgs>>): Prisma__localidadeRegiaoClient<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocalidadeRegiaos.
     * @param {localidadeRegiaoDeleteManyArgs} args - Arguments to filter LocalidadeRegiaos to delete.
     * @example
     * // Delete a few LocalidadeRegiaos
     * const { count } = await prisma.localidadeRegiao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends localidadeRegiaoDeleteManyArgs>(args?: SelectSubset<T, localidadeRegiaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalidadeRegiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeRegiaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalidadeRegiaos
     * const localidadeRegiao = await prisma.localidadeRegiao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends localidadeRegiaoUpdateManyArgs>(args: SelectSubset<T, localidadeRegiaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalidadeRegiaos and returns the data updated in the database.
     * @param {localidadeRegiaoUpdateManyAndReturnArgs} args - Arguments to update many LocalidadeRegiaos.
     * @example
     * // Update many LocalidadeRegiaos
     * const localidadeRegiao = await prisma.localidadeRegiao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LocalidadeRegiaos and only return the `localidadeId`
     * const localidadeRegiaoWithLocalidadeIdOnly = await prisma.localidadeRegiao.updateManyAndReturn({
     *   select: { localidadeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends localidadeRegiaoUpdateManyAndReturnArgs>(args: SelectSubset<T, localidadeRegiaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LocalidadeRegiao.
     * @param {localidadeRegiaoUpsertArgs} args - Arguments to update or create a LocalidadeRegiao.
     * @example
     * // Update or create a LocalidadeRegiao
     * const localidadeRegiao = await prisma.localidadeRegiao.upsert({
     *   create: {
     *     // ... data to create a LocalidadeRegiao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalidadeRegiao we want to update
     *   }
     * })
     */
    upsert<T extends localidadeRegiaoUpsertArgs>(args: SelectSubset<T, localidadeRegiaoUpsertArgs<ExtArgs>>): Prisma__localidadeRegiaoClient<$Result.GetResult<Prisma.$localidadeRegiaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocalidadeRegiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeRegiaoCountArgs} args - Arguments to filter LocalidadeRegiaos to count.
     * @example
     * // Count the number of LocalidadeRegiaos
     * const count = await prisma.localidadeRegiao.count({
     *   where: {
     *     // ... the filter for the LocalidadeRegiaos we want to count
     *   }
     * })
    **/
    count<T extends localidadeRegiaoCountArgs>(
      args?: Subset<T, localidadeRegiaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalidadeRegiaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalidadeRegiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalidadeRegiaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalidadeRegiaoAggregateArgs>(args: Subset<T, LocalidadeRegiaoAggregateArgs>): Prisma.PrismaPromise<GetLocalidadeRegiaoAggregateType<T>>

    /**
     * Group by LocalidadeRegiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {localidadeRegiaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends localidadeRegiaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: localidadeRegiaoGroupByArgs['orderBy'] }
        : { orderBy?: localidadeRegiaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, localidadeRegiaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalidadeRegiaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the localidadeRegiao model
   */
  readonly fields: localidadeRegiaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for localidadeRegiao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__localidadeRegiaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    localidade<T extends localidadeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, localidadeDefaultArgs<ExtArgs>>): Prisma__localidadeClient<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    regiao<T extends regiaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, regiaoDefaultArgs<ExtArgs>>): Prisma__regiaoClient<$Result.GetResult<Prisma.$regiaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the localidadeRegiao model
   */
  interface localidadeRegiaoFieldRefs {
    readonly localidadeId: FieldRef<"localidadeRegiao", 'Int'>
    readonly regiaoId: FieldRef<"localidadeRegiao", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * localidadeRegiao findUnique
   */
  export type localidadeRegiaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which localidadeRegiao to fetch.
     */
    where: localidadeRegiaoWhereUniqueInput
  }

  /**
   * localidadeRegiao findUniqueOrThrow
   */
  export type localidadeRegiaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which localidadeRegiao to fetch.
     */
    where: localidadeRegiaoWhereUniqueInput
  }

  /**
   * localidadeRegiao findFirst
   */
  export type localidadeRegiaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which localidadeRegiao to fetch.
     */
    where?: localidadeRegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localidadeRegiaos to fetch.
     */
    orderBy?: localidadeRegiaoOrderByWithRelationInput | localidadeRegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localidadeRegiaos.
     */
    cursor?: localidadeRegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localidadeRegiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localidadeRegiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localidadeRegiaos.
     */
    distinct?: LocalidadeRegiaoScalarFieldEnum | LocalidadeRegiaoScalarFieldEnum[]
  }

  /**
   * localidadeRegiao findFirstOrThrow
   */
  export type localidadeRegiaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which localidadeRegiao to fetch.
     */
    where?: localidadeRegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localidadeRegiaos to fetch.
     */
    orderBy?: localidadeRegiaoOrderByWithRelationInput | localidadeRegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for localidadeRegiaos.
     */
    cursor?: localidadeRegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localidadeRegiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localidadeRegiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of localidadeRegiaos.
     */
    distinct?: LocalidadeRegiaoScalarFieldEnum | LocalidadeRegiaoScalarFieldEnum[]
  }

  /**
   * localidadeRegiao findMany
   */
  export type localidadeRegiaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    /**
     * Filter, which localidadeRegiaos to fetch.
     */
    where?: localidadeRegiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of localidadeRegiaos to fetch.
     */
    orderBy?: localidadeRegiaoOrderByWithRelationInput | localidadeRegiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing localidadeRegiaos.
     */
    cursor?: localidadeRegiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` localidadeRegiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` localidadeRegiaos.
     */
    skip?: number
    distinct?: LocalidadeRegiaoScalarFieldEnum | LocalidadeRegiaoScalarFieldEnum[]
  }

  /**
   * localidadeRegiao create
   */
  export type localidadeRegiaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    /**
     * The data needed to create a localidadeRegiao.
     */
    data: XOR<localidadeRegiaoCreateInput, localidadeRegiaoUncheckedCreateInput>
  }

  /**
   * localidadeRegiao createMany
   */
  export type localidadeRegiaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many localidadeRegiaos.
     */
    data: localidadeRegiaoCreateManyInput | localidadeRegiaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * localidadeRegiao createManyAndReturn
   */
  export type localidadeRegiaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * The data used to create many localidadeRegiaos.
     */
    data: localidadeRegiaoCreateManyInput | localidadeRegiaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * localidadeRegiao update
   */
  export type localidadeRegiaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    /**
     * The data needed to update a localidadeRegiao.
     */
    data: XOR<localidadeRegiaoUpdateInput, localidadeRegiaoUncheckedUpdateInput>
    /**
     * Choose, which localidadeRegiao to update.
     */
    where: localidadeRegiaoWhereUniqueInput
  }

  /**
   * localidadeRegiao updateMany
   */
  export type localidadeRegiaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update localidadeRegiaos.
     */
    data: XOR<localidadeRegiaoUpdateManyMutationInput, localidadeRegiaoUncheckedUpdateManyInput>
    /**
     * Filter which localidadeRegiaos to update
     */
    where?: localidadeRegiaoWhereInput
    /**
     * Limit how many localidadeRegiaos to update.
     */
    limit?: number
  }

  /**
   * localidadeRegiao updateManyAndReturn
   */
  export type localidadeRegiaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * The data used to update localidadeRegiaos.
     */
    data: XOR<localidadeRegiaoUpdateManyMutationInput, localidadeRegiaoUncheckedUpdateManyInput>
    /**
     * Filter which localidadeRegiaos to update
     */
    where?: localidadeRegiaoWhereInput
    /**
     * Limit how many localidadeRegiaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * localidadeRegiao upsert
   */
  export type localidadeRegiaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    /**
     * The filter to search for the localidadeRegiao to update in case it exists.
     */
    where: localidadeRegiaoWhereUniqueInput
    /**
     * In case the localidadeRegiao found by the `where` argument doesn't exist, create a new localidadeRegiao with this data.
     */
    create: XOR<localidadeRegiaoCreateInput, localidadeRegiaoUncheckedCreateInput>
    /**
     * In case the localidadeRegiao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<localidadeRegiaoUpdateInput, localidadeRegiaoUncheckedUpdateInput>
  }

  /**
   * localidadeRegiao delete
   */
  export type localidadeRegiaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
    /**
     * Filter which localidadeRegiao to delete.
     */
    where: localidadeRegiaoWhereUniqueInput
  }

  /**
   * localidadeRegiao deleteMany
   */
  export type localidadeRegiaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which localidadeRegiaos to delete
     */
    where?: localidadeRegiaoWhereInput
    /**
     * Limit how many localidadeRegiaos to delete.
     */
    limit?: number
  }

  /**
   * localidadeRegiao without action
   */
  export type localidadeRegiaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidadeRegiao
     */
    select?: localidadeRegiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidadeRegiao
     */
    omit?: localidadeRegiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeRegiaoInclude<ExtArgs> | null
  }


  /**
   * Model tipoLocalidade
   */

  export type AggregateTipoLocalidade = {
    _count: TipoLocalidadeCountAggregateOutputType | null
    _avg: TipoLocalidadeAvgAggregateOutputType | null
    _sum: TipoLocalidadeSumAggregateOutputType | null
    _min: TipoLocalidadeMinAggregateOutputType | null
    _max: TipoLocalidadeMaxAggregateOutputType | null
  }

  export type TipoLocalidadeAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoLocalidadeSumAggregateOutputType = {
    id: number | null
  }

  export type TipoLocalidadeMinAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoLocalidadeMaxAggregateOutputType = {
    id: number | null
    descricao: string | null
  }

  export type TipoLocalidadeCountAggregateOutputType = {
    id: number
    descricao: number
    _all: number
  }


  export type TipoLocalidadeAvgAggregateInputType = {
    id?: true
  }

  export type TipoLocalidadeSumAggregateInputType = {
    id?: true
  }

  export type TipoLocalidadeMinAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoLocalidadeMaxAggregateInputType = {
    id?: true
    descricao?: true
  }

  export type TipoLocalidadeCountAggregateInputType = {
    id?: true
    descricao?: true
    _all?: true
  }

  export type TipoLocalidadeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoLocalidade to aggregate.
     */
    where?: tipoLocalidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoLocalidades to fetch.
     */
    orderBy?: tipoLocalidadeOrderByWithRelationInput | tipoLocalidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tipoLocalidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoLocalidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoLocalidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tipoLocalidades
    **/
    _count?: true | TipoLocalidadeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoLocalidadeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoLocalidadeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoLocalidadeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoLocalidadeMaxAggregateInputType
  }

  export type GetTipoLocalidadeAggregateType<T extends TipoLocalidadeAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoLocalidade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoLocalidade[P]>
      : GetScalarType<T[P], AggregateTipoLocalidade[P]>
  }




  export type tipoLocalidadeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tipoLocalidadeWhereInput
    orderBy?: tipoLocalidadeOrderByWithAggregationInput | tipoLocalidadeOrderByWithAggregationInput[]
    by: TipoLocalidadeScalarFieldEnum[] | TipoLocalidadeScalarFieldEnum
    having?: tipoLocalidadeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoLocalidadeCountAggregateInputType | true
    _avg?: TipoLocalidadeAvgAggregateInputType
    _sum?: TipoLocalidadeSumAggregateInputType
    _min?: TipoLocalidadeMinAggregateInputType
    _max?: TipoLocalidadeMaxAggregateInputType
  }

  export type TipoLocalidadeGroupByOutputType = {
    id: number
    descricao: string
    _count: TipoLocalidadeCountAggregateOutputType | null
    _avg: TipoLocalidadeAvgAggregateOutputType | null
    _sum: TipoLocalidadeSumAggregateOutputType | null
    _min: TipoLocalidadeMinAggregateOutputType | null
    _max: TipoLocalidadeMaxAggregateOutputType | null
  }

  type GetTipoLocalidadeGroupByPayload<T extends tipoLocalidadeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoLocalidadeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoLocalidadeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoLocalidadeGroupByOutputType[P]>
            : GetScalarType<T[P], TipoLocalidadeGroupByOutputType[P]>
        }
      >
    >


  export type tipoLocalidadeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
    localidade?: boolean | tipoLocalidade$localidadeArgs<ExtArgs>
    _count?: boolean | TipoLocalidadeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoLocalidade"]>

  export type tipoLocalidadeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoLocalidade"]>

  export type tipoLocalidadeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    descricao?: boolean
  }, ExtArgs["result"]["tipoLocalidade"]>

  export type tipoLocalidadeSelectScalar = {
    id?: boolean
    descricao?: boolean
  }

  export type tipoLocalidadeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "descricao", ExtArgs["result"]["tipoLocalidade"]>
  export type tipoLocalidadeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    localidade?: boolean | tipoLocalidade$localidadeArgs<ExtArgs>
    _count?: boolean | TipoLocalidadeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tipoLocalidadeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tipoLocalidadeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tipoLocalidadePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tipoLocalidade"
    objects: {
      localidade: Prisma.$localidadePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      descricao: string
    }, ExtArgs["result"]["tipoLocalidade"]>
    composites: {}
  }

  type tipoLocalidadeGetPayload<S extends boolean | null | undefined | tipoLocalidadeDefaultArgs> = $Result.GetResult<Prisma.$tipoLocalidadePayload, S>

  type tipoLocalidadeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tipoLocalidadeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoLocalidadeCountAggregateInputType | true
    }

  export interface tipoLocalidadeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tipoLocalidade'], meta: { name: 'tipoLocalidade' } }
    /**
     * Find zero or one TipoLocalidade that matches the filter.
     * @param {tipoLocalidadeFindUniqueArgs} args - Arguments to find a TipoLocalidade
     * @example
     * // Get one TipoLocalidade
     * const tipoLocalidade = await prisma.tipoLocalidade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tipoLocalidadeFindUniqueArgs>(args: SelectSubset<T, tipoLocalidadeFindUniqueArgs<ExtArgs>>): Prisma__tipoLocalidadeClient<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoLocalidade that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tipoLocalidadeFindUniqueOrThrowArgs} args - Arguments to find a TipoLocalidade
     * @example
     * // Get one TipoLocalidade
     * const tipoLocalidade = await prisma.tipoLocalidade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tipoLocalidadeFindUniqueOrThrowArgs>(args: SelectSubset<T, tipoLocalidadeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tipoLocalidadeClient<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoLocalidade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoLocalidadeFindFirstArgs} args - Arguments to find a TipoLocalidade
     * @example
     * // Get one TipoLocalidade
     * const tipoLocalidade = await prisma.tipoLocalidade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tipoLocalidadeFindFirstArgs>(args?: SelectSubset<T, tipoLocalidadeFindFirstArgs<ExtArgs>>): Prisma__tipoLocalidadeClient<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoLocalidade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoLocalidadeFindFirstOrThrowArgs} args - Arguments to find a TipoLocalidade
     * @example
     * // Get one TipoLocalidade
     * const tipoLocalidade = await prisma.tipoLocalidade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tipoLocalidadeFindFirstOrThrowArgs>(args?: SelectSubset<T, tipoLocalidadeFindFirstOrThrowArgs<ExtArgs>>): Prisma__tipoLocalidadeClient<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoLocalidades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoLocalidadeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoLocalidades
     * const tipoLocalidades = await prisma.tipoLocalidade.findMany()
     * 
     * // Get first 10 TipoLocalidades
     * const tipoLocalidades = await prisma.tipoLocalidade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoLocalidadeWithIdOnly = await prisma.tipoLocalidade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tipoLocalidadeFindManyArgs>(args?: SelectSubset<T, tipoLocalidadeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoLocalidade.
     * @param {tipoLocalidadeCreateArgs} args - Arguments to create a TipoLocalidade.
     * @example
     * // Create one TipoLocalidade
     * const TipoLocalidade = await prisma.tipoLocalidade.create({
     *   data: {
     *     // ... data to create a TipoLocalidade
     *   }
     * })
     * 
     */
    create<T extends tipoLocalidadeCreateArgs>(args: SelectSubset<T, tipoLocalidadeCreateArgs<ExtArgs>>): Prisma__tipoLocalidadeClient<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoLocalidades.
     * @param {tipoLocalidadeCreateManyArgs} args - Arguments to create many TipoLocalidades.
     * @example
     * // Create many TipoLocalidades
     * const tipoLocalidade = await prisma.tipoLocalidade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tipoLocalidadeCreateManyArgs>(args?: SelectSubset<T, tipoLocalidadeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoLocalidades and returns the data saved in the database.
     * @param {tipoLocalidadeCreateManyAndReturnArgs} args - Arguments to create many TipoLocalidades.
     * @example
     * // Create many TipoLocalidades
     * const tipoLocalidade = await prisma.tipoLocalidade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoLocalidades and only return the `id`
     * const tipoLocalidadeWithIdOnly = await prisma.tipoLocalidade.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tipoLocalidadeCreateManyAndReturnArgs>(args?: SelectSubset<T, tipoLocalidadeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoLocalidade.
     * @param {tipoLocalidadeDeleteArgs} args - Arguments to delete one TipoLocalidade.
     * @example
     * // Delete one TipoLocalidade
     * const TipoLocalidade = await prisma.tipoLocalidade.delete({
     *   where: {
     *     // ... filter to delete one TipoLocalidade
     *   }
     * })
     * 
     */
    delete<T extends tipoLocalidadeDeleteArgs>(args: SelectSubset<T, tipoLocalidadeDeleteArgs<ExtArgs>>): Prisma__tipoLocalidadeClient<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoLocalidade.
     * @param {tipoLocalidadeUpdateArgs} args - Arguments to update one TipoLocalidade.
     * @example
     * // Update one TipoLocalidade
     * const tipoLocalidade = await prisma.tipoLocalidade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tipoLocalidadeUpdateArgs>(args: SelectSubset<T, tipoLocalidadeUpdateArgs<ExtArgs>>): Prisma__tipoLocalidadeClient<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoLocalidades.
     * @param {tipoLocalidadeDeleteManyArgs} args - Arguments to filter TipoLocalidades to delete.
     * @example
     * // Delete a few TipoLocalidades
     * const { count } = await prisma.tipoLocalidade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tipoLocalidadeDeleteManyArgs>(args?: SelectSubset<T, tipoLocalidadeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoLocalidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoLocalidadeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoLocalidades
     * const tipoLocalidade = await prisma.tipoLocalidade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tipoLocalidadeUpdateManyArgs>(args: SelectSubset<T, tipoLocalidadeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoLocalidades and returns the data updated in the database.
     * @param {tipoLocalidadeUpdateManyAndReturnArgs} args - Arguments to update many TipoLocalidades.
     * @example
     * // Update many TipoLocalidades
     * const tipoLocalidade = await prisma.tipoLocalidade.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoLocalidades and only return the `id`
     * const tipoLocalidadeWithIdOnly = await prisma.tipoLocalidade.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tipoLocalidadeUpdateManyAndReturnArgs>(args: SelectSubset<T, tipoLocalidadeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoLocalidade.
     * @param {tipoLocalidadeUpsertArgs} args - Arguments to update or create a TipoLocalidade.
     * @example
     * // Update or create a TipoLocalidade
     * const tipoLocalidade = await prisma.tipoLocalidade.upsert({
     *   create: {
     *     // ... data to create a TipoLocalidade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoLocalidade we want to update
     *   }
     * })
     */
    upsert<T extends tipoLocalidadeUpsertArgs>(args: SelectSubset<T, tipoLocalidadeUpsertArgs<ExtArgs>>): Prisma__tipoLocalidadeClient<$Result.GetResult<Prisma.$tipoLocalidadePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoLocalidades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoLocalidadeCountArgs} args - Arguments to filter TipoLocalidades to count.
     * @example
     * // Count the number of TipoLocalidades
     * const count = await prisma.tipoLocalidade.count({
     *   where: {
     *     // ... the filter for the TipoLocalidades we want to count
     *   }
     * })
    **/
    count<T extends tipoLocalidadeCountArgs>(
      args?: Subset<T, tipoLocalidadeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoLocalidadeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoLocalidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoLocalidadeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoLocalidadeAggregateArgs>(args: Subset<T, TipoLocalidadeAggregateArgs>): Prisma.PrismaPromise<GetTipoLocalidadeAggregateType<T>>

    /**
     * Group by TipoLocalidade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tipoLocalidadeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tipoLocalidadeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tipoLocalidadeGroupByArgs['orderBy'] }
        : { orderBy?: tipoLocalidadeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tipoLocalidadeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoLocalidadeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tipoLocalidade model
   */
  readonly fields: tipoLocalidadeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tipoLocalidade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tipoLocalidadeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    localidade<T extends tipoLocalidade$localidadeArgs<ExtArgs> = {}>(args?: Subset<T, tipoLocalidade$localidadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$localidadePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tipoLocalidade model
   */
  interface tipoLocalidadeFieldRefs {
    readonly id: FieldRef<"tipoLocalidade", 'Int'>
    readonly descricao: FieldRef<"tipoLocalidade", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tipoLocalidade findUnique
   */
  export type tipoLocalidadeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoLocalidade to fetch.
     */
    where: tipoLocalidadeWhereUniqueInput
  }

  /**
   * tipoLocalidade findUniqueOrThrow
   */
  export type tipoLocalidadeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoLocalidade to fetch.
     */
    where: tipoLocalidadeWhereUniqueInput
  }

  /**
   * tipoLocalidade findFirst
   */
  export type tipoLocalidadeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoLocalidade to fetch.
     */
    where?: tipoLocalidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoLocalidades to fetch.
     */
    orderBy?: tipoLocalidadeOrderByWithRelationInput | tipoLocalidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoLocalidades.
     */
    cursor?: tipoLocalidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoLocalidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoLocalidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoLocalidades.
     */
    distinct?: TipoLocalidadeScalarFieldEnum | TipoLocalidadeScalarFieldEnum[]
  }

  /**
   * tipoLocalidade findFirstOrThrow
   */
  export type tipoLocalidadeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoLocalidade to fetch.
     */
    where?: tipoLocalidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoLocalidades to fetch.
     */
    orderBy?: tipoLocalidadeOrderByWithRelationInput | tipoLocalidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tipoLocalidades.
     */
    cursor?: tipoLocalidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoLocalidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoLocalidades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tipoLocalidades.
     */
    distinct?: TipoLocalidadeScalarFieldEnum | TipoLocalidadeScalarFieldEnum[]
  }

  /**
   * tipoLocalidade findMany
   */
  export type tipoLocalidadeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
    /**
     * Filter, which tipoLocalidades to fetch.
     */
    where?: tipoLocalidadeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tipoLocalidades to fetch.
     */
    orderBy?: tipoLocalidadeOrderByWithRelationInput | tipoLocalidadeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tipoLocalidades.
     */
    cursor?: tipoLocalidadeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tipoLocalidades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tipoLocalidades.
     */
    skip?: number
    distinct?: TipoLocalidadeScalarFieldEnum | TipoLocalidadeScalarFieldEnum[]
  }

  /**
   * tipoLocalidade create
   */
  export type tipoLocalidadeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
    /**
     * The data needed to create a tipoLocalidade.
     */
    data: XOR<tipoLocalidadeCreateInput, tipoLocalidadeUncheckedCreateInput>
  }

  /**
   * tipoLocalidade createMany
   */
  export type tipoLocalidadeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tipoLocalidades.
     */
    data: tipoLocalidadeCreateManyInput | tipoLocalidadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoLocalidade createManyAndReturn
   */
  export type tipoLocalidadeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * The data used to create many tipoLocalidades.
     */
    data: tipoLocalidadeCreateManyInput | tipoLocalidadeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tipoLocalidade update
   */
  export type tipoLocalidadeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
    /**
     * The data needed to update a tipoLocalidade.
     */
    data: XOR<tipoLocalidadeUpdateInput, tipoLocalidadeUncheckedUpdateInput>
    /**
     * Choose, which tipoLocalidade to update.
     */
    where: tipoLocalidadeWhereUniqueInput
  }

  /**
   * tipoLocalidade updateMany
   */
  export type tipoLocalidadeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tipoLocalidades.
     */
    data: XOR<tipoLocalidadeUpdateManyMutationInput, tipoLocalidadeUncheckedUpdateManyInput>
    /**
     * Filter which tipoLocalidades to update
     */
    where?: tipoLocalidadeWhereInput
    /**
     * Limit how many tipoLocalidades to update.
     */
    limit?: number
  }

  /**
   * tipoLocalidade updateManyAndReturn
   */
  export type tipoLocalidadeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * The data used to update tipoLocalidades.
     */
    data: XOR<tipoLocalidadeUpdateManyMutationInput, tipoLocalidadeUncheckedUpdateManyInput>
    /**
     * Filter which tipoLocalidades to update
     */
    where?: tipoLocalidadeWhereInput
    /**
     * Limit how many tipoLocalidades to update.
     */
    limit?: number
  }

  /**
   * tipoLocalidade upsert
   */
  export type tipoLocalidadeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
    /**
     * The filter to search for the tipoLocalidade to update in case it exists.
     */
    where: tipoLocalidadeWhereUniqueInput
    /**
     * In case the tipoLocalidade found by the `where` argument doesn't exist, create a new tipoLocalidade with this data.
     */
    create: XOR<tipoLocalidadeCreateInput, tipoLocalidadeUncheckedCreateInput>
    /**
     * In case the tipoLocalidade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tipoLocalidadeUpdateInput, tipoLocalidadeUncheckedUpdateInput>
  }

  /**
   * tipoLocalidade delete
   */
  export type tipoLocalidadeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
    /**
     * Filter which tipoLocalidade to delete.
     */
    where: tipoLocalidadeWhereUniqueInput
  }

  /**
   * tipoLocalidade deleteMany
   */
  export type tipoLocalidadeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tipoLocalidades to delete
     */
    where?: tipoLocalidadeWhereInput
    /**
     * Limit how many tipoLocalidades to delete.
     */
    limit?: number
  }

  /**
   * tipoLocalidade.localidade
   */
  export type tipoLocalidade$localidadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the localidade
     */
    select?: localidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the localidade
     */
    omit?: localidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: localidadeInclude<ExtArgs> | null
    where?: localidadeWhereInput
    orderBy?: localidadeOrderByWithRelationInput | localidadeOrderByWithRelationInput[]
    cursor?: localidadeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocalidadeScalarFieldEnum | LocalidadeScalarFieldEnum[]
  }

  /**
   * tipoLocalidade without action
   */
  export type tipoLocalidadeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tipoLocalidade
     */
    select?: tipoLocalidadeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tipoLocalidade
     */
    omit?: tipoLocalidadeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tipoLocalidadeInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.roles | null
    whatsapp: string | null
    verifiedWhatsapp: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.roles | null
    whatsapp: string | null
    verifiedWhatsapp: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    whatsapp: number
    verifiedWhatsapp: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    whatsapp?: true
    verifiedWhatsapp?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    whatsapp?: true
    verifiedWhatsapp?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    whatsapp?: true
    verifiedWhatsapp?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.roles
    whatsapp: string | null
    verifiedWhatsapp: boolean
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    whatsapp?: boolean
    verifiedWhatsapp?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    whatsapp?: boolean
    verifiedWhatsapp?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    whatsapp?: boolean
    verifiedWhatsapp?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    whatsapp?: boolean
    verifiedWhatsapp?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "whatsapp" | "verifiedWhatsapp" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.roles
      whatsapp: string | null
      verifiedWhatsapp: boolean
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly name: FieldRef<"user", 'String'>
    readonly email: FieldRef<"user", 'String'>
    readonly password: FieldRef<"user", 'String'>
    readonly role: FieldRef<"user", 'roles'>
    readonly whatsapp: FieldRef<"user", 'String'>
    readonly verifiedWhatsapp: FieldRef<"user", 'Boolean'>
    readonly active: FieldRef<"user", 'Boolean'>
    readonly createdAt: FieldRef<"user", 'DateTime'>
    readonly updatedAt: FieldRef<"user", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PaisScalarFieldEnum: {
    id: 'id',
    isoAlpha2: 'isoAlpha2',
    nome: 'nome',
    regiao: 'regiao',
    subRegiao: 'subRegiao',
    regiaoIntermediaria: 'regiaoIntermediaria',
    lingua: 'lingua',
    capital: 'capital'
  };

  export type PaisScalarFieldEnum = (typeof PaisScalarFieldEnum)[keyof typeof PaisScalarFieldEnum]


  export const EstadoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    sigla: 'sigla',
    ativo: 'ativo',
    paisId: 'paisId'
  };

  export type EstadoScalarFieldEnum = (typeof EstadoScalarFieldEnum)[keyof typeof EstadoScalarFieldEnum]


  export const CidadeScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    estadoId: 'estadoId',
    ativo: 'ativo'
  };

  export type CidadeScalarFieldEnum = (typeof CidadeScalarFieldEnum)[keyof typeof CidadeScalarFieldEnum]


  export const EnderecoScalarFieldEnum: {
    id: 'id',
    cep: 'cep',
    logradouro: 'logradouro',
    cidade: 'cidade',
    bairro: 'bairro',
    numero: 'numero',
    UF: 'UF',
    pais: 'pais',
    observacao: 'observacao'
  };

  export type EnderecoScalarFieldEnum = (typeof EnderecoScalarFieldEnum)[keyof typeof EnderecoScalarFieldEnum]


  export const TipoCarismaScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type TipoCarismaScalarFieldEnum = (typeof TipoCarismaScalarFieldEnum)[keyof typeof TipoCarismaScalarFieldEnum]


  export const EstadoCivilScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type EstadoCivilScalarFieldEnum = (typeof EstadoCivilScalarFieldEnum)[keyof typeof EstadoCivilScalarFieldEnum]


  export const EscolaridadeScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type EscolaridadeScalarFieldEnum = (typeof EscolaridadeScalarFieldEnum)[keyof typeof EscolaridadeScalarFieldEnum]


  export const PessoaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    conhecidoPor: 'conhecidoPor',
    sexo: 'sexo',
    cpf: 'cpf',
    nacionalidade: 'nacionalidade',
    dataNascimento: 'dataNascimento',
    estadoCivilId: 'estadoCivilId',
    foto: 'foto',
    escolaridadeId: 'escolaridadeId',
    ativo: 'ativo',
    tipoPessoaId: 'tipoPessoaId'
  };

  export type PessoaScalarFieldEnum = (typeof PessoaScalarFieldEnum)[keyof typeof PessoaScalarFieldEnum]


  export const TipoPessoaScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type TipoPessoaScalarFieldEnum = (typeof TipoPessoaScalarFieldEnum)[keyof typeof TipoPessoaScalarFieldEnum]


  export const PessoaEnderecoScalarFieldEnum: {
    pessoaId: 'pessoaId',
    enderecoId: 'enderecoId'
  };

  export type PessoaEnderecoScalarFieldEnum = (typeof PessoaEnderecoScalarFieldEnum)[keyof typeof PessoaEnderecoScalarFieldEnum]


  export const PessoaCasalScalarFieldEnum: {
    id: 'id',
    pessoaMaridoId: 'pessoaMaridoId',
    pessoaMulherId: 'pessoaMulherId'
  };

  export type PessoaCasalScalarFieldEnum = (typeof PessoaCasalScalarFieldEnum)[keyof typeof PessoaCasalScalarFieldEnum]


  export const PessoaCarismaScalarFieldEnum: {
    pessoaId: 'pessoaId',
    tipoCarismaId: 'tipoCarismaId'
  };

  export type PessoaCarismaScalarFieldEnum = (typeof PessoaCarismaScalarFieldEnum)[keyof typeof PessoaCarismaScalarFieldEnum]


  export const PassaportePessoaScalarFieldEnum: {
    id: 'id',
    pessoaId: 'pessoaId',
    numero: 'numero',
    dataExpiracao: 'dataExpiracao',
    renovado: 'renovado',
    dataRenovacao: 'dataRenovacao'
  };

  export type PassaportePessoaScalarFieldEnum = (typeof PassaportePessoaScalarFieldEnum)[keyof typeof PassaportePessoaScalarFieldEnum]


  export const PessoaContatoScalarFieldEnum: {
    id: 'id',
    telefoneResidencial: 'telefoneResidencial',
    telefoneCelular: 'telefoneCelular',
    observacao: 'observacao',
    ativo: 'ativo',
    email: 'email',
    pessoaId: 'pessoaId'
  };

  export type PessoaContatoScalarFieldEnum = (typeof PessoaContatoScalarFieldEnum)[keyof typeof PessoaContatoScalarFieldEnum]


  export const TipoDioceseScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type TipoDioceseScalarFieldEnum = (typeof TipoDioceseScalarFieldEnum)[keyof typeof TipoDioceseScalarFieldEnum]


  export const DioceseScalarFieldEnum: {
    id: 'id',
    tipoDioceseId: 'tipoDioceseId',
    descricao: 'descricao',
    enderecoId: 'enderecoId'
  };

  export type DioceseScalarFieldEnum = (typeof DioceseScalarFieldEnum)[keyof typeof DioceseScalarFieldEnum]


  export const ParoquiaScalarFieldEnum: {
    id: 'id',
    enderecoId: 'enderecoId',
    dioceseId: 'dioceseId',
    descricao: 'descricao'
  };

  export type ParoquiaScalarFieldEnum = (typeof ParoquiaScalarFieldEnum)[keyof typeof ParoquiaScalarFieldEnum]


  export const ParoquiaPessoasScalarFieldEnum: {
    pessoaId: 'pessoaId',
    paroquiaId: 'paroquiaId'
  };

  export type ParoquiaPessoasScalarFieldEnum = (typeof ParoquiaPessoasScalarFieldEnum)[keyof typeof ParoquiaPessoasScalarFieldEnum]


  export const EtapaScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type EtapaScalarFieldEnum = (typeof EtapaScalarFieldEnum)[keyof typeof EtapaScalarFieldEnum]


  export const RegiaoScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    macroRegiao: 'macroRegiao'
  };

  export type RegiaoScalarFieldEnum = (typeof RegiaoScalarFieldEnum)[keyof typeof RegiaoScalarFieldEnum]


  export const TipoEquipeScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type TipoEquipeScalarFieldEnum = (typeof TipoEquipeScalarFieldEnum)[keyof typeof TipoEquipeScalarFieldEnum]


  export const EquipeScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type EquipeScalarFieldEnum = (typeof EquipeScalarFieldEnum)[keyof typeof EquipeScalarFieldEnum]


  export const EquipeTipoEquipeScalarFieldEnum: {
    equipeId: 'equipeId',
    tipoEquipeId: 'tipoEquipeId'
  };

  export type EquipeTipoEquipeScalarFieldEnum = (typeof EquipeTipoEquipeScalarFieldEnum)[keyof typeof EquipeTipoEquipeScalarFieldEnum]


  export const EquipeRegiaoScalarFieldEnum: {
    equipeId: 'equipeId',
    regiaoId: 'regiaoId'
  };

  export type EquipeRegiaoScalarFieldEnum = (typeof EquipeRegiaoScalarFieldEnum)[keyof typeof EquipeRegiaoScalarFieldEnum]


  export const EquipePessoasScalarFieldEnum: {
    equipeId: 'equipeId',
    pessoaId: 'pessoaId'
  };

  export type EquipePessoasScalarFieldEnum = (typeof EquipePessoasScalarFieldEnum)[keyof typeof EquipePessoasScalarFieldEnum]


  export const LocalidadeScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao',
    dioceseId: 'dioceseId',
    tipoLocalidadeId: 'tipoLocalidadeId',
    observacao: 'observacao',
    enderecoId: 'enderecoId'
  };

  export type LocalidadeScalarFieldEnum = (typeof LocalidadeScalarFieldEnum)[keyof typeof LocalidadeScalarFieldEnum]


  export const LocalidadeRegiaoScalarFieldEnum: {
    localidadeId: 'localidadeId',
    regiaoId: 'regiaoId'
  };

  export type LocalidadeRegiaoScalarFieldEnum = (typeof LocalidadeRegiaoScalarFieldEnum)[keyof typeof LocalidadeRegiaoScalarFieldEnum]


  export const TipoLocalidadeScalarFieldEnum: {
    id: 'id',
    descricao: 'descricao'
  };

  export type TipoLocalidadeScalarFieldEnum = (typeof TipoLocalidadeScalarFieldEnum)[keyof typeof TipoLocalidadeScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    whatsapp: 'whatsapp',
    verifiedWhatsapp: 'verifiedWhatsapp',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Sexo'
   */
  export type EnumSexoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexo'>
    


  /**
   * Reference to a field of type 'Sexo[]'
   */
  export type ListEnumSexoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexo[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'roles'
   */
  export type EnumrolesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roles'>
    


  /**
   * Reference to a field of type 'roles[]'
   */
  export type ListEnumrolesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'roles[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type paisWhereInput = {
    AND?: paisWhereInput | paisWhereInput[]
    OR?: paisWhereInput[]
    NOT?: paisWhereInput | paisWhereInput[]
    id?: IntFilter<"pais"> | number
    isoAlpha2?: StringFilter<"pais"> | string
    nome?: StringFilter<"pais"> | string
    regiao?: StringFilter<"pais"> | string
    subRegiao?: StringFilter<"pais"> | string
    regiaoIntermediaria?: StringNullableFilter<"pais"> | string | null
    lingua?: StringFilter<"pais"> | string
    capital?: StringFilter<"pais"> | string
    estado?: EstadoListRelationFilter
  }

  export type paisOrderByWithRelationInput = {
    id?: SortOrder
    isoAlpha2?: SortOrder
    nome?: SortOrder
    regiao?: SortOrder
    subRegiao?: SortOrder
    regiaoIntermediaria?: SortOrderInput | SortOrder
    lingua?: SortOrder
    capital?: SortOrder
    estado?: estadoOrderByRelationAggregateInput
  }

  export type paisWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: paisWhereInput | paisWhereInput[]
    OR?: paisWhereInput[]
    NOT?: paisWhereInput | paisWhereInput[]
    isoAlpha2?: StringFilter<"pais"> | string
    regiao?: StringFilter<"pais"> | string
    subRegiao?: StringFilter<"pais"> | string
    regiaoIntermediaria?: StringNullableFilter<"pais"> | string | null
    lingua?: StringFilter<"pais"> | string
    capital?: StringFilter<"pais"> | string
    estado?: EstadoListRelationFilter
  }, "id" | "nome">

  export type paisOrderByWithAggregationInput = {
    id?: SortOrder
    isoAlpha2?: SortOrder
    nome?: SortOrder
    regiao?: SortOrder
    subRegiao?: SortOrder
    regiaoIntermediaria?: SortOrderInput | SortOrder
    lingua?: SortOrder
    capital?: SortOrder
    _count?: paisCountOrderByAggregateInput
    _avg?: paisAvgOrderByAggregateInput
    _max?: paisMaxOrderByAggregateInput
    _min?: paisMinOrderByAggregateInput
    _sum?: paisSumOrderByAggregateInput
  }

  export type paisScalarWhereWithAggregatesInput = {
    AND?: paisScalarWhereWithAggregatesInput | paisScalarWhereWithAggregatesInput[]
    OR?: paisScalarWhereWithAggregatesInput[]
    NOT?: paisScalarWhereWithAggregatesInput | paisScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pais"> | number
    isoAlpha2?: StringWithAggregatesFilter<"pais"> | string
    nome?: StringWithAggregatesFilter<"pais"> | string
    regiao?: StringWithAggregatesFilter<"pais"> | string
    subRegiao?: StringWithAggregatesFilter<"pais"> | string
    regiaoIntermediaria?: StringNullableWithAggregatesFilter<"pais"> | string | null
    lingua?: StringWithAggregatesFilter<"pais"> | string
    capital?: StringWithAggregatesFilter<"pais"> | string
  }

  export type estadoWhereInput = {
    AND?: estadoWhereInput | estadoWhereInput[]
    OR?: estadoWhereInput[]
    NOT?: estadoWhereInput | estadoWhereInput[]
    id?: IntFilter<"estado"> | number
    nome?: StringFilter<"estado"> | string
    sigla?: StringFilter<"estado"> | string
    ativo?: BoolFilter<"estado"> | boolean
    paisId?: IntFilter<"estado"> | number
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    cidade?: CidadeListRelationFilter
  }

  export type estadoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    paisId?: SortOrder
    pais?: paisOrderByWithRelationInput
    cidade?: cidadeOrderByRelationAggregateInput
  }

  export type estadoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    sigla?: string
    AND?: estadoWhereInput | estadoWhereInput[]
    OR?: estadoWhereInput[]
    NOT?: estadoWhereInput | estadoWhereInput[]
    ativo?: BoolFilter<"estado"> | boolean
    paisId?: IntFilter<"estado"> | number
    pais?: XOR<PaisScalarRelationFilter, paisWhereInput>
    cidade?: CidadeListRelationFilter
  }, "id" | "nome" | "sigla">

  export type estadoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    paisId?: SortOrder
    _count?: estadoCountOrderByAggregateInput
    _avg?: estadoAvgOrderByAggregateInput
    _max?: estadoMaxOrderByAggregateInput
    _min?: estadoMinOrderByAggregateInput
    _sum?: estadoSumOrderByAggregateInput
  }

  export type estadoScalarWhereWithAggregatesInput = {
    AND?: estadoScalarWhereWithAggregatesInput | estadoScalarWhereWithAggregatesInput[]
    OR?: estadoScalarWhereWithAggregatesInput[]
    NOT?: estadoScalarWhereWithAggregatesInput | estadoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"estado"> | number
    nome?: StringWithAggregatesFilter<"estado"> | string
    sigla?: StringWithAggregatesFilter<"estado"> | string
    ativo?: BoolWithAggregatesFilter<"estado"> | boolean
    paisId?: IntWithAggregatesFilter<"estado"> | number
  }

  export type cidadeWhereInput = {
    AND?: cidadeWhereInput | cidadeWhereInput[]
    OR?: cidadeWhereInput[]
    NOT?: cidadeWhereInput | cidadeWhereInput[]
    id?: IntFilter<"cidade"> | number
    nome?: StringFilter<"cidade"> | string
    estadoId?: IntFilter<"cidade"> | number
    ativo?: BoolFilter<"cidade"> | boolean
    estado?: XOR<EstadoScalarRelationFilter, estadoWhereInput>
  }

  export type cidadeOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    estadoId?: SortOrder
    ativo?: SortOrder
    estado?: estadoOrderByWithRelationInput
  }

  export type cidadeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: cidadeWhereInput | cidadeWhereInput[]
    OR?: cidadeWhereInput[]
    NOT?: cidadeWhereInput | cidadeWhereInput[]
    estadoId?: IntFilter<"cidade"> | number
    ativo?: BoolFilter<"cidade"> | boolean
    estado?: XOR<EstadoScalarRelationFilter, estadoWhereInput>
  }, "id" | "nome">

  export type cidadeOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    estadoId?: SortOrder
    ativo?: SortOrder
    _count?: cidadeCountOrderByAggregateInput
    _avg?: cidadeAvgOrderByAggregateInput
    _max?: cidadeMaxOrderByAggregateInput
    _min?: cidadeMinOrderByAggregateInput
    _sum?: cidadeSumOrderByAggregateInput
  }

  export type cidadeScalarWhereWithAggregatesInput = {
    AND?: cidadeScalarWhereWithAggregatesInput | cidadeScalarWhereWithAggregatesInput[]
    OR?: cidadeScalarWhereWithAggregatesInput[]
    NOT?: cidadeScalarWhereWithAggregatesInput | cidadeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cidade"> | number
    nome?: StringWithAggregatesFilter<"cidade"> | string
    estadoId?: IntWithAggregatesFilter<"cidade"> | number
    ativo?: BoolWithAggregatesFilter<"cidade"> | boolean
  }

  export type enderecoWhereInput = {
    AND?: enderecoWhereInput | enderecoWhereInput[]
    OR?: enderecoWhereInput[]
    NOT?: enderecoWhereInput | enderecoWhereInput[]
    id?: IntFilter<"endereco"> | number
    cep?: StringFilter<"endereco"> | string
    logradouro?: StringFilter<"endereco"> | string
    cidade?: StringFilter<"endereco"> | string
    bairro?: StringFilter<"endereco"> | string
    numero?: StringFilter<"endereco"> | string
    UF?: StringFilter<"endereco"> | string
    pais?: StringFilter<"endereco"> | string
    observacao?: StringNullableFilter<"endereco"> | string | null
    paroquias?: ParoquiaListRelationFilter
    pessoas?: PessoaEnderecoListRelationFilter
    localidade?: LocalidadeListRelationFilter
    diocese?: DioceseListRelationFilter
  }

  export type enderecoOrderByWithRelationInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    numero?: SortOrder
    UF?: SortOrder
    pais?: SortOrder
    observacao?: SortOrderInput | SortOrder
    paroquias?: paroquiaOrderByRelationAggregateInput
    pessoas?: pessoaEnderecoOrderByRelationAggregateInput
    localidade?: localidadeOrderByRelationAggregateInput
    diocese?: dioceseOrderByRelationAggregateInput
  }

  export type enderecoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: enderecoWhereInput | enderecoWhereInput[]
    OR?: enderecoWhereInput[]
    NOT?: enderecoWhereInput | enderecoWhereInput[]
    cep?: StringFilter<"endereco"> | string
    logradouro?: StringFilter<"endereco"> | string
    cidade?: StringFilter<"endereco"> | string
    bairro?: StringFilter<"endereco"> | string
    numero?: StringFilter<"endereco"> | string
    UF?: StringFilter<"endereco"> | string
    pais?: StringFilter<"endereco"> | string
    observacao?: StringNullableFilter<"endereco"> | string | null
    paroquias?: ParoquiaListRelationFilter
    pessoas?: PessoaEnderecoListRelationFilter
    localidade?: LocalidadeListRelationFilter
    diocese?: DioceseListRelationFilter
  }, "id">

  export type enderecoOrderByWithAggregationInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    numero?: SortOrder
    UF?: SortOrder
    pais?: SortOrder
    observacao?: SortOrderInput | SortOrder
    _count?: enderecoCountOrderByAggregateInput
    _avg?: enderecoAvgOrderByAggregateInput
    _max?: enderecoMaxOrderByAggregateInput
    _min?: enderecoMinOrderByAggregateInput
    _sum?: enderecoSumOrderByAggregateInput
  }

  export type enderecoScalarWhereWithAggregatesInput = {
    AND?: enderecoScalarWhereWithAggregatesInput | enderecoScalarWhereWithAggregatesInput[]
    OR?: enderecoScalarWhereWithAggregatesInput[]
    NOT?: enderecoScalarWhereWithAggregatesInput | enderecoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"endereco"> | number
    cep?: StringWithAggregatesFilter<"endereco"> | string
    logradouro?: StringWithAggregatesFilter<"endereco"> | string
    cidade?: StringWithAggregatesFilter<"endereco"> | string
    bairro?: StringWithAggregatesFilter<"endereco"> | string
    numero?: StringWithAggregatesFilter<"endereco"> | string
    UF?: StringWithAggregatesFilter<"endereco"> | string
    pais?: StringWithAggregatesFilter<"endereco"> | string
    observacao?: StringNullableWithAggregatesFilter<"endereco"> | string | null
  }

  export type tipoCarismaWhereInput = {
    AND?: tipoCarismaWhereInput | tipoCarismaWhereInput[]
    OR?: tipoCarismaWhereInput[]
    NOT?: tipoCarismaWhereInput | tipoCarismaWhereInput[]
    id?: IntFilter<"tipoCarisma"> | number
    descricao?: StringFilter<"tipoCarisma"> | string
    pessoaCarisma?: PessoaCarismaListRelationFilter
  }

  export type tipoCarismaOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    pessoaCarisma?: pessoaCarismaOrderByRelationAggregateInput
  }

  export type tipoCarismaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    descricao?: string
    AND?: tipoCarismaWhereInput | tipoCarismaWhereInput[]
    OR?: tipoCarismaWhereInput[]
    NOT?: tipoCarismaWhereInput | tipoCarismaWhereInput[]
    pessoaCarisma?: PessoaCarismaListRelationFilter
  }, "id" | "descricao">

  export type tipoCarismaOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: tipoCarismaCountOrderByAggregateInput
    _avg?: tipoCarismaAvgOrderByAggregateInput
    _max?: tipoCarismaMaxOrderByAggregateInput
    _min?: tipoCarismaMinOrderByAggregateInput
    _sum?: tipoCarismaSumOrderByAggregateInput
  }

  export type tipoCarismaScalarWhereWithAggregatesInput = {
    AND?: tipoCarismaScalarWhereWithAggregatesInput | tipoCarismaScalarWhereWithAggregatesInput[]
    OR?: tipoCarismaScalarWhereWithAggregatesInput[]
    NOT?: tipoCarismaScalarWhereWithAggregatesInput | tipoCarismaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tipoCarisma"> | number
    descricao?: StringWithAggregatesFilter<"tipoCarisma"> | string
  }

  export type estadoCivilWhereInput = {
    AND?: estadoCivilWhereInput | estadoCivilWhereInput[]
    OR?: estadoCivilWhereInput[]
    NOT?: estadoCivilWhereInput | estadoCivilWhereInput[]
    id?: IntFilter<"estadoCivil"> | number
    descricao?: StringFilter<"estadoCivil"> | string
    pessoas?: PessoaListRelationFilter
  }

  export type estadoCivilOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    pessoas?: pessoaOrderByRelationAggregateInput
  }

  export type estadoCivilWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    descricao?: string
    AND?: estadoCivilWhereInput | estadoCivilWhereInput[]
    OR?: estadoCivilWhereInput[]
    NOT?: estadoCivilWhereInput | estadoCivilWhereInput[]
    pessoas?: PessoaListRelationFilter
  }, "id" | "descricao">

  export type estadoCivilOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: estadoCivilCountOrderByAggregateInput
    _avg?: estadoCivilAvgOrderByAggregateInput
    _max?: estadoCivilMaxOrderByAggregateInput
    _min?: estadoCivilMinOrderByAggregateInput
    _sum?: estadoCivilSumOrderByAggregateInput
  }

  export type estadoCivilScalarWhereWithAggregatesInput = {
    AND?: estadoCivilScalarWhereWithAggregatesInput | estadoCivilScalarWhereWithAggregatesInput[]
    OR?: estadoCivilScalarWhereWithAggregatesInput[]
    NOT?: estadoCivilScalarWhereWithAggregatesInput | estadoCivilScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"estadoCivil"> | number
    descricao?: StringWithAggregatesFilter<"estadoCivil"> | string
  }

  export type escolaridadeWhereInput = {
    AND?: escolaridadeWhereInput | escolaridadeWhereInput[]
    OR?: escolaridadeWhereInput[]
    NOT?: escolaridadeWhereInput | escolaridadeWhereInput[]
    id?: IntFilter<"escolaridade"> | number
    descricao?: StringFilter<"escolaridade"> | string
    pessoas?: PessoaListRelationFilter
  }

  export type escolaridadeOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    pessoas?: pessoaOrderByRelationAggregateInput
  }

  export type escolaridadeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    descricao?: string
    AND?: escolaridadeWhereInput | escolaridadeWhereInput[]
    OR?: escolaridadeWhereInput[]
    NOT?: escolaridadeWhereInput | escolaridadeWhereInput[]
    pessoas?: PessoaListRelationFilter
  }, "id" | "descricao">

  export type escolaridadeOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: escolaridadeCountOrderByAggregateInput
    _avg?: escolaridadeAvgOrderByAggregateInput
    _max?: escolaridadeMaxOrderByAggregateInput
    _min?: escolaridadeMinOrderByAggregateInput
    _sum?: escolaridadeSumOrderByAggregateInput
  }

  export type escolaridadeScalarWhereWithAggregatesInput = {
    AND?: escolaridadeScalarWhereWithAggregatesInput | escolaridadeScalarWhereWithAggregatesInput[]
    OR?: escolaridadeScalarWhereWithAggregatesInput[]
    NOT?: escolaridadeScalarWhereWithAggregatesInput | escolaridadeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"escolaridade"> | number
    descricao?: StringWithAggregatesFilter<"escolaridade"> | string
  }

  export type pessoaWhereInput = {
    AND?: pessoaWhereInput | pessoaWhereInput[]
    OR?: pessoaWhereInput[]
    NOT?: pessoaWhereInput | pessoaWhereInput[]
    id?: IntFilter<"pessoa"> | number
    nome?: StringFilter<"pessoa"> | string
    conhecidoPor?: StringNullableFilter<"pessoa"> | string | null
    sexo?: EnumSexoFilter<"pessoa"> | $Enums.Sexo
    cpf?: StringNullableFilter<"pessoa"> | string | null
    nacionalidade?: StringFilter<"pessoa"> | string
    dataNascimento?: DateTimeNullableFilter<"pessoa"> | Date | string | null
    estadoCivilId?: IntFilter<"pessoa"> | number
    foto?: StringNullableFilter<"pessoa"> | string | null
    escolaridadeId?: IntNullableFilter<"pessoa"> | number | null
    ativo?: BoolFilter<"pessoa"> | boolean
    tipoPessoaId?: IntFilter<"pessoa"> | number
    estadoCivil?: XOR<EstadoCivilScalarRelationFilter, estadoCivilWhereInput>
    escolaridade?: XOR<EscolaridadeNullableScalarRelationFilter, escolaridadeWhereInput> | null
    tipoPessoa?: XOR<TipoPessoaScalarRelationFilter, tipoPessoaWhereInput>
    passaportes?: PassaportePessoaListRelationFilter
    contatos?: PessoaContatoListRelationFilter
    paroquias?: ParoquiaPessoasListRelationFilter
    casamentosComoMarido?: PessoaCasalListRelationFilter
    casamentosComoMulher?: PessoaCasalListRelationFilter
    enderecos?: PessoaEnderecoListRelationFilter
    equipes?: EquipePessoasListRelationFilter
    pessoaCarisma?: PessoaCarismaListRelationFilter
  }

  export type pessoaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    conhecidoPor?: SortOrderInput | SortOrder
    sexo?: SortOrder
    cpf?: SortOrderInput | SortOrder
    nacionalidade?: SortOrder
    dataNascimento?: SortOrderInput | SortOrder
    estadoCivilId?: SortOrder
    foto?: SortOrderInput | SortOrder
    escolaridadeId?: SortOrderInput | SortOrder
    ativo?: SortOrder
    tipoPessoaId?: SortOrder
    estadoCivil?: estadoCivilOrderByWithRelationInput
    escolaridade?: escolaridadeOrderByWithRelationInput
    tipoPessoa?: tipoPessoaOrderByWithRelationInput
    passaportes?: passaportePessoaOrderByRelationAggregateInput
    contatos?: pessoaContatoOrderByRelationAggregateInput
    paroquias?: paroquiaPessoasOrderByRelationAggregateInput
    casamentosComoMarido?: pessoaCasalOrderByRelationAggregateInput
    casamentosComoMulher?: pessoaCasalOrderByRelationAggregateInput
    enderecos?: pessoaEnderecoOrderByRelationAggregateInput
    equipes?: equipePessoasOrderByRelationAggregateInput
    pessoaCarisma?: pessoaCarismaOrderByRelationAggregateInput
  }

  export type pessoaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pessoaWhereInput | pessoaWhereInput[]
    OR?: pessoaWhereInput[]
    NOT?: pessoaWhereInput | pessoaWhereInput[]
    nome?: StringFilter<"pessoa"> | string
    conhecidoPor?: StringNullableFilter<"pessoa"> | string | null
    sexo?: EnumSexoFilter<"pessoa"> | $Enums.Sexo
    cpf?: StringNullableFilter<"pessoa"> | string | null
    nacionalidade?: StringFilter<"pessoa"> | string
    dataNascimento?: DateTimeNullableFilter<"pessoa"> | Date | string | null
    estadoCivilId?: IntFilter<"pessoa"> | number
    foto?: StringNullableFilter<"pessoa"> | string | null
    escolaridadeId?: IntNullableFilter<"pessoa"> | number | null
    ativo?: BoolFilter<"pessoa"> | boolean
    tipoPessoaId?: IntFilter<"pessoa"> | number
    estadoCivil?: XOR<EstadoCivilScalarRelationFilter, estadoCivilWhereInput>
    escolaridade?: XOR<EscolaridadeNullableScalarRelationFilter, escolaridadeWhereInput> | null
    tipoPessoa?: XOR<TipoPessoaScalarRelationFilter, tipoPessoaWhereInput>
    passaportes?: PassaportePessoaListRelationFilter
    contatos?: PessoaContatoListRelationFilter
    paroquias?: ParoquiaPessoasListRelationFilter
    casamentosComoMarido?: PessoaCasalListRelationFilter
    casamentosComoMulher?: PessoaCasalListRelationFilter
    enderecos?: PessoaEnderecoListRelationFilter
    equipes?: EquipePessoasListRelationFilter
    pessoaCarisma?: PessoaCarismaListRelationFilter
  }, "id">

  export type pessoaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    conhecidoPor?: SortOrderInput | SortOrder
    sexo?: SortOrder
    cpf?: SortOrderInput | SortOrder
    nacionalidade?: SortOrder
    dataNascimento?: SortOrderInput | SortOrder
    estadoCivilId?: SortOrder
    foto?: SortOrderInput | SortOrder
    escolaridadeId?: SortOrderInput | SortOrder
    ativo?: SortOrder
    tipoPessoaId?: SortOrder
    _count?: pessoaCountOrderByAggregateInput
    _avg?: pessoaAvgOrderByAggregateInput
    _max?: pessoaMaxOrderByAggregateInput
    _min?: pessoaMinOrderByAggregateInput
    _sum?: pessoaSumOrderByAggregateInput
  }

  export type pessoaScalarWhereWithAggregatesInput = {
    AND?: pessoaScalarWhereWithAggregatesInput | pessoaScalarWhereWithAggregatesInput[]
    OR?: pessoaScalarWhereWithAggregatesInput[]
    NOT?: pessoaScalarWhereWithAggregatesInput | pessoaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pessoa"> | number
    nome?: StringWithAggregatesFilter<"pessoa"> | string
    conhecidoPor?: StringNullableWithAggregatesFilter<"pessoa"> | string | null
    sexo?: EnumSexoWithAggregatesFilter<"pessoa"> | $Enums.Sexo
    cpf?: StringNullableWithAggregatesFilter<"pessoa"> | string | null
    nacionalidade?: StringWithAggregatesFilter<"pessoa"> | string
    dataNascimento?: DateTimeNullableWithAggregatesFilter<"pessoa"> | Date | string | null
    estadoCivilId?: IntWithAggregatesFilter<"pessoa"> | number
    foto?: StringNullableWithAggregatesFilter<"pessoa"> | string | null
    escolaridadeId?: IntNullableWithAggregatesFilter<"pessoa"> | number | null
    ativo?: BoolWithAggregatesFilter<"pessoa"> | boolean
    tipoPessoaId?: IntWithAggregatesFilter<"pessoa"> | number
  }

  export type tipoPessoaWhereInput = {
    AND?: tipoPessoaWhereInput | tipoPessoaWhereInput[]
    OR?: tipoPessoaWhereInput[]
    NOT?: tipoPessoaWhereInput | tipoPessoaWhereInput[]
    id?: IntFilter<"tipoPessoa"> | number
    descricao?: StringFilter<"tipoPessoa"> | string
    pessoa?: PessoaListRelationFilter
  }

  export type tipoPessoaOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    pessoa?: pessoaOrderByRelationAggregateInput
  }

  export type tipoPessoaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    descricao?: string
    AND?: tipoPessoaWhereInput | tipoPessoaWhereInput[]
    OR?: tipoPessoaWhereInput[]
    NOT?: tipoPessoaWhereInput | tipoPessoaWhereInput[]
    pessoa?: PessoaListRelationFilter
  }, "id" | "descricao">

  export type tipoPessoaOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: tipoPessoaCountOrderByAggregateInput
    _avg?: tipoPessoaAvgOrderByAggregateInput
    _max?: tipoPessoaMaxOrderByAggregateInput
    _min?: tipoPessoaMinOrderByAggregateInput
    _sum?: tipoPessoaSumOrderByAggregateInput
  }

  export type tipoPessoaScalarWhereWithAggregatesInput = {
    AND?: tipoPessoaScalarWhereWithAggregatesInput | tipoPessoaScalarWhereWithAggregatesInput[]
    OR?: tipoPessoaScalarWhereWithAggregatesInput[]
    NOT?: tipoPessoaScalarWhereWithAggregatesInput | tipoPessoaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tipoPessoa"> | number
    descricao?: StringWithAggregatesFilter<"tipoPessoa"> | string
  }

  export type pessoaEnderecoWhereInput = {
    AND?: pessoaEnderecoWhereInput | pessoaEnderecoWhereInput[]
    OR?: pessoaEnderecoWhereInput[]
    NOT?: pessoaEnderecoWhereInput | pessoaEnderecoWhereInput[]
    pessoaId?: IntFilter<"pessoaEndereco"> | number
    enderecoId?: IntFilter<"pessoaEndereco"> | number
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
    endereco?: XOR<EnderecoScalarRelationFilter, enderecoWhereInput>
  }

  export type pessoaEnderecoOrderByWithRelationInput = {
    pessoaId?: SortOrder
    enderecoId?: SortOrder
    pessoa?: pessoaOrderByWithRelationInput
    endereco?: enderecoOrderByWithRelationInput
  }

  export type pessoaEnderecoWhereUniqueInput = Prisma.AtLeast<{
    pessoaId_enderecoId?: pessoaEnderecoPessoaIdEnderecoIdCompoundUniqueInput
    AND?: pessoaEnderecoWhereInput | pessoaEnderecoWhereInput[]
    OR?: pessoaEnderecoWhereInput[]
    NOT?: pessoaEnderecoWhereInput | pessoaEnderecoWhereInput[]
    pessoaId?: IntFilter<"pessoaEndereco"> | number
    enderecoId?: IntFilter<"pessoaEndereco"> | number
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
    endereco?: XOR<EnderecoScalarRelationFilter, enderecoWhereInput>
  }, "pessoaId_enderecoId">

  export type pessoaEnderecoOrderByWithAggregationInput = {
    pessoaId?: SortOrder
    enderecoId?: SortOrder
    _count?: pessoaEnderecoCountOrderByAggregateInput
    _avg?: pessoaEnderecoAvgOrderByAggregateInput
    _max?: pessoaEnderecoMaxOrderByAggregateInput
    _min?: pessoaEnderecoMinOrderByAggregateInput
    _sum?: pessoaEnderecoSumOrderByAggregateInput
  }

  export type pessoaEnderecoScalarWhereWithAggregatesInput = {
    AND?: pessoaEnderecoScalarWhereWithAggregatesInput | pessoaEnderecoScalarWhereWithAggregatesInput[]
    OR?: pessoaEnderecoScalarWhereWithAggregatesInput[]
    NOT?: pessoaEnderecoScalarWhereWithAggregatesInput | pessoaEnderecoScalarWhereWithAggregatesInput[]
    pessoaId?: IntWithAggregatesFilter<"pessoaEndereco"> | number
    enderecoId?: IntWithAggregatesFilter<"pessoaEndereco"> | number
  }

  export type pessoaCasalWhereInput = {
    AND?: pessoaCasalWhereInput | pessoaCasalWhereInput[]
    OR?: pessoaCasalWhereInput[]
    NOT?: pessoaCasalWhereInput | pessoaCasalWhereInput[]
    id?: IntFilter<"pessoaCasal"> | number
    pessoaMaridoId?: IntFilter<"pessoaCasal"> | number
    pessoaMulherId?: IntFilter<"pessoaCasal"> | number
    marido?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
    mulher?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
  }

  export type pessoaCasalOrderByWithRelationInput = {
    id?: SortOrder
    pessoaMaridoId?: SortOrder
    pessoaMulherId?: SortOrder
    marido?: pessoaOrderByWithRelationInput
    mulher?: pessoaOrderByWithRelationInput
  }

  export type pessoaCasalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    pessoaMaridoId_pessoaMulherId?: pessoaCasalPessoaMaridoIdPessoaMulherIdCompoundUniqueInput
    AND?: pessoaCasalWhereInput | pessoaCasalWhereInput[]
    OR?: pessoaCasalWhereInput[]
    NOT?: pessoaCasalWhereInput | pessoaCasalWhereInput[]
    pessoaMaridoId?: IntFilter<"pessoaCasal"> | number
    pessoaMulherId?: IntFilter<"pessoaCasal"> | number
    marido?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
    mulher?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
  }, "id" | "pessoaMaridoId_pessoaMulherId">

  export type pessoaCasalOrderByWithAggregationInput = {
    id?: SortOrder
    pessoaMaridoId?: SortOrder
    pessoaMulherId?: SortOrder
    _count?: pessoaCasalCountOrderByAggregateInput
    _avg?: pessoaCasalAvgOrderByAggregateInput
    _max?: pessoaCasalMaxOrderByAggregateInput
    _min?: pessoaCasalMinOrderByAggregateInput
    _sum?: pessoaCasalSumOrderByAggregateInput
  }

  export type pessoaCasalScalarWhereWithAggregatesInput = {
    AND?: pessoaCasalScalarWhereWithAggregatesInput | pessoaCasalScalarWhereWithAggregatesInput[]
    OR?: pessoaCasalScalarWhereWithAggregatesInput[]
    NOT?: pessoaCasalScalarWhereWithAggregatesInput | pessoaCasalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pessoaCasal"> | number
    pessoaMaridoId?: IntWithAggregatesFilter<"pessoaCasal"> | number
    pessoaMulherId?: IntWithAggregatesFilter<"pessoaCasal"> | number
  }

  export type pessoaCarismaWhereInput = {
    AND?: pessoaCarismaWhereInput | pessoaCarismaWhereInput[]
    OR?: pessoaCarismaWhereInput[]
    NOT?: pessoaCarismaWhereInput | pessoaCarismaWhereInput[]
    pessoaId?: IntFilter<"pessoaCarisma"> | number
    tipoCarismaId?: IntFilter<"pessoaCarisma"> | number
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
    tipoCarisma?: XOR<TipoCarismaScalarRelationFilter, tipoCarismaWhereInput>
  }

  export type pessoaCarismaOrderByWithRelationInput = {
    pessoaId?: SortOrder
    tipoCarismaId?: SortOrder
    pessoa?: pessoaOrderByWithRelationInput
    tipoCarisma?: tipoCarismaOrderByWithRelationInput
  }

  export type pessoaCarismaWhereUniqueInput = Prisma.AtLeast<{
    pessoaId_tipoCarismaId?: pessoaCarismaPessoaIdTipoCarismaIdCompoundUniqueInput
    AND?: pessoaCarismaWhereInput | pessoaCarismaWhereInput[]
    OR?: pessoaCarismaWhereInput[]
    NOT?: pessoaCarismaWhereInput | pessoaCarismaWhereInput[]
    pessoaId?: IntFilter<"pessoaCarisma"> | number
    tipoCarismaId?: IntFilter<"pessoaCarisma"> | number
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
    tipoCarisma?: XOR<TipoCarismaScalarRelationFilter, tipoCarismaWhereInput>
  }, "pessoaId_tipoCarismaId">

  export type pessoaCarismaOrderByWithAggregationInput = {
    pessoaId?: SortOrder
    tipoCarismaId?: SortOrder
    _count?: pessoaCarismaCountOrderByAggregateInput
    _avg?: pessoaCarismaAvgOrderByAggregateInput
    _max?: pessoaCarismaMaxOrderByAggregateInput
    _min?: pessoaCarismaMinOrderByAggregateInput
    _sum?: pessoaCarismaSumOrderByAggregateInput
  }

  export type pessoaCarismaScalarWhereWithAggregatesInput = {
    AND?: pessoaCarismaScalarWhereWithAggregatesInput | pessoaCarismaScalarWhereWithAggregatesInput[]
    OR?: pessoaCarismaScalarWhereWithAggregatesInput[]
    NOT?: pessoaCarismaScalarWhereWithAggregatesInput | pessoaCarismaScalarWhereWithAggregatesInput[]
    pessoaId?: IntWithAggregatesFilter<"pessoaCarisma"> | number
    tipoCarismaId?: IntWithAggregatesFilter<"pessoaCarisma"> | number
  }

  export type passaportePessoaWhereInput = {
    AND?: passaportePessoaWhereInput | passaportePessoaWhereInput[]
    OR?: passaportePessoaWhereInput[]
    NOT?: passaportePessoaWhereInput | passaportePessoaWhereInput[]
    id?: IntFilter<"passaportePessoa"> | number
    pessoaId?: IntFilter<"passaportePessoa"> | number
    numero?: StringFilter<"passaportePessoa"> | string
    dataExpiracao?: DateTimeFilter<"passaportePessoa"> | Date | string
    renovado?: BoolFilter<"passaportePessoa"> | boolean
    dataRenovacao?: DateTimeNullableFilter<"passaportePessoa"> | Date | string | null
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
  }

  export type passaportePessoaOrderByWithRelationInput = {
    id?: SortOrder
    pessoaId?: SortOrder
    numero?: SortOrder
    dataExpiracao?: SortOrder
    renovado?: SortOrder
    dataRenovacao?: SortOrderInput | SortOrder
    pessoa?: pessoaOrderByWithRelationInput
  }

  export type passaportePessoaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: passaportePessoaWhereInput | passaportePessoaWhereInput[]
    OR?: passaportePessoaWhereInput[]
    NOT?: passaportePessoaWhereInput | passaportePessoaWhereInput[]
    pessoaId?: IntFilter<"passaportePessoa"> | number
    numero?: StringFilter<"passaportePessoa"> | string
    dataExpiracao?: DateTimeFilter<"passaportePessoa"> | Date | string
    renovado?: BoolFilter<"passaportePessoa"> | boolean
    dataRenovacao?: DateTimeNullableFilter<"passaportePessoa"> | Date | string | null
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
  }, "id">

  export type passaportePessoaOrderByWithAggregationInput = {
    id?: SortOrder
    pessoaId?: SortOrder
    numero?: SortOrder
    dataExpiracao?: SortOrder
    renovado?: SortOrder
    dataRenovacao?: SortOrderInput | SortOrder
    _count?: passaportePessoaCountOrderByAggregateInput
    _avg?: passaportePessoaAvgOrderByAggregateInput
    _max?: passaportePessoaMaxOrderByAggregateInput
    _min?: passaportePessoaMinOrderByAggregateInput
    _sum?: passaportePessoaSumOrderByAggregateInput
  }

  export type passaportePessoaScalarWhereWithAggregatesInput = {
    AND?: passaportePessoaScalarWhereWithAggregatesInput | passaportePessoaScalarWhereWithAggregatesInput[]
    OR?: passaportePessoaScalarWhereWithAggregatesInput[]
    NOT?: passaportePessoaScalarWhereWithAggregatesInput | passaportePessoaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"passaportePessoa"> | number
    pessoaId?: IntWithAggregatesFilter<"passaportePessoa"> | number
    numero?: StringWithAggregatesFilter<"passaportePessoa"> | string
    dataExpiracao?: DateTimeWithAggregatesFilter<"passaportePessoa"> | Date | string
    renovado?: BoolWithAggregatesFilter<"passaportePessoa"> | boolean
    dataRenovacao?: DateTimeNullableWithAggregatesFilter<"passaportePessoa"> | Date | string | null
  }

  export type pessoaContatoWhereInput = {
    AND?: pessoaContatoWhereInput | pessoaContatoWhereInput[]
    OR?: pessoaContatoWhereInput[]
    NOT?: pessoaContatoWhereInput | pessoaContatoWhereInput[]
    id?: IntFilter<"pessoaContato"> | number
    telefoneResidencial?: StringNullableFilter<"pessoaContato"> | string | null
    telefoneCelular?: StringNullableFilter<"pessoaContato"> | string | null
    observacao?: StringNullableFilter<"pessoaContato"> | string | null
    ativo?: BoolFilter<"pessoaContato"> | boolean
    email?: StringNullableFilter<"pessoaContato"> | string | null
    pessoaId?: IntFilter<"pessoaContato"> | number
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
  }

  export type pessoaContatoOrderByWithRelationInput = {
    id?: SortOrder
    telefoneResidencial?: SortOrderInput | SortOrder
    telefoneCelular?: SortOrderInput | SortOrder
    observacao?: SortOrderInput | SortOrder
    ativo?: SortOrder
    email?: SortOrderInput | SortOrder
    pessoaId?: SortOrder
    pessoa?: pessoaOrderByWithRelationInput
  }

  export type pessoaContatoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: pessoaContatoWhereInput | pessoaContatoWhereInput[]
    OR?: pessoaContatoWhereInput[]
    NOT?: pessoaContatoWhereInput | pessoaContatoWhereInput[]
    telefoneResidencial?: StringNullableFilter<"pessoaContato"> | string | null
    telefoneCelular?: StringNullableFilter<"pessoaContato"> | string | null
    observacao?: StringNullableFilter<"pessoaContato"> | string | null
    ativo?: BoolFilter<"pessoaContato"> | boolean
    email?: StringNullableFilter<"pessoaContato"> | string | null
    pessoaId?: IntFilter<"pessoaContato"> | number
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
  }, "id">

  export type pessoaContatoOrderByWithAggregationInput = {
    id?: SortOrder
    telefoneResidencial?: SortOrderInput | SortOrder
    telefoneCelular?: SortOrderInput | SortOrder
    observacao?: SortOrderInput | SortOrder
    ativo?: SortOrder
    email?: SortOrderInput | SortOrder
    pessoaId?: SortOrder
    _count?: pessoaContatoCountOrderByAggregateInput
    _avg?: pessoaContatoAvgOrderByAggregateInput
    _max?: pessoaContatoMaxOrderByAggregateInput
    _min?: pessoaContatoMinOrderByAggregateInput
    _sum?: pessoaContatoSumOrderByAggregateInput
  }

  export type pessoaContatoScalarWhereWithAggregatesInput = {
    AND?: pessoaContatoScalarWhereWithAggregatesInput | pessoaContatoScalarWhereWithAggregatesInput[]
    OR?: pessoaContatoScalarWhereWithAggregatesInput[]
    NOT?: pessoaContatoScalarWhereWithAggregatesInput | pessoaContatoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"pessoaContato"> | number
    telefoneResidencial?: StringNullableWithAggregatesFilter<"pessoaContato"> | string | null
    telefoneCelular?: StringNullableWithAggregatesFilter<"pessoaContato"> | string | null
    observacao?: StringNullableWithAggregatesFilter<"pessoaContato"> | string | null
    ativo?: BoolWithAggregatesFilter<"pessoaContato"> | boolean
    email?: StringNullableWithAggregatesFilter<"pessoaContato"> | string | null
    pessoaId?: IntWithAggregatesFilter<"pessoaContato"> | number
  }

  export type tipoDioceseWhereInput = {
    AND?: tipoDioceseWhereInput | tipoDioceseWhereInput[]
    OR?: tipoDioceseWhereInput[]
    NOT?: tipoDioceseWhereInput | tipoDioceseWhereInput[]
    id?: IntFilter<"tipoDiocese"> | number
    descricao?: StringFilter<"tipoDiocese"> | string
    dioceses?: DioceseListRelationFilter
  }

  export type tipoDioceseOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    dioceses?: dioceseOrderByRelationAggregateInput
  }

  export type tipoDioceseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tipoDioceseWhereInput | tipoDioceseWhereInput[]
    OR?: tipoDioceseWhereInput[]
    NOT?: tipoDioceseWhereInput | tipoDioceseWhereInput[]
    descricao?: StringFilter<"tipoDiocese"> | string
    dioceses?: DioceseListRelationFilter
  }, "id">

  export type tipoDioceseOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: tipoDioceseCountOrderByAggregateInput
    _avg?: tipoDioceseAvgOrderByAggregateInput
    _max?: tipoDioceseMaxOrderByAggregateInput
    _min?: tipoDioceseMinOrderByAggregateInput
    _sum?: tipoDioceseSumOrderByAggregateInput
  }

  export type tipoDioceseScalarWhereWithAggregatesInput = {
    AND?: tipoDioceseScalarWhereWithAggregatesInput | tipoDioceseScalarWhereWithAggregatesInput[]
    OR?: tipoDioceseScalarWhereWithAggregatesInput[]
    NOT?: tipoDioceseScalarWhereWithAggregatesInput | tipoDioceseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tipoDiocese"> | number
    descricao?: StringWithAggregatesFilter<"tipoDiocese"> | string
  }

  export type dioceseWhereInput = {
    AND?: dioceseWhereInput | dioceseWhereInput[]
    OR?: dioceseWhereInput[]
    NOT?: dioceseWhereInput | dioceseWhereInput[]
    id?: IntFilter<"diocese"> | number
    tipoDioceseId?: IntFilter<"diocese"> | number
    descricao?: StringFilter<"diocese"> | string
    enderecoId?: IntFilter<"diocese"> | number
    tipoDiocese?: XOR<TipoDioceseScalarRelationFilter, tipoDioceseWhereInput>
    endereco?: XOR<EnderecoScalarRelationFilter, enderecoWhereInput>
    paroquias?: ParoquiaListRelationFilter
    localidade?: LocalidadeListRelationFilter
  }

  export type dioceseOrderByWithRelationInput = {
    id?: SortOrder
    tipoDioceseId?: SortOrder
    descricao?: SortOrder
    enderecoId?: SortOrder
    tipoDiocese?: tipoDioceseOrderByWithRelationInput
    endereco?: enderecoOrderByWithRelationInput
    paroquias?: paroquiaOrderByRelationAggregateInput
    localidade?: localidadeOrderByRelationAggregateInput
  }

  export type dioceseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: dioceseWhereInput | dioceseWhereInput[]
    OR?: dioceseWhereInput[]
    NOT?: dioceseWhereInput | dioceseWhereInput[]
    tipoDioceseId?: IntFilter<"diocese"> | number
    descricao?: StringFilter<"diocese"> | string
    enderecoId?: IntFilter<"diocese"> | number
    tipoDiocese?: XOR<TipoDioceseScalarRelationFilter, tipoDioceseWhereInput>
    endereco?: XOR<EnderecoScalarRelationFilter, enderecoWhereInput>
    paroquias?: ParoquiaListRelationFilter
    localidade?: LocalidadeListRelationFilter
  }, "id">

  export type dioceseOrderByWithAggregationInput = {
    id?: SortOrder
    tipoDioceseId?: SortOrder
    descricao?: SortOrder
    enderecoId?: SortOrder
    _count?: dioceseCountOrderByAggregateInput
    _avg?: dioceseAvgOrderByAggregateInput
    _max?: dioceseMaxOrderByAggregateInput
    _min?: dioceseMinOrderByAggregateInput
    _sum?: dioceseSumOrderByAggregateInput
  }

  export type dioceseScalarWhereWithAggregatesInput = {
    AND?: dioceseScalarWhereWithAggregatesInput | dioceseScalarWhereWithAggregatesInput[]
    OR?: dioceseScalarWhereWithAggregatesInput[]
    NOT?: dioceseScalarWhereWithAggregatesInput | dioceseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"diocese"> | number
    tipoDioceseId?: IntWithAggregatesFilter<"diocese"> | number
    descricao?: StringWithAggregatesFilter<"diocese"> | string
    enderecoId?: IntWithAggregatesFilter<"diocese"> | number
  }

  export type paroquiaWhereInput = {
    AND?: paroquiaWhereInput | paroquiaWhereInput[]
    OR?: paroquiaWhereInput[]
    NOT?: paroquiaWhereInput | paroquiaWhereInput[]
    id?: IntFilter<"paroquia"> | number
    enderecoId?: IntFilter<"paroquia"> | number
    dioceseId?: IntFilter<"paroquia"> | number
    descricao?: StringFilter<"paroquia"> | string
    endereco?: XOR<EnderecoScalarRelationFilter, enderecoWhereInput>
    diocese?: XOR<DioceseScalarRelationFilter, dioceseWhereInput>
    pessoas?: ParoquiaPessoasListRelationFilter
  }

  export type paroquiaOrderByWithRelationInput = {
    id?: SortOrder
    enderecoId?: SortOrder
    dioceseId?: SortOrder
    descricao?: SortOrder
    endereco?: enderecoOrderByWithRelationInput
    diocese?: dioceseOrderByWithRelationInput
    pessoas?: paroquiaPessoasOrderByRelationAggregateInput
  }

  export type paroquiaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: paroquiaWhereInput | paroquiaWhereInput[]
    OR?: paroquiaWhereInput[]
    NOT?: paroquiaWhereInput | paroquiaWhereInput[]
    enderecoId?: IntFilter<"paroquia"> | number
    dioceseId?: IntFilter<"paroquia"> | number
    descricao?: StringFilter<"paroquia"> | string
    endereco?: XOR<EnderecoScalarRelationFilter, enderecoWhereInput>
    diocese?: XOR<DioceseScalarRelationFilter, dioceseWhereInput>
    pessoas?: ParoquiaPessoasListRelationFilter
  }, "id">

  export type paroquiaOrderByWithAggregationInput = {
    id?: SortOrder
    enderecoId?: SortOrder
    dioceseId?: SortOrder
    descricao?: SortOrder
    _count?: paroquiaCountOrderByAggregateInput
    _avg?: paroquiaAvgOrderByAggregateInput
    _max?: paroquiaMaxOrderByAggregateInput
    _min?: paroquiaMinOrderByAggregateInput
    _sum?: paroquiaSumOrderByAggregateInput
  }

  export type paroquiaScalarWhereWithAggregatesInput = {
    AND?: paroquiaScalarWhereWithAggregatesInput | paroquiaScalarWhereWithAggregatesInput[]
    OR?: paroquiaScalarWhereWithAggregatesInput[]
    NOT?: paroquiaScalarWhereWithAggregatesInput | paroquiaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"paroquia"> | number
    enderecoId?: IntWithAggregatesFilter<"paroquia"> | number
    dioceseId?: IntWithAggregatesFilter<"paroquia"> | number
    descricao?: StringWithAggregatesFilter<"paroquia"> | string
  }

  export type paroquiaPessoasWhereInput = {
    AND?: paroquiaPessoasWhereInput | paroquiaPessoasWhereInput[]
    OR?: paroquiaPessoasWhereInput[]
    NOT?: paroquiaPessoasWhereInput | paroquiaPessoasWhereInput[]
    pessoaId?: IntFilter<"paroquiaPessoas"> | number
    paroquiaId?: IntFilter<"paroquiaPessoas"> | number
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
    paroquia?: XOR<ParoquiaScalarRelationFilter, paroquiaWhereInput>
  }

  export type paroquiaPessoasOrderByWithRelationInput = {
    pessoaId?: SortOrder
    paroquiaId?: SortOrder
    pessoa?: pessoaOrderByWithRelationInput
    paroquia?: paroquiaOrderByWithRelationInput
  }

  export type paroquiaPessoasWhereUniqueInput = Prisma.AtLeast<{
    pessoaId_paroquiaId?: paroquiaPessoasPessoaIdParoquiaIdCompoundUniqueInput
    AND?: paroquiaPessoasWhereInput | paroquiaPessoasWhereInput[]
    OR?: paroquiaPessoasWhereInput[]
    NOT?: paroquiaPessoasWhereInput | paroquiaPessoasWhereInput[]
    pessoaId?: IntFilter<"paroquiaPessoas"> | number
    paroquiaId?: IntFilter<"paroquiaPessoas"> | number
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
    paroquia?: XOR<ParoquiaScalarRelationFilter, paroquiaWhereInput>
  }, "pessoaId_paroquiaId">

  export type paroquiaPessoasOrderByWithAggregationInput = {
    pessoaId?: SortOrder
    paroquiaId?: SortOrder
    _count?: paroquiaPessoasCountOrderByAggregateInput
    _avg?: paroquiaPessoasAvgOrderByAggregateInput
    _max?: paroquiaPessoasMaxOrderByAggregateInput
    _min?: paroquiaPessoasMinOrderByAggregateInput
    _sum?: paroquiaPessoasSumOrderByAggregateInput
  }

  export type paroquiaPessoasScalarWhereWithAggregatesInput = {
    AND?: paroquiaPessoasScalarWhereWithAggregatesInput | paroquiaPessoasScalarWhereWithAggregatesInput[]
    OR?: paroquiaPessoasScalarWhereWithAggregatesInput[]
    NOT?: paroquiaPessoasScalarWhereWithAggregatesInput | paroquiaPessoasScalarWhereWithAggregatesInput[]
    pessoaId?: IntWithAggregatesFilter<"paroquiaPessoas"> | number
    paroquiaId?: IntWithAggregatesFilter<"paroquiaPessoas"> | number
  }

  export type etapaWhereInput = {
    AND?: etapaWhereInput | etapaWhereInput[]
    OR?: etapaWhereInput[]
    NOT?: etapaWhereInput | etapaWhereInput[]
    id?: IntFilter<"etapa"> | number
    descricao?: StringFilter<"etapa"> | string
  }

  export type etapaOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type etapaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: etapaWhereInput | etapaWhereInput[]
    OR?: etapaWhereInput[]
    NOT?: etapaWhereInput | etapaWhereInput[]
    descricao?: StringFilter<"etapa"> | string
  }, "id">

  export type etapaOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: etapaCountOrderByAggregateInput
    _avg?: etapaAvgOrderByAggregateInput
    _max?: etapaMaxOrderByAggregateInput
    _min?: etapaMinOrderByAggregateInput
    _sum?: etapaSumOrderByAggregateInput
  }

  export type etapaScalarWhereWithAggregatesInput = {
    AND?: etapaScalarWhereWithAggregatesInput | etapaScalarWhereWithAggregatesInput[]
    OR?: etapaScalarWhereWithAggregatesInput[]
    NOT?: etapaScalarWhereWithAggregatesInput | etapaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"etapa"> | number
    descricao?: StringWithAggregatesFilter<"etapa"> | string
  }

  export type regiaoWhereInput = {
    AND?: regiaoWhereInput | regiaoWhereInput[]
    OR?: regiaoWhereInput[]
    NOT?: regiaoWhereInput | regiaoWhereInput[]
    id?: IntFilter<"regiao"> | number
    descricao?: StringFilter<"regiao"> | string
    macroRegiao?: BoolFilter<"regiao"> | boolean
    equipes?: EquipeRegiaoListRelationFilter
    localidadeRegiao?: LocalidadeRegiaoListRelationFilter
  }

  export type regiaoOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    macroRegiao?: SortOrder
    equipes?: equipeRegiaoOrderByRelationAggregateInput
    localidadeRegiao?: localidadeRegiaoOrderByRelationAggregateInput
  }

  export type regiaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: regiaoWhereInput | regiaoWhereInput[]
    OR?: regiaoWhereInput[]
    NOT?: regiaoWhereInput | regiaoWhereInput[]
    descricao?: StringFilter<"regiao"> | string
    macroRegiao?: BoolFilter<"regiao"> | boolean
    equipes?: EquipeRegiaoListRelationFilter
    localidadeRegiao?: LocalidadeRegiaoListRelationFilter
  }, "id">

  export type regiaoOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    macroRegiao?: SortOrder
    _count?: regiaoCountOrderByAggregateInput
    _avg?: regiaoAvgOrderByAggregateInput
    _max?: regiaoMaxOrderByAggregateInput
    _min?: regiaoMinOrderByAggregateInput
    _sum?: regiaoSumOrderByAggregateInput
  }

  export type regiaoScalarWhereWithAggregatesInput = {
    AND?: regiaoScalarWhereWithAggregatesInput | regiaoScalarWhereWithAggregatesInput[]
    OR?: regiaoScalarWhereWithAggregatesInput[]
    NOT?: regiaoScalarWhereWithAggregatesInput | regiaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"regiao"> | number
    descricao?: StringWithAggregatesFilter<"regiao"> | string
    macroRegiao?: BoolWithAggregatesFilter<"regiao"> | boolean
  }

  export type tipoEquipeWhereInput = {
    AND?: tipoEquipeWhereInput | tipoEquipeWhereInput[]
    OR?: tipoEquipeWhereInput[]
    NOT?: tipoEquipeWhereInput | tipoEquipeWhereInput[]
    id?: IntFilter<"tipoEquipe"> | number
    descricao?: StringFilter<"tipoEquipe"> | string
    equipes?: EquipeTipoEquipeListRelationFilter
  }

  export type tipoEquipeOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    equipes?: equipeTipoEquipeOrderByRelationAggregateInput
  }

  export type tipoEquipeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tipoEquipeWhereInput | tipoEquipeWhereInput[]
    OR?: tipoEquipeWhereInput[]
    NOT?: tipoEquipeWhereInput | tipoEquipeWhereInput[]
    descricao?: StringFilter<"tipoEquipe"> | string
    equipes?: EquipeTipoEquipeListRelationFilter
  }, "id">

  export type tipoEquipeOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: tipoEquipeCountOrderByAggregateInput
    _avg?: tipoEquipeAvgOrderByAggregateInput
    _max?: tipoEquipeMaxOrderByAggregateInput
    _min?: tipoEquipeMinOrderByAggregateInput
    _sum?: tipoEquipeSumOrderByAggregateInput
  }

  export type tipoEquipeScalarWhereWithAggregatesInput = {
    AND?: tipoEquipeScalarWhereWithAggregatesInput | tipoEquipeScalarWhereWithAggregatesInput[]
    OR?: tipoEquipeScalarWhereWithAggregatesInput[]
    NOT?: tipoEquipeScalarWhereWithAggregatesInput | tipoEquipeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tipoEquipe"> | number
    descricao?: StringWithAggregatesFilter<"tipoEquipe"> | string
  }

  export type equipeWhereInput = {
    AND?: equipeWhereInput | equipeWhereInput[]
    OR?: equipeWhereInput[]
    NOT?: equipeWhereInput | equipeWhereInput[]
    id?: IntFilter<"equipe"> | number
    descricao?: StringFilter<"equipe"> | string
    regioes?: EquipeRegiaoListRelationFilter
    equipePessoas?: EquipePessoasListRelationFilter
    tipos?: EquipeTipoEquipeListRelationFilter
  }

  export type equipeOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    regioes?: equipeRegiaoOrderByRelationAggregateInput
    equipePessoas?: equipePessoasOrderByRelationAggregateInput
    tipos?: equipeTipoEquipeOrderByRelationAggregateInput
  }

  export type equipeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: equipeWhereInput | equipeWhereInput[]
    OR?: equipeWhereInput[]
    NOT?: equipeWhereInput | equipeWhereInput[]
    descricao?: StringFilter<"equipe"> | string
    regioes?: EquipeRegiaoListRelationFilter
    equipePessoas?: EquipePessoasListRelationFilter
    tipos?: EquipeTipoEquipeListRelationFilter
  }, "id">

  export type equipeOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: equipeCountOrderByAggregateInput
    _avg?: equipeAvgOrderByAggregateInput
    _max?: equipeMaxOrderByAggregateInput
    _min?: equipeMinOrderByAggregateInput
    _sum?: equipeSumOrderByAggregateInput
  }

  export type equipeScalarWhereWithAggregatesInput = {
    AND?: equipeScalarWhereWithAggregatesInput | equipeScalarWhereWithAggregatesInput[]
    OR?: equipeScalarWhereWithAggregatesInput[]
    NOT?: equipeScalarWhereWithAggregatesInput | equipeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"equipe"> | number
    descricao?: StringWithAggregatesFilter<"equipe"> | string
  }

  export type equipeTipoEquipeWhereInput = {
    AND?: equipeTipoEquipeWhereInput | equipeTipoEquipeWhereInput[]
    OR?: equipeTipoEquipeWhereInput[]
    NOT?: equipeTipoEquipeWhereInput | equipeTipoEquipeWhereInput[]
    equipeId?: IntFilter<"equipeTipoEquipe"> | number
    tipoEquipeId?: IntFilter<"equipeTipoEquipe"> | number
    equipe?: XOR<EquipeScalarRelationFilter, equipeWhereInput>
    tipoEquipe?: XOR<TipoEquipeScalarRelationFilter, tipoEquipeWhereInput>
  }

  export type equipeTipoEquipeOrderByWithRelationInput = {
    equipeId?: SortOrder
    tipoEquipeId?: SortOrder
    equipe?: equipeOrderByWithRelationInput
    tipoEquipe?: tipoEquipeOrderByWithRelationInput
  }

  export type equipeTipoEquipeWhereUniqueInput = Prisma.AtLeast<{
    equipeId_tipoEquipeId?: equipeTipoEquipeEquipeIdTipoEquipeIdCompoundUniqueInput
    AND?: equipeTipoEquipeWhereInput | equipeTipoEquipeWhereInput[]
    OR?: equipeTipoEquipeWhereInput[]
    NOT?: equipeTipoEquipeWhereInput | equipeTipoEquipeWhereInput[]
    equipeId?: IntFilter<"equipeTipoEquipe"> | number
    tipoEquipeId?: IntFilter<"equipeTipoEquipe"> | number
    equipe?: XOR<EquipeScalarRelationFilter, equipeWhereInput>
    tipoEquipe?: XOR<TipoEquipeScalarRelationFilter, tipoEquipeWhereInput>
  }, "equipeId_tipoEquipeId">

  export type equipeTipoEquipeOrderByWithAggregationInput = {
    equipeId?: SortOrder
    tipoEquipeId?: SortOrder
    _count?: equipeTipoEquipeCountOrderByAggregateInput
    _avg?: equipeTipoEquipeAvgOrderByAggregateInput
    _max?: equipeTipoEquipeMaxOrderByAggregateInput
    _min?: equipeTipoEquipeMinOrderByAggregateInput
    _sum?: equipeTipoEquipeSumOrderByAggregateInput
  }

  export type equipeTipoEquipeScalarWhereWithAggregatesInput = {
    AND?: equipeTipoEquipeScalarWhereWithAggregatesInput | equipeTipoEquipeScalarWhereWithAggregatesInput[]
    OR?: equipeTipoEquipeScalarWhereWithAggregatesInput[]
    NOT?: equipeTipoEquipeScalarWhereWithAggregatesInput | equipeTipoEquipeScalarWhereWithAggregatesInput[]
    equipeId?: IntWithAggregatesFilter<"equipeTipoEquipe"> | number
    tipoEquipeId?: IntWithAggregatesFilter<"equipeTipoEquipe"> | number
  }

  export type equipeRegiaoWhereInput = {
    AND?: equipeRegiaoWhereInput | equipeRegiaoWhereInput[]
    OR?: equipeRegiaoWhereInput[]
    NOT?: equipeRegiaoWhereInput | equipeRegiaoWhereInput[]
    equipeId?: IntFilter<"equipeRegiao"> | number
    regiaoId?: IntFilter<"equipeRegiao"> | number
    equipe?: XOR<EquipeScalarRelationFilter, equipeWhereInput>
    regiao?: XOR<RegiaoScalarRelationFilter, regiaoWhereInput>
  }

  export type equipeRegiaoOrderByWithRelationInput = {
    equipeId?: SortOrder
    regiaoId?: SortOrder
    equipe?: equipeOrderByWithRelationInput
    regiao?: regiaoOrderByWithRelationInput
  }

  export type equipeRegiaoWhereUniqueInput = Prisma.AtLeast<{
    equipeId_regiaoId?: equipeRegiaoEquipeIdRegiaoIdCompoundUniqueInput
    AND?: equipeRegiaoWhereInput | equipeRegiaoWhereInput[]
    OR?: equipeRegiaoWhereInput[]
    NOT?: equipeRegiaoWhereInput | equipeRegiaoWhereInput[]
    equipeId?: IntFilter<"equipeRegiao"> | number
    regiaoId?: IntFilter<"equipeRegiao"> | number
    equipe?: XOR<EquipeScalarRelationFilter, equipeWhereInput>
    regiao?: XOR<RegiaoScalarRelationFilter, regiaoWhereInput>
  }, "equipeId_regiaoId">

  export type equipeRegiaoOrderByWithAggregationInput = {
    equipeId?: SortOrder
    regiaoId?: SortOrder
    _count?: equipeRegiaoCountOrderByAggregateInput
    _avg?: equipeRegiaoAvgOrderByAggregateInput
    _max?: equipeRegiaoMaxOrderByAggregateInput
    _min?: equipeRegiaoMinOrderByAggregateInput
    _sum?: equipeRegiaoSumOrderByAggregateInput
  }

  export type equipeRegiaoScalarWhereWithAggregatesInput = {
    AND?: equipeRegiaoScalarWhereWithAggregatesInput | equipeRegiaoScalarWhereWithAggregatesInput[]
    OR?: equipeRegiaoScalarWhereWithAggregatesInput[]
    NOT?: equipeRegiaoScalarWhereWithAggregatesInput | equipeRegiaoScalarWhereWithAggregatesInput[]
    equipeId?: IntWithAggregatesFilter<"equipeRegiao"> | number
    regiaoId?: IntWithAggregatesFilter<"equipeRegiao"> | number
  }

  export type equipePessoasWhereInput = {
    AND?: equipePessoasWhereInput | equipePessoasWhereInput[]
    OR?: equipePessoasWhereInput[]
    NOT?: equipePessoasWhereInput | equipePessoasWhereInput[]
    equipeId?: IntFilter<"equipePessoas"> | number
    pessoaId?: IntFilter<"equipePessoas"> | number
    equipe?: XOR<EquipeScalarRelationFilter, equipeWhereInput>
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
  }

  export type equipePessoasOrderByWithRelationInput = {
    equipeId?: SortOrder
    pessoaId?: SortOrder
    equipe?: equipeOrderByWithRelationInput
    pessoa?: pessoaOrderByWithRelationInput
  }

  export type equipePessoasWhereUniqueInput = Prisma.AtLeast<{
    equipeId_pessoaId?: equipePessoasEquipeIdPessoaIdCompoundUniqueInput
    AND?: equipePessoasWhereInput | equipePessoasWhereInput[]
    OR?: equipePessoasWhereInput[]
    NOT?: equipePessoasWhereInput | equipePessoasWhereInput[]
    equipeId?: IntFilter<"equipePessoas"> | number
    pessoaId?: IntFilter<"equipePessoas"> | number
    equipe?: XOR<EquipeScalarRelationFilter, equipeWhereInput>
    pessoa?: XOR<PessoaScalarRelationFilter, pessoaWhereInput>
  }, "equipeId_pessoaId">

  export type equipePessoasOrderByWithAggregationInput = {
    equipeId?: SortOrder
    pessoaId?: SortOrder
    _count?: equipePessoasCountOrderByAggregateInput
    _avg?: equipePessoasAvgOrderByAggregateInput
    _max?: equipePessoasMaxOrderByAggregateInput
    _min?: equipePessoasMinOrderByAggregateInput
    _sum?: equipePessoasSumOrderByAggregateInput
  }

  export type equipePessoasScalarWhereWithAggregatesInput = {
    AND?: equipePessoasScalarWhereWithAggregatesInput | equipePessoasScalarWhereWithAggregatesInput[]
    OR?: equipePessoasScalarWhereWithAggregatesInput[]
    NOT?: equipePessoasScalarWhereWithAggregatesInput | equipePessoasScalarWhereWithAggregatesInput[]
    equipeId?: IntWithAggregatesFilter<"equipePessoas"> | number
    pessoaId?: IntWithAggregatesFilter<"equipePessoas"> | number
  }

  export type localidadeWhereInput = {
    AND?: localidadeWhereInput | localidadeWhereInput[]
    OR?: localidadeWhereInput[]
    NOT?: localidadeWhereInput | localidadeWhereInput[]
    id?: IntFilter<"localidade"> | number
    descricao?: StringFilter<"localidade"> | string
    dioceseId?: IntFilter<"localidade"> | number
    tipoLocalidadeId?: IntFilter<"localidade"> | number
    observacao?: StringNullableFilter<"localidade"> | string | null
    enderecoId?: IntFilter<"localidade"> | number
    diocese?: XOR<DioceseScalarRelationFilter, dioceseWhereInput>
    tipoLocalidade?: XOR<TipoLocalidadeScalarRelationFilter, tipoLocalidadeWhereInput>
    endereco?: XOR<EnderecoScalarRelationFilter, enderecoWhereInput>
    localidadeRegiao?: LocalidadeRegiaoListRelationFilter
  }

  export type localidadeOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    dioceseId?: SortOrder
    tipoLocalidadeId?: SortOrder
    observacao?: SortOrderInput | SortOrder
    enderecoId?: SortOrder
    diocese?: dioceseOrderByWithRelationInput
    tipoLocalidade?: tipoLocalidadeOrderByWithRelationInput
    endereco?: enderecoOrderByWithRelationInput
    localidadeRegiao?: localidadeRegiaoOrderByRelationAggregateInput
  }

  export type localidadeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: localidadeWhereInput | localidadeWhereInput[]
    OR?: localidadeWhereInput[]
    NOT?: localidadeWhereInput | localidadeWhereInput[]
    descricao?: StringFilter<"localidade"> | string
    dioceseId?: IntFilter<"localidade"> | number
    tipoLocalidadeId?: IntFilter<"localidade"> | number
    observacao?: StringNullableFilter<"localidade"> | string | null
    enderecoId?: IntFilter<"localidade"> | number
    diocese?: XOR<DioceseScalarRelationFilter, dioceseWhereInput>
    tipoLocalidade?: XOR<TipoLocalidadeScalarRelationFilter, tipoLocalidadeWhereInput>
    endereco?: XOR<EnderecoScalarRelationFilter, enderecoWhereInput>
    localidadeRegiao?: LocalidadeRegiaoListRelationFilter
  }, "id">

  export type localidadeOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    dioceseId?: SortOrder
    tipoLocalidadeId?: SortOrder
    observacao?: SortOrderInput | SortOrder
    enderecoId?: SortOrder
    _count?: localidadeCountOrderByAggregateInput
    _avg?: localidadeAvgOrderByAggregateInput
    _max?: localidadeMaxOrderByAggregateInput
    _min?: localidadeMinOrderByAggregateInput
    _sum?: localidadeSumOrderByAggregateInput
  }

  export type localidadeScalarWhereWithAggregatesInput = {
    AND?: localidadeScalarWhereWithAggregatesInput | localidadeScalarWhereWithAggregatesInput[]
    OR?: localidadeScalarWhereWithAggregatesInput[]
    NOT?: localidadeScalarWhereWithAggregatesInput | localidadeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"localidade"> | number
    descricao?: StringWithAggregatesFilter<"localidade"> | string
    dioceseId?: IntWithAggregatesFilter<"localidade"> | number
    tipoLocalidadeId?: IntWithAggregatesFilter<"localidade"> | number
    observacao?: StringNullableWithAggregatesFilter<"localidade"> | string | null
    enderecoId?: IntWithAggregatesFilter<"localidade"> | number
  }

  export type localidadeRegiaoWhereInput = {
    AND?: localidadeRegiaoWhereInput | localidadeRegiaoWhereInput[]
    OR?: localidadeRegiaoWhereInput[]
    NOT?: localidadeRegiaoWhereInput | localidadeRegiaoWhereInput[]
    localidadeId?: IntFilter<"localidadeRegiao"> | number
    regiaoId?: IntFilter<"localidadeRegiao"> | number
    localidade?: XOR<LocalidadeScalarRelationFilter, localidadeWhereInput>
    regiao?: XOR<RegiaoScalarRelationFilter, regiaoWhereInput>
  }

  export type localidadeRegiaoOrderByWithRelationInput = {
    localidadeId?: SortOrder
    regiaoId?: SortOrder
    localidade?: localidadeOrderByWithRelationInput
    regiao?: regiaoOrderByWithRelationInput
  }

  export type localidadeRegiaoWhereUniqueInput = Prisma.AtLeast<{
    localidadeId_regiaoId?: localidadeRegiaoLocalidadeIdRegiaoIdCompoundUniqueInput
    AND?: localidadeRegiaoWhereInput | localidadeRegiaoWhereInput[]
    OR?: localidadeRegiaoWhereInput[]
    NOT?: localidadeRegiaoWhereInput | localidadeRegiaoWhereInput[]
    localidadeId?: IntFilter<"localidadeRegiao"> | number
    regiaoId?: IntFilter<"localidadeRegiao"> | number
    localidade?: XOR<LocalidadeScalarRelationFilter, localidadeWhereInput>
    regiao?: XOR<RegiaoScalarRelationFilter, regiaoWhereInput>
  }, "localidadeId_regiaoId">

  export type localidadeRegiaoOrderByWithAggregationInput = {
    localidadeId?: SortOrder
    regiaoId?: SortOrder
    _count?: localidadeRegiaoCountOrderByAggregateInput
    _avg?: localidadeRegiaoAvgOrderByAggregateInput
    _max?: localidadeRegiaoMaxOrderByAggregateInput
    _min?: localidadeRegiaoMinOrderByAggregateInput
    _sum?: localidadeRegiaoSumOrderByAggregateInput
  }

  export type localidadeRegiaoScalarWhereWithAggregatesInput = {
    AND?: localidadeRegiaoScalarWhereWithAggregatesInput | localidadeRegiaoScalarWhereWithAggregatesInput[]
    OR?: localidadeRegiaoScalarWhereWithAggregatesInput[]
    NOT?: localidadeRegiaoScalarWhereWithAggregatesInput | localidadeRegiaoScalarWhereWithAggregatesInput[]
    localidadeId?: IntWithAggregatesFilter<"localidadeRegiao"> | number
    regiaoId?: IntWithAggregatesFilter<"localidadeRegiao"> | number
  }

  export type tipoLocalidadeWhereInput = {
    AND?: tipoLocalidadeWhereInput | tipoLocalidadeWhereInput[]
    OR?: tipoLocalidadeWhereInput[]
    NOT?: tipoLocalidadeWhereInput | tipoLocalidadeWhereInput[]
    id?: IntFilter<"tipoLocalidade"> | number
    descricao?: StringFilter<"tipoLocalidade"> | string
    localidade?: LocalidadeListRelationFilter
  }

  export type tipoLocalidadeOrderByWithRelationInput = {
    id?: SortOrder
    descricao?: SortOrder
    localidade?: localidadeOrderByRelationAggregateInput
  }

  export type tipoLocalidadeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tipoLocalidadeWhereInput | tipoLocalidadeWhereInput[]
    OR?: tipoLocalidadeWhereInput[]
    NOT?: tipoLocalidadeWhereInput | tipoLocalidadeWhereInput[]
    descricao?: StringFilter<"tipoLocalidade"> | string
    localidade?: LocalidadeListRelationFilter
  }, "id">

  export type tipoLocalidadeOrderByWithAggregationInput = {
    id?: SortOrder
    descricao?: SortOrder
    _count?: tipoLocalidadeCountOrderByAggregateInput
    _avg?: tipoLocalidadeAvgOrderByAggregateInput
    _max?: tipoLocalidadeMaxOrderByAggregateInput
    _min?: tipoLocalidadeMinOrderByAggregateInput
    _sum?: tipoLocalidadeSumOrderByAggregateInput
  }

  export type tipoLocalidadeScalarWhereWithAggregatesInput = {
    AND?: tipoLocalidadeScalarWhereWithAggregatesInput | tipoLocalidadeScalarWhereWithAggregatesInput[]
    OR?: tipoLocalidadeScalarWhereWithAggregatesInput[]
    NOT?: tipoLocalidadeScalarWhereWithAggregatesInput | tipoLocalidadeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tipoLocalidade"> | number
    descricao?: StringWithAggregatesFilter<"tipoLocalidade"> | string
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: StringFilter<"user"> | string
    name?: StringFilter<"user"> | string
    email?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    role?: EnumrolesFilter<"user"> | $Enums.roles
    whatsapp?: StringNullableFilter<"user"> | string | null
    verifiedWhatsapp?: BoolFilter<"user"> | boolean
    active?: BoolFilter<"user"> | boolean
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrderInput | SortOrder
    verifiedWhatsapp?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    name?: StringFilter<"user"> | string
    password?: StringFilter<"user"> | string
    role?: EnumrolesFilter<"user"> | $Enums.roles
    whatsapp?: StringNullableFilter<"user"> | string | null
    verifiedWhatsapp?: BoolFilter<"user"> | boolean
    active?: BoolFilter<"user"> | boolean
    createdAt?: DateTimeFilter<"user"> | Date | string
    updatedAt?: DateTimeFilter<"user"> | Date | string
  }, "id" | "email">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrderInput | SortOrder
    verifiedWhatsapp?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user"> | string
    name?: StringWithAggregatesFilter<"user"> | string
    email?: StringWithAggregatesFilter<"user"> | string
    password?: StringWithAggregatesFilter<"user"> | string
    role?: EnumrolesWithAggregatesFilter<"user"> | $Enums.roles
    whatsapp?: StringNullableWithAggregatesFilter<"user"> | string | null
    verifiedWhatsapp?: BoolWithAggregatesFilter<"user"> | boolean
    active?: BoolWithAggregatesFilter<"user"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"user"> | Date | string
  }

  export type paisCreateInput = {
    isoAlpha2: string
    nome: string
    regiao: string
    subRegiao: string
    regiaoIntermediaria?: string | null
    lingua: string
    capital: string
    estado?: estadoCreateNestedManyWithoutPaisInput
  }

  export type paisUncheckedCreateInput = {
    id?: number
    isoAlpha2: string
    nome: string
    regiao: string
    subRegiao: string
    regiaoIntermediaria?: string | null
    lingua: string
    capital: string
    estado?: estadoUncheckedCreateNestedManyWithoutPaisInput
  }

  export type paisUpdateInput = {
    isoAlpha2?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    regiao?: StringFieldUpdateOperationsInput | string
    subRegiao?: StringFieldUpdateOperationsInput | string
    regiaoIntermediaria?: NullableStringFieldUpdateOperationsInput | string | null
    lingua?: StringFieldUpdateOperationsInput | string
    capital?: StringFieldUpdateOperationsInput | string
    estado?: estadoUpdateManyWithoutPaisNestedInput
  }

  export type paisUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    isoAlpha2?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    regiao?: StringFieldUpdateOperationsInput | string
    subRegiao?: StringFieldUpdateOperationsInput | string
    regiaoIntermediaria?: NullableStringFieldUpdateOperationsInput | string | null
    lingua?: StringFieldUpdateOperationsInput | string
    capital?: StringFieldUpdateOperationsInput | string
    estado?: estadoUncheckedUpdateManyWithoutPaisNestedInput
  }

  export type paisCreateManyInput = {
    id?: number
    isoAlpha2: string
    nome: string
    regiao: string
    subRegiao: string
    regiaoIntermediaria?: string | null
    lingua: string
    capital: string
  }

  export type paisUpdateManyMutationInput = {
    isoAlpha2?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    regiao?: StringFieldUpdateOperationsInput | string
    subRegiao?: StringFieldUpdateOperationsInput | string
    regiaoIntermediaria?: NullableStringFieldUpdateOperationsInput | string | null
    lingua?: StringFieldUpdateOperationsInput | string
    capital?: StringFieldUpdateOperationsInput | string
  }

  export type paisUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    isoAlpha2?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    regiao?: StringFieldUpdateOperationsInput | string
    subRegiao?: StringFieldUpdateOperationsInput | string
    regiaoIntermediaria?: NullableStringFieldUpdateOperationsInput | string | null
    lingua?: StringFieldUpdateOperationsInput | string
    capital?: StringFieldUpdateOperationsInput | string
  }

  export type estadoCreateInput = {
    nome: string
    sigla: string
    ativo?: boolean
    pais: paisCreateNestedOneWithoutEstadoInput
    cidade?: cidadeCreateNestedManyWithoutEstadoInput
  }

  export type estadoUncheckedCreateInput = {
    id?: number
    nome: string
    sigla: string
    ativo?: boolean
    paisId: number
    cidade?: cidadeUncheckedCreateNestedManyWithoutEstadoInput
  }

  export type estadoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    pais?: paisUpdateOneRequiredWithoutEstadoNestedInput
    cidade?: cidadeUpdateManyWithoutEstadoNestedInput
  }

  export type estadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    paisId?: IntFieldUpdateOperationsInput | number
    cidade?: cidadeUncheckedUpdateManyWithoutEstadoNestedInput
  }

  export type estadoCreateManyInput = {
    id?: number
    nome: string
    sigla: string
    ativo?: boolean
    paisId: number
  }

  export type estadoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type estadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    paisId?: IntFieldUpdateOperationsInput | number
  }

  export type cidadeCreateInput = {
    nome: string
    ativo?: boolean
    estado: estadoCreateNestedOneWithoutCidadeInput
  }

  export type cidadeUncheckedCreateInput = {
    id?: number
    nome: string
    estadoId: number
    ativo?: boolean
  }

  export type cidadeUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estado?: estadoUpdateOneRequiredWithoutCidadeNestedInput
  }

  export type cidadeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    estadoId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cidadeCreateManyInput = {
    id?: number
    nome: string
    estadoId: number
    ativo?: boolean
  }

  export type cidadeUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cidadeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    estadoId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type enderecoCreateInput = {
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    paroquias?: paroquiaCreateNestedManyWithoutEnderecoInput
    pessoas?: pessoaEnderecoCreateNestedManyWithoutEnderecoInput
    localidade?: localidadeCreateNestedManyWithoutEnderecoInput
    diocese?: dioceseCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoUncheckedCreateInput = {
    id?: number
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    paroquias?: paroquiaUncheckedCreateNestedManyWithoutEnderecoInput
    pessoas?: pessoaEnderecoUncheckedCreateNestedManyWithoutEnderecoInput
    localidade?: localidadeUncheckedCreateNestedManyWithoutEnderecoInput
    diocese?: dioceseUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoUpdateInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    paroquias?: paroquiaUpdateManyWithoutEnderecoNestedInput
    pessoas?: pessoaEnderecoUpdateManyWithoutEnderecoNestedInput
    localidade?: localidadeUpdateManyWithoutEnderecoNestedInput
    diocese?: dioceseUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    paroquias?: paroquiaUncheckedUpdateManyWithoutEnderecoNestedInput
    pessoas?: pessoaEnderecoUncheckedUpdateManyWithoutEnderecoNestedInput
    localidade?: localidadeUncheckedUpdateManyWithoutEnderecoNestedInput
    diocese?: dioceseUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoCreateManyInput = {
    id?: number
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
  }

  export type enderecoUpdateManyMutationInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type enderecoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tipoCarismaCreateInput = {
    descricao: string
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutTipoCarismaInput
  }

  export type tipoCarismaUncheckedCreateInput = {
    id?: number
    descricao: string
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutTipoCarismaInput
  }

  export type tipoCarismaUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutTipoCarismaNestedInput
  }

  export type tipoCarismaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutTipoCarismaNestedInput
  }

  export type tipoCarismaCreateManyInput = {
    id?: number
    descricao: string
  }

  export type tipoCarismaUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoCarismaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type estadoCivilCreateInput = {
    descricao: string
    pessoas?: pessoaCreateNestedManyWithoutEstadoCivilInput
  }

  export type estadoCivilUncheckedCreateInput = {
    id?: number
    descricao: string
    pessoas?: pessoaUncheckedCreateNestedManyWithoutEstadoCivilInput
  }

  export type estadoCivilUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    pessoas?: pessoaUpdateManyWithoutEstadoCivilNestedInput
  }

  export type estadoCivilUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pessoas?: pessoaUncheckedUpdateManyWithoutEstadoCivilNestedInput
  }

  export type estadoCivilCreateManyInput = {
    id?: number
    descricao: string
  }

  export type estadoCivilUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type estadoCivilUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type escolaridadeCreateInput = {
    descricao: string
    pessoas?: pessoaCreateNestedManyWithoutEscolaridadeInput
  }

  export type escolaridadeUncheckedCreateInput = {
    id?: number
    descricao: string
    pessoas?: pessoaUncheckedCreateNestedManyWithoutEscolaridadeInput
  }

  export type escolaridadeUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    pessoas?: pessoaUpdateManyWithoutEscolaridadeNestedInput
  }

  export type escolaridadeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pessoas?: pessoaUncheckedUpdateManyWithoutEscolaridadeNestedInput
  }

  export type escolaridadeCreateManyInput = {
    id?: number
    descricao: string
  }

  export type escolaridadeUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type escolaridadeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaCreateInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaCreateManyInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
  }

  export type pessoaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type pessoaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type tipoPessoaCreateInput = {
    descricao: string
    pessoa?: pessoaCreateNestedManyWithoutTipoPessoaInput
  }

  export type tipoPessoaUncheckedCreateInput = {
    id?: number
    descricao: string
    pessoa?: pessoaUncheckedCreateNestedManyWithoutTipoPessoaInput
  }

  export type tipoPessoaUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUpdateManyWithoutTipoPessoaNestedInput
  }

  export type tipoPessoaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pessoa?: pessoaUncheckedUpdateManyWithoutTipoPessoaNestedInput
  }

  export type tipoPessoaCreateManyInput = {
    id?: number
    descricao: string
  }

  export type tipoPessoaUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoPessoaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaEnderecoCreateInput = {
    pessoa: pessoaCreateNestedOneWithoutEnderecosInput
    endereco: enderecoCreateNestedOneWithoutPessoasInput
  }

  export type pessoaEnderecoUncheckedCreateInput = {
    pessoaId: number
    enderecoId: number
  }

  export type pessoaEnderecoUpdateInput = {
    pessoa?: pessoaUpdateOneRequiredWithoutEnderecosNestedInput
    endereco?: enderecoUpdateOneRequiredWithoutPessoasNestedInput
  }

  export type pessoaEnderecoUncheckedUpdateInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
    enderecoId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaEnderecoCreateManyInput = {
    pessoaId: number
    enderecoId: number
  }

  export type pessoaEnderecoUpdateManyMutationInput = {

  }

  export type pessoaEnderecoUncheckedUpdateManyInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
    enderecoId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCasalCreateInput = {
    marido: pessoaCreateNestedOneWithoutCasamentosComoMaridoInput
    mulher: pessoaCreateNestedOneWithoutCasamentosComoMulherInput
  }

  export type pessoaCasalUncheckedCreateInput = {
    id?: number
    pessoaMaridoId: number
    pessoaMulherId: number
  }

  export type pessoaCasalUpdateInput = {
    marido?: pessoaUpdateOneRequiredWithoutCasamentosComoMaridoNestedInput
    mulher?: pessoaUpdateOneRequiredWithoutCasamentosComoMulherNestedInput
  }

  export type pessoaCasalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoaMaridoId?: IntFieldUpdateOperationsInput | number
    pessoaMulherId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCasalCreateManyInput = {
    id?: number
    pessoaMaridoId: number
    pessoaMulherId: number
  }

  export type pessoaCasalUpdateManyMutationInput = {

  }

  export type pessoaCasalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoaMaridoId?: IntFieldUpdateOperationsInput | number
    pessoaMulherId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCarismaCreateInput = {
    pessoa: pessoaCreateNestedOneWithoutPessoaCarismaInput
    tipoCarisma: tipoCarismaCreateNestedOneWithoutPessoaCarismaInput
  }

  export type pessoaCarismaUncheckedCreateInput = {
    pessoaId: number
    tipoCarismaId: number
  }

  export type pessoaCarismaUpdateInput = {
    pessoa?: pessoaUpdateOneRequiredWithoutPessoaCarismaNestedInput
    tipoCarisma?: tipoCarismaUpdateOneRequiredWithoutPessoaCarismaNestedInput
  }

  export type pessoaCarismaUncheckedUpdateInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
    tipoCarismaId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCarismaCreateManyInput = {
    pessoaId: number
    tipoCarismaId: number
  }

  export type pessoaCarismaUpdateManyMutationInput = {

  }

  export type pessoaCarismaUncheckedUpdateManyInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
    tipoCarismaId?: IntFieldUpdateOperationsInput | number
  }

  export type passaportePessoaCreateInput = {
    numero: string
    dataExpiracao: Date | string
    renovado?: boolean
    dataRenovacao?: Date | string | null
    pessoa: pessoaCreateNestedOneWithoutPassaportesInput
  }

  export type passaportePessoaUncheckedCreateInput = {
    id?: number
    pessoaId: number
    numero: string
    dataExpiracao: Date | string
    renovado?: boolean
    dataRenovacao?: Date | string | null
  }

  export type passaportePessoaUpdateInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataExpiracao?: DateTimeFieldUpdateOperationsInput | Date | string
    renovado?: BoolFieldUpdateOperationsInput | boolean
    dataRenovacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pessoa?: pessoaUpdateOneRequiredWithoutPassaportesNestedInput
  }

  export type passaportePessoaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoaId?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    dataExpiracao?: DateTimeFieldUpdateOperationsInput | Date | string
    renovado?: BoolFieldUpdateOperationsInput | boolean
    dataRenovacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type passaportePessoaCreateManyInput = {
    id?: number
    pessoaId: number
    numero: string
    dataExpiracao: Date | string
    renovado?: boolean
    dataRenovacao?: Date | string | null
  }

  export type passaportePessoaUpdateManyMutationInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataExpiracao?: DateTimeFieldUpdateOperationsInput | Date | string
    renovado?: BoolFieldUpdateOperationsInput | boolean
    dataRenovacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type passaportePessoaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoaId?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    dataExpiracao?: DateTimeFieldUpdateOperationsInput | Date | string
    renovado?: BoolFieldUpdateOperationsInput | boolean
    dataRenovacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pessoaContatoCreateInput = {
    telefoneResidencial?: string | null
    telefoneCelular?: string | null
    observacao?: string | null
    ativo?: boolean
    email?: string | null
    pessoa: pessoaCreateNestedOneWithoutContatosInput
  }

  export type pessoaContatoUncheckedCreateInput = {
    id?: number
    telefoneResidencial?: string | null
    telefoneCelular?: string | null
    observacao?: string | null
    ativo?: boolean
    email?: string | null
    pessoaId: number
  }

  export type pessoaContatoUpdateInput = {
    telefoneResidencial?: NullableStringFieldUpdateOperationsInput | string | null
    telefoneCelular?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pessoa?: pessoaUpdateOneRequiredWithoutContatosNestedInput
  }

  export type pessoaContatoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    telefoneResidencial?: NullableStringFieldUpdateOperationsInput | string | null
    telefoneCelular?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaContatoCreateManyInput = {
    id?: number
    telefoneResidencial?: string | null
    telefoneCelular?: string | null
    observacao?: string | null
    ativo?: boolean
    email?: string | null
    pessoaId: number
  }

  export type pessoaContatoUpdateManyMutationInput = {
    telefoneResidencial?: NullableStringFieldUpdateOperationsInput | string | null
    telefoneCelular?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pessoaContatoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    telefoneResidencial?: NullableStringFieldUpdateOperationsInput | string | null
    telefoneCelular?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type tipoDioceseCreateInput = {
    descricao: string
    dioceses?: dioceseCreateNestedManyWithoutTipoDioceseInput
  }

  export type tipoDioceseUncheckedCreateInput = {
    id?: number
    descricao: string
    dioceses?: dioceseUncheckedCreateNestedManyWithoutTipoDioceseInput
  }

  export type tipoDioceseUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    dioceses?: dioceseUpdateManyWithoutTipoDioceseNestedInput
  }

  export type tipoDioceseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dioceses?: dioceseUncheckedUpdateManyWithoutTipoDioceseNestedInput
  }

  export type tipoDioceseCreateManyInput = {
    id?: number
    descricao: string
  }

  export type tipoDioceseUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoDioceseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type dioceseCreateInput = {
    descricao: string
    tipoDiocese: tipoDioceseCreateNestedOneWithoutDiocesesInput
    endereco: enderecoCreateNestedOneWithoutDioceseInput
    paroquias?: paroquiaCreateNestedManyWithoutDioceseInput
    localidade?: localidadeCreateNestedManyWithoutDioceseInput
  }

  export type dioceseUncheckedCreateInput = {
    id?: number
    tipoDioceseId: number
    descricao: string
    enderecoId: number
    paroquias?: paroquiaUncheckedCreateNestedManyWithoutDioceseInput
    localidade?: localidadeUncheckedCreateNestedManyWithoutDioceseInput
  }

  export type dioceseUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    tipoDiocese?: tipoDioceseUpdateOneRequiredWithoutDiocesesNestedInput
    endereco?: enderecoUpdateOneRequiredWithoutDioceseNestedInput
    paroquias?: paroquiaUpdateManyWithoutDioceseNestedInput
    localidade?: localidadeUpdateManyWithoutDioceseNestedInput
  }

  export type dioceseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoDioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    enderecoId?: IntFieldUpdateOperationsInput | number
    paroquias?: paroquiaUncheckedUpdateManyWithoutDioceseNestedInput
    localidade?: localidadeUncheckedUpdateManyWithoutDioceseNestedInput
  }

  export type dioceseCreateManyInput = {
    id?: number
    tipoDioceseId: number
    descricao: string
    enderecoId: number
  }

  export type dioceseUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type dioceseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoDioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    enderecoId?: IntFieldUpdateOperationsInput | number
  }

  export type paroquiaCreateInput = {
    descricao: string
    endereco: enderecoCreateNestedOneWithoutParoquiasInput
    diocese: dioceseCreateNestedOneWithoutParoquiasInput
    pessoas?: paroquiaPessoasCreateNestedManyWithoutParoquiaInput
  }

  export type paroquiaUncheckedCreateInput = {
    id?: number
    enderecoId: number
    dioceseId: number
    descricao: string
    pessoas?: paroquiaPessoasUncheckedCreateNestedManyWithoutParoquiaInput
  }

  export type paroquiaUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    endereco?: enderecoUpdateOneRequiredWithoutParoquiasNestedInput
    diocese?: dioceseUpdateOneRequiredWithoutParoquiasNestedInput
    pessoas?: paroquiaPessoasUpdateManyWithoutParoquiaNestedInput
  }

  export type paroquiaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enderecoId?: IntFieldUpdateOperationsInput | number
    dioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pessoas?: paroquiaPessoasUncheckedUpdateManyWithoutParoquiaNestedInput
  }

  export type paroquiaCreateManyInput = {
    id?: number
    enderecoId: number
    dioceseId: number
    descricao: string
  }

  export type paroquiaUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type paroquiaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enderecoId?: IntFieldUpdateOperationsInput | number
    dioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type paroquiaPessoasCreateInput = {
    pessoa: pessoaCreateNestedOneWithoutParoquiasInput
    paroquia: paroquiaCreateNestedOneWithoutPessoasInput
  }

  export type paroquiaPessoasUncheckedCreateInput = {
    pessoaId: number
    paroquiaId: number
  }

  export type paroquiaPessoasUpdateInput = {
    pessoa?: pessoaUpdateOneRequiredWithoutParoquiasNestedInput
    paroquia?: paroquiaUpdateOneRequiredWithoutPessoasNestedInput
  }

  export type paroquiaPessoasUncheckedUpdateInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
    paroquiaId?: IntFieldUpdateOperationsInput | number
  }

  export type paroquiaPessoasCreateManyInput = {
    pessoaId: number
    paroquiaId: number
  }

  export type paroquiaPessoasUpdateManyMutationInput = {

  }

  export type paroquiaPessoasUncheckedUpdateManyInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
    paroquiaId?: IntFieldUpdateOperationsInput | number
  }

  export type etapaCreateInput = {
    descricao: string
  }

  export type etapaUncheckedCreateInput = {
    id?: number
    descricao: string
  }

  export type etapaUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type etapaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type etapaCreateManyInput = {
    id?: number
    descricao: string
  }

  export type etapaUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type etapaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type regiaoCreateInput = {
    descricao: string
    macroRegiao?: boolean
    equipes?: equipeRegiaoCreateNestedManyWithoutRegiaoInput
    localidadeRegiao?: localidadeRegiaoCreateNestedManyWithoutRegiaoInput
  }

  export type regiaoUncheckedCreateInput = {
    id?: number
    descricao: string
    macroRegiao?: boolean
    equipes?: equipeRegiaoUncheckedCreateNestedManyWithoutRegiaoInput
    localidadeRegiao?: localidadeRegiaoUncheckedCreateNestedManyWithoutRegiaoInput
  }

  export type regiaoUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    macroRegiao?: BoolFieldUpdateOperationsInput | boolean
    equipes?: equipeRegiaoUpdateManyWithoutRegiaoNestedInput
    localidadeRegiao?: localidadeRegiaoUpdateManyWithoutRegiaoNestedInput
  }

  export type regiaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    macroRegiao?: BoolFieldUpdateOperationsInput | boolean
    equipes?: equipeRegiaoUncheckedUpdateManyWithoutRegiaoNestedInput
    localidadeRegiao?: localidadeRegiaoUncheckedUpdateManyWithoutRegiaoNestedInput
  }

  export type regiaoCreateManyInput = {
    id?: number
    descricao: string
    macroRegiao?: boolean
  }

  export type regiaoUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    macroRegiao?: BoolFieldUpdateOperationsInput | boolean
  }

  export type regiaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    macroRegiao?: BoolFieldUpdateOperationsInput | boolean
  }

  export type tipoEquipeCreateInput = {
    descricao: string
    equipes?: equipeTipoEquipeCreateNestedManyWithoutTipoEquipeInput
  }

  export type tipoEquipeUncheckedCreateInput = {
    id?: number
    descricao: string
    equipes?: equipeTipoEquipeUncheckedCreateNestedManyWithoutTipoEquipeInput
  }

  export type tipoEquipeUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    equipes?: equipeTipoEquipeUpdateManyWithoutTipoEquipeNestedInput
  }

  export type tipoEquipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    equipes?: equipeTipoEquipeUncheckedUpdateManyWithoutTipoEquipeNestedInput
  }

  export type tipoEquipeCreateManyInput = {
    id?: number
    descricao: string
  }

  export type tipoEquipeUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoEquipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type equipeCreateInput = {
    descricao: string
    regioes?: equipeRegiaoCreateNestedManyWithoutEquipeInput
    equipePessoas?: equipePessoasCreateNestedManyWithoutEquipeInput
    tipos?: equipeTipoEquipeCreateNestedManyWithoutEquipeInput
  }

  export type equipeUncheckedCreateInput = {
    id?: number
    descricao: string
    regioes?: equipeRegiaoUncheckedCreateNestedManyWithoutEquipeInput
    equipePessoas?: equipePessoasUncheckedCreateNestedManyWithoutEquipeInput
    tipos?: equipeTipoEquipeUncheckedCreateNestedManyWithoutEquipeInput
  }

  export type equipeUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    regioes?: equipeRegiaoUpdateManyWithoutEquipeNestedInput
    equipePessoas?: equipePessoasUpdateManyWithoutEquipeNestedInput
    tipos?: equipeTipoEquipeUpdateManyWithoutEquipeNestedInput
  }

  export type equipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    regioes?: equipeRegiaoUncheckedUpdateManyWithoutEquipeNestedInput
    equipePessoas?: equipePessoasUncheckedUpdateManyWithoutEquipeNestedInput
    tipos?: equipeTipoEquipeUncheckedUpdateManyWithoutEquipeNestedInput
  }

  export type equipeCreateManyInput = {
    id?: number
    descricao: string
  }

  export type equipeUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type equipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type equipeTipoEquipeCreateInput = {
    equipe: equipeCreateNestedOneWithoutTiposInput
    tipoEquipe: tipoEquipeCreateNestedOneWithoutEquipesInput
  }

  export type equipeTipoEquipeUncheckedCreateInput = {
    equipeId: number
    tipoEquipeId: number
  }

  export type equipeTipoEquipeUpdateInput = {
    equipe?: equipeUpdateOneRequiredWithoutTiposNestedInput
    tipoEquipe?: tipoEquipeUpdateOneRequiredWithoutEquipesNestedInput
  }

  export type equipeTipoEquipeUncheckedUpdateInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
    tipoEquipeId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeTipoEquipeCreateManyInput = {
    equipeId: number
    tipoEquipeId: number
  }

  export type equipeTipoEquipeUpdateManyMutationInput = {

  }

  export type equipeTipoEquipeUncheckedUpdateManyInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
    tipoEquipeId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeRegiaoCreateInput = {
    equipe: equipeCreateNestedOneWithoutRegioesInput
    regiao: regiaoCreateNestedOneWithoutEquipesInput
  }

  export type equipeRegiaoUncheckedCreateInput = {
    equipeId: number
    regiaoId: number
  }

  export type equipeRegiaoUpdateInput = {
    equipe?: equipeUpdateOneRequiredWithoutRegioesNestedInput
    regiao?: regiaoUpdateOneRequiredWithoutEquipesNestedInput
  }

  export type equipeRegiaoUncheckedUpdateInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
    regiaoId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeRegiaoCreateManyInput = {
    equipeId: number
    regiaoId: number
  }

  export type equipeRegiaoUpdateManyMutationInput = {

  }

  export type equipeRegiaoUncheckedUpdateManyInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
    regiaoId?: IntFieldUpdateOperationsInput | number
  }

  export type equipePessoasCreateInput = {
    equipe: equipeCreateNestedOneWithoutEquipePessoasInput
    pessoa: pessoaCreateNestedOneWithoutEquipesInput
  }

  export type equipePessoasUncheckedCreateInput = {
    equipeId: number
    pessoaId: number
  }

  export type equipePessoasUpdateInput = {
    equipe?: equipeUpdateOneRequiredWithoutEquipePessoasNestedInput
    pessoa?: pessoaUpdateOneRequiredWithoutEquipesNestedInput
  }

  export type equipePessoasUncheckedUpdateInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type equipePessoasCreateManyInput = {
    equipeId: number
    pessoaId: number
  }

  export type equipePessoasUpdateManyMutationInput = {

  }

  export type equipePessoasUncheckedUpdateManyInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type localidadeCreateInput = {
    descricao: string
    observacao?: string | null
    diocese: dioceseCreateNestedOneWithoutLocalidadeInput
    tipoLocalidade: tipoLocalidadeCreateNestedOneWithoutLocalidadeInput
    endereco: enderecoCreateNestedOneWithoutLocalidadeInput
    localidadeRegiao?: localidadeRegiaoCreateNestedManyWithoutLocalidadeInput
  }

  export type localidadeUncheckedCreateInput = {
    id?: number
    descricao: string
    dioceseId: number
    tipoLocalidadeId: number
    observacao?: string | null
    enderecoId: number
    localidadeRegiao?: localidadeRegiaoUncheckedCreateNestedManyWithoutLocalidadeInput
  }

  export type localidadeUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    diocese?: dioceseUpdateOneRequiredWithoutLocalidadeNestedInput
    tipoLocalidade?: tipoLocalidadeUpdateOneRequiredWithoutLocalidadeNestedInput
    endereco?: enderecoUpdateOneRequiredWithoutLocalidadeNestedInput
    localidadeRegiao?: localidadeRegiaoUpdateManyWithoutLocalidadeNestedInput
  }

  export type localidadeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dioceseId?: IntFieldUpdateOperationsInput | number
    tipoLocalidadeId?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoId?: IntFieldUpdateOperationsInput | number
    localidadeRegiao?: localidadeRegiaoUncheckedUpdateManyWithoutLocalidadeNestedInput
  }

  export type localidadeCreateManyInput = {
    id?: number
    descricao: string
    dioceseId: number
    tipoLocalidadeId: number
    observacao?: string | null
    enderecoId: number
  }

  export type localidadeUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type localidadeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dioceseId?: IntFieldUpdateOperationsInput | number
    tipoLocalidadeId?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoId?: IntFieldUpdateOperationsInput | number
  }

  export type localidadeRegiaoCreateInput = {
    localidade: localidadeCreateNestedOneWithoutLocalidadeRegiaoInput
    regiao: regiaoCreateNestedOneWithoutLocalidadeRegiaoInput
  }

  export type localidadeRegiaoUncheckedCreateInput = {
    localidadeId: number
    regiaoId: number
  }

  export type localidadeRegiaoUpdateInput = {
    localidade?: localidadeUpdateOneRequiredWithoutLocalidadeRegiaoNestedInput
    regiao?: regiaoUpdateOneRequiredWithoutLocalidadeRegiaoNestedInput
  }

  export type localidadeRegiaoUncheckedUpdateInput = {
    localidadeId?: IntFieldUpdateOperationsInput | number
    regiaoId?: IntFieldUpdateOperationsInput | number
  }

  export type localidadeRegiaoCreateManyInput = {
    localidadeId: number
    regiaoId: number
  }

  export type localidadeRegiaoUpdateManyMutationInput = {

  }

  export type localidadeRegiaoUncheckedUpdateManyInput = {
    localidadeId?: IntFieldUpdateOperationsInput | number
    regiaoId?: IntFieldUpdateOperationsInput | number
  }

  export type tipoLocalidadeCreateInput = {
    descricao: string
    localidade?: localidadeCreateNestedManyWithoutTipoLocalidadeInput
  }

  export type tipoLocalidadeUncheckedCreateInput = {
    id?: number
    descricao: string
    localidade?: localidadeUncheckedCreateNestedManyWithoutTipoLocalidadeInput
  }

  export type tipoLocalidadeUpdateInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    localidade?: localidadeUpdateManyWithoutTipoLocalidadeNestedInput
  }

  export type tipoLocalidadeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    localidade?: localidadeUncheckedUpdateManyWithoutTipoLocalidadeNestedInput
  }

  export type tipoLocalidadeCreateManyInput = {
    id?: number
    descricao: string
  }

  export type tipoLocalidadeUpdateManyMutationInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoLocalidadeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.roles
    whatsapp?: string | null
    verifiedWhatsapp?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.roles
    whatsapp?: string | null
    verifiedWhatsapp?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedWhatsapp?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedWhatsapp?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.roles
    whatsapp?: string | null
    verifiedWhatsapp?: boolean
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedWhatsapp?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumrolesFieldUpdateOperationsInput | $Enums.roles
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedWhatsapp?: BoolFieldUpdateOperationsInput | boolean
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EstadoListRelationFilter = {
    every?: estadoWhereInput
    some?: estadoWhereInput
    none?: estadoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type estadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paisCountOrderByAggregateInput = {
    id?: SortOrder
    isoAlpha2?: SortOrder
    nome?: SortOrder
    regiao?: SortOrder
    subRegiao?: SortOrder
    regiaoIntermediaria?: SortOrder
    lingua?: SortOrder
    capital?: SortOrder
  }

  export type paisAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type paisMaxOrderByAggregateInput = {
    id?: SortOrder
    isoAlpha2?: SortOrder
    nome?: SortOrder
    regiao?: SortOrder
    subRegiao?: SortOrder
    regiaoIntermediaria?: SortOrder
    lingua?: SortOrder
    capital?: SortOrder
  }

  export type paisMinOrderByAggregateInput = {
    id?: SortOrder
    isoAlpha2?: SortOrder
    nome?: SortOrder
    regiao?: SortOrder
    subRegiao?: SortOrder
    regiaoIntermediaria?: SortOrder
    lingua?: SortOrder
    capital?: SortOrder
  }

  export type paisSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PaisScalarRelationFilter = {
    is?: paisWhereInput
    isNot?: paisWhereInput
  }

  export type CidadeListRelationFilter = {
    every?: cidadeWhereInput
    some?: cidadeWhereInput
    none?: cidadeWhereInput
  }

  export type cidadeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estadoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    paisId?: SortOrder
  }

  export type estadoAvgOrderByAggregateInput = {
    id?: SortOrder
    paisId?: SortOrder
  }

  export type estadoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    paisId?: SortOrder
  }

  export type estadoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    sigla?: SortOrder
    ativo?: SortOrder
    paisId?: SortOrder
  }

  export type estadoSumOrderByAggregateInput = {
    id?: SortOrder
    paisId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EstadoScalarRelationFilter = {
    is?: estadoWhereInput
    isNot?: estadoWhereInput
  }

  export type cidadeCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    estadoId?: SortOrder
    ativo?: SortOrder
  }

  export type cidadeAvgOrderByAggregateInput = {
    id?: SortOrder
    estadoId?: SortOrder
  }

  export type cidadeMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    estadoId?: SortOrder
    ativo?: SortOrder
  }

  export type cidadeMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    estadoId?: SortOrder
    ativo?: SortOrder
  }

  export type cidadeSumOrderByAggregateInput = {
    id?: SortOrder
    estadoId?: SortOrder
  }

  export type ParoquiaListRelationFilter = {
    every?: paroquiaWhereInput
    some?: paroquiaWhereInput
    none?: paroquiaWhereInput
  }

  export type PessoaEnderecoListRelationFilter = {
    every?: pessoaEnderecoWhereInput
    some?: pessoaEnderecoWhereInput
    none?: pessoaEnderecoWhereInput
  }

  export type LocalidadeListRelationFilter = {
    every?: localidadeWhereInput
    some?: localidadeWhereInput
    none?: localidadeWhereInput
  }

  export type DioceseListRelationFilter = {
    every?: dioceseWhereInput
    some?: dioceseWhereInput
    none?: dioceseWhereInput
  }

  export type paroquiaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pessoaEnderecoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type localidadeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type dioceseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type enderecoCountOrderByAggregateInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    numero?: SortOrder
    UF?: SortOrder
    pais?: SortOrder
    observacao?: SortOrder
  }

  export type enderecoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type enderecoMaxOrderByAggregateInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    numero?: SortOrder
    UF?: SortOrder
    pais?: SortOrder
    observacao?: SortOrder
  }

  export type enderecoMinOrderByAggregateInput = {
    id?: SortOrder
    cep?: SortOrder
    logradouro?: SortOrder
    cidade?: SortOrder
    bairro?: SortOrder
    numero?: SortOrder
    UF?: SortOrder
    pais?: SortOrder
    observacao?: SortOrder
  }

  export type enderecoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PessoaCarismaListRelationFilter = {
    every?: pessoaCarismaWhereInput
    some?: pessoaCarismaWhereInput
    none?: pessoaCarismaWhereInput
  }

  export type pessoaCarismaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tipoCarismaCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoCarismaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipoCarismaMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoCarismaMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoCarismaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PessoaListRelationFilter = {
    every?: pessoaWhereInput
    some?: pessoaWhereInput
    none?: pessoaWhereInput
  }

  export type pessoaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type estadoCivilCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type estadoCivilAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type estadoCivilMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type estadoCivilMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type estadoCivilSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type escolaridadeCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type escolaridadeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type escolaridadeMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type escolaridadeMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type escolaridadeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumSexoFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoFilter<$PrismaModel> | $Enums.Sexo
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EstadoCivilScalarRelationFilter = {
    is?: estadoCivilWhereInput
    isNot?: estadoCivilWhereInput
  }

  export type EscolaridadeNullableScalarRelationFilter = {
    is?: escolaridadeWhereInput | null
    isNot?: escolaridadeWhereInput | null
  }

  export type TipoPessoaScalarRelationFilter = {
    is?: tipoPessoaWhereInput
    isNot?: tipoPessoaWhereInput
  }

  export type PassaportePessoaListRelationFilter = {
    every?: passaportePessoaWhereInput
    some?: passaportePessoaWhereInput
    none?: passaportePessoaWhereInput
  }

  export type PessoaContatoListRelationFilter = {
    every?: pessoaContatoWhereInput
    some?: pessoaContatoWhereInput
    none?: pessoaContatoWhereInput
  }

  export type ParoquiaPessoasListRelationFilter = {
    every?: paroquiaPessoasWhereInput
    some?: paroquiaPessoasWhereInput
    none?: paroquiaPessoasWhereInput
  }

  export type PessoaCasalListRelationFilter = {
    every?: pessoaCasalWhereInput
    some?: pessoaCasalWhereInput
    none?: pessoaCasalWhereInput
  }

  export type EquipePessoasListRelationFilter = {
    every?: equipePessoasWhereInput
    some?: equipePessoasWhereInput
    none?: equipePessoasWhereInput
  }

  export type passaportePessoaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pessoaContatoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paroquiaPessoasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pessoaCasalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type equipePessoasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type pessoaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    conhecidoPor?: SortOrder
    sexo?: SortOrder
    cpf?: SortOrder
    nacionalidade?: SortOrder
    dataNascimento?: SortOrder
    estadoCivilId?: SortOrder
    foto?: SortOrder
    escolaridadeId?: SortOrder
    ativo?: SortOrder
    tipoPessoaId?: SortOrder
  }

  export type pessoaAvgOrderByAggregateInput = {
    id?: SortOrder
    estadoCivilId?: SortOrder
    escolaridadeId?: SortOrder
    tipoPessoaId?: SortOrder
  }

  export type pessoaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    conhecidoPor?: SortOrder
    sexo?: SortOrder
    cpf?: SortOrder
    nacionalidade?: SortOrder
    dataNascimento?: SortOrder
    estadoCivilId?: SortOrder
    foto?: SortOrder
    escolaridadeId?: SortOrder
    ativo?: SortOrder
    tipoPessoaId?: SortOrder
  }

  export type pessoaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    conhecidoPor?: SortOrder
    sexo?: SortOrder
    cpf?: SortOrder
    nacionalidade?: SortOrder
    dataNascimento?: SortOrder
    estadoCivilId?: SortOrder
    foto?: SortOrder
    escolaridadeId?: SortOrder
    ativo?: SortOrder
    tipoPessoaId?: SortOrder
  }

  export type pessoaSumOrderByAggregateInput = {
    id?: SortOrder
    estadoCivilId?: SortOrder
    escolaridadeId?: SortOrder
    tipoPessoaId?: SortOrder
  }

  export type EnumSexoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoWithAggregatesFilter<$PrismaModel> | $Enums.Sexo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexoFilter<$PrismaModel>
    _max?: NestedEnumSexoFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type tipoPessoaCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoPessoaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipoPessoaMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoPessoaMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoPessoaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PessoaScalarRelationFilter = {
    is?: pessoaWhereInput
    isNot?: pessoaWhereInput
  }

  export type EnderecoScalarRelationFilter = {
    is?: enderecoWhereInput
    isNot?: enderecoWhereInput
  }

  export type pessoaEnderecoPessoaIdEnderecoIdCompoundUniqueInput = {
    pessoaId: number
    enderecoId: number
  }

  export type pessoaEnderecoCountOrderByAggregateInput = {
    pessoaId?: SortOrder
    enderecoId?: SortOrder
  }

  export type pessoaEnderecoAvgOrderByAggregateInput = {
    pessoaId?: SortOrder
    enderecoId?: SortOrder
  }

  export type pessoaEnderecoMaxOrderByAggregateInput = {
    pessoaId?: SortOrder
    enderecoId?: SortOrder
  }

  export type pessoaEnderecoMinOrderByAggregateInput = {
    pessoaId?: SortOrder
    enderecoId?: SortOrder
  }

  export type pessoaEnderecoSumOrderByAggregateInput = {
    pessoaId?: SortOrder
    enderecoId?: SortOrder
  }

  export type pessoaCasalPessoaMaridoIdPessoaMulherIdCompoundUniqueInput = {
    pessoaMaridoId: number
    pessoaMulherId: number
  }

  export type pessoaCasalCountOrderByAggregateInput = {
    id?: SortOrder
    pessoaMaridoId?: SortOrder
    pessoaMulherId?: SortOrder
  }

  export type pessoaCasalAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoaMaridoId?: SortOrder
    pessoaMulherId?: SortOrder
  }

  export type pessoaCasalMaxOrderByAggregateInput = {
    id?: SortOrder
    pessoaMaridoId?: SortOrder
    pessoaMulherId?: SortOrder
  }

  export type pessoaCasalMinOrderByAggregateInput = {
    id?: SortOrder
    pessoaMaridoId?: SortOrder
    pessoaMulherId?: SortOrder
  }

  export type pessoaCasalSumOrderByAggregateInput = {
    id?: SortOrder
    pessoaMaridoId?: SortOrder
    pessoaMulherId?: SortOrder
  }

  export type TipoCarismaScalarRelationFilter = {
    is?: tipoCarismaWhereInput
    isNot?: tipoCarismaWhereInput
  }

  export type pessoaCarismaPessoaIdTipoCarismaIdCompoundUniqueInput = {
    pessoaId: number
    tipoCarismaId: number
  }

  export type pessoaCarismaCountOrderByAggregateInput = {
    pessoaId?: SortOrder
    tipoCarismaId?: SortOrder
  }

  export type pessoaCarismaAvgOrderByAggregateInput = {
    pessoaId?: SortOrder
    tipoCarismaId?: SortOrder
  }

  export type pessoaCarismaMaxOrderByAggregateInput = {
    pessoaId?: SortOrder
    tipoCarismaId?: SortOrder
  }

  export type pessoaCarismaMinOrderByAggregateInput = {
    pessoaId?: SortOrder
    tipoCarismaId?: SortOrder
  }

  export type pessoaCarismaSumOrderByAggregateInput = {
    pessoaId?: SortOrder
    tipoCarismaId?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type passaportePessoaCountOrderByAggregateInput = {
    id?: SortOrder
    pessoaId?: SortOrder
    numero?: SortOrder
    dataExpiracao?: SortOrder
    renovado?: SortOrder
    dataRenovacao?: SortOrder
  }

  export type passaportePessoaAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoaId?: SortOrder
  }

  export type passaportePessoaMaxOrderByAggregateInput = {
    id?: SortOrder
    pessoaId?: SortOrder
    numero?: SortOrder
    dataExpiracao?: SortOrder
    renovado?: SortOrder
    dataRenovacao?: SortOrder
  }

  export type passaportePessoaMinOrderByAggregateInput = {
    id?: SortOrder
    pessoaId?: SortOrder
    numero?: SortOrder
    dataExpiracao?: SortOrder
    renovado?: SortOrder
    dataRenovacao?: SortOrder
  }

  export type passaportePessoaSumOrderByAggregateInput = {
    id?: SortOrder
    pessoaId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type pessoaContatoCountOrderByAggregateInput = {
    id?: SortOrder
    telefoneResidencial?: SortOrder
    telefoneCelular?: SortOrder
    observacao?: SortOrder
    ativo?: SortOrder
    email?: SortOrder
    pessoaId?: SortOrder
  }

  export type pessoaContatoAvgOrderByAggregateInput = {
    id?: SortOrder
    pessoaId?: SortOrder
  }

  export type pessoaContatoMaxOrderByAggregateInput = {
    id?: SortOrder
    telefoneResidencial?: SortOrder
    telefoneCelular?: SortOrder
    observacao?: SortOrder
    ativo?: SortOrder
    email?: SortOrder
    pessoaId?: SortOrder
  }

  export type pessoaContatoMinOrderByAggregateInput = {
    id?: SortOrder
    telefoneResidencial?: SortOrder
    telefoneCelular?: SortOrder
    observacao?: SortOrder
    ativo?: SortOrder
    email?: SortOrder
    pessoaId?: SortOrder
  }

  export type pessoaContatoSumOrderByAggregateInput = {
    id?: SortOrder
    pessoaId?: SortOrder
  }

  export type tipoDioceseCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoDioceseAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipoDioceseMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoDioceseMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoDioceseSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoDioceseScalarRelationFilter = {
    is?: tipoDioceseWhereInput
    isNot?: tipoDioceseWhereInput
  }

  export type dioceseCountOrderByAggregateInput = {
    id?: SortOrder
    tipoDioceseId?: SortOrder
    descricao?: SortOrder
    enderecoId?: SortOrder
  }

  export type dioceseAvgOrderByAggregateInput = {
    id?: SortOrder
    tipoDioceseId?: SortOrder
    enderecoId?: SortOrder
  }

  export type dioceseMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoDioceseId?: SortOrder
    descricao?: SortOrder
    enderecoId?: SortOrder
  }

  export type dioceseMinOrderByAggregateInput = {
    id?: SortOrder
    tipoDioceseId?: SortOrder
    descricao?: SortOrder
    enderecoId?: SortOrder
  }

  export type dioceseSumOrderByAggregateInput = {
    id?: SortOrder
    tipoDioceseId?: SortOrder
    enderecoId?: SortOrder
  }

  export type DioceseScalarRelationFilter = {
    is?: dioceseWhereInput
    isNot?: dioceseWhereInput
  }

  export type paroquiaCountOrderByAggregateInput = {
    id?: SortOrder
    enderecoId?: SortOrder
    dioceseId?: SortOrder
    descricao?: SortOrder
  }

  export type paroquiaAvgOrderByAggregateInput = {
    id?: SortOrder
    enderecoId?: SortOrder
    dioceseId?: SortOrder
  }

  export type paroquiaMaxOrderByAggregateInput = {
    id?: SortOrder
    enderecoId?: SortOrder
    dioceseId?: SortOrder
    descricao?: SortOrder
  }

  export type paroquiaMinOrderByAggregateInput = {
    id?: SortOrder
    enderecoId?: SortOrder
    dioceseId?: SortOrder
    descricao?: SortOrder
  }

  export type paroquiaSumOrderByAggregateInput = {
    id?: SortOrder
    enderecoId?: SortOrder
    dioceseId?: SortOrder
  }

  export type ParoquiaScalarRelationFilter = {
    is?: paroquiaWhereInput
    isNot?: paroquiaWhereInput
  }

  export type paroquiaPessoasPessoaIdParoquiaIdCompoundUniqueInput = {
    pessoaId: number
    paroquiaId: number
  }

  export type paroquiaPessoasCountOrderByAggregateInput = {
    pessoaId?: SortOrder
    paroquiaId?: SortOrder
  }

  export type paroquiaPessoasAvgOrderByAggregateInput = {
    pessoaId?: SortOrder
    paroquiaId?: SortOrder
  }

  export type paroquiaPessoasMaxOrderByAggregateInput = {
    pessoaId?: SortOrder
    paroquiaId?: SortOrder
  }

  export type paroquiaPessoasMinOrderByAggregateInput = {
    pessoaId?: SortOrder
    paroquiaId?: SortOrder
  }

  export type paroquiaPessoasSumOrderByAggregateInput = {
    pessoaId?: SortOrder
    paroquiaId?: SortOrder
  }

  export type etapaCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type etapaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type etapaMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type etapaMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type etapaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EquipeRegiaoListRelationFilter = {
    every?: equipeRegiaoWhereInput
    some?: equipeRegiaoWhereInput
    none?: equipeRegiaoWhereInput
  }

  export type LocalidadeRegiaoListRelationFilter = {
    every?: localidadeRegiaoWhereInput
    some?: localidadeRegiaoWhereInput
    none?: localidadeRegiaoWhereInput
  }

  export type equipeRegiaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type localidadeRegiaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type regiaoCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    macroRegiao?: SortOrder
  }

  export type regiaoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type regiaoMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    macroRegiao?: SortOrder
  }

  export type regiaoMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    macroRegiao?: SortOrder
  }

  export type regiaoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EquipeTipoEquipeListRelationFilter = {
    every?: equipeTipoEquipeWhereInput
    some?: equipeTipoEquipeWhereInput
    none?: equipeTipoEquipeWhereInput
  }

  export type equipeTipoEquipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tipoEquipeCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoEquipeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipoEquipeMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoEquipeMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoEquipeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type equipeCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type equipeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type equipeMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type equipeMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type equipeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EquipeScalarRelationFilter = {
    is?: equipeWhereInput
    isNot?: equipeWhereInput
  }

  export type TipoEquipeScalarRelationFilter = {
    is?: tipoEquipeWhereInput
    isNot?: tipoEquipeWhereInput
  }

  export type equipeTipoEquipeEquipeIdTipoEquipeIdCompoundUniqueInput = {
    equipeId: number
    tipoEquipeId: number
  }

  export type equipeTipoEquipeCountOrderByAggregateInput = {
    equipeId?: SortOrder
    tipoEquipeId?: SortOrder
  }

  export type equipeTipoEquipeAvgOrderByAggregateInput = {
    equipeId?: SortOrder
    tipoEquipeId?: SortOrder
  }

  export type equipeTipoEquipeMaxOrderByAggregateInput = {
    equipeId?: SortOrder
    tipoEquipeId?: SortOrder
  }

  export type equipeTipoEquipeMinOrderByAggregateInput = {
    equipeId?: SortOrder
    tipoEquipeId?: SortOrder
  }

  export type equipeTipoEquipeSumOrderByAggregateInput = {
    equipeId?: SortOrder
    tipoEquipeId?: SortOrder
  }

  export type RegiaoScalarRelationFilter = {
    is?: regiaoWhereInput
    isNot?: regiaoWhereInput
  }

  export type equipeRegiaoEquipeIdRegiaoIdCompoundUniqueInput = {
    equipeId: number
    regiaoId: number
  }

  export type equipeRegiaoCountOrderByAggregateInput = {
    equipeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type equipeRegiaoAvgOrderByAggregateInput = {
    equipeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type equipeRegiaoMaxOrderByAggregateInput = {
    equipeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type equipeRegiaoMinOrderByAggregateInput = {
    equipeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type equipeRegiaoSumOrderByAggregateInput = {
    equipeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type equipePessoasEquipeIdPessoaIdCompoundUniqueInput = {
    equipeId: number
    pessoaId: number
  }

  export type equipePessoasCountOrderByAggregateInput = {
    equipeId?: SortOrder
    pessoaId?: SortOrder
  }

  export type equipePessoasAvgOrderByAggregateInput = {
    equipeId?: SortOrder
    pessoaId?: SortOrder
  }

  export type equipePessoasMaxOrderByAggregateInput = {
    equipeId?: SortOrder
    pessoaId?: SortOrder
  }

  export type equipePessoasMinOrderByAggregateInput = {
    equipeId?: SortOrder
    pessoaId?: SortOrder
  }

  export type equipePessoasSumOrderByAggregateInput = {
    equipeId?: SortOrder
    pessoaId?: SortOrder
  }

  export type TipoLocalidadeScalarRelationFilter = {
    is?: tipoLocalidadeWhereInput
    isNot?: tipoLocalidadeWhereInput
  }

  export type localidadeCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    dioceseId?: SortOrder
    tipoLocalidadeId?: SortOrder
    observacao?: SortOrder
    enderecoId?: SortOrder
  }

  export type localidadeAvgOrderByAggregateInput = {
    id?: SortOrder
    dioceseId?: SortOrder
    tipoLocalidadeId?: SortOrder
    enderecoId?: SortOrder
  }

  export type localidadeMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    dioceseId?: SortOrder
    tipoLocalidadeId?: SortOrder
    observacao?: SortOrder
    enderecoId?: SortOrder
  }

  export type localidadeMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
    dioceseId?: SortOrder
    tipoLocalidadeId?: SortOrder
    observacao?: SortOrder
    enderecoId?: SortOrder
  }

  export type localidadeSumOrderByAggregateInput = {
    id?: SortOrder
    dioceseId?: SortOrder
    tipoLocalidadeId?: SortOrder
    enderecoId?: SortOrder
  }

  export type LocalidadeScalarRelationFilter = {
    is?: localidadeWhereInput
    isNot?: localidadeWhereInput
  }

  export type localidadeRegiaoLocalidadeIdRegiaoIdCompoundUniqueInput = {
    localidadeId: number
    regiaoId: number
  }

  export type localidadeRegiaoCountOrderByAggregateInput = {
    localidadeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type localidadeRegiaoAvgOrderByAggregateInput = {
    localidadeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type localidadeRegiaoMaxOrderByAggregateInput = {
    localidadeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type localidadeRegiaoMinOrderByAggregateInput = {
    localidadeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type localidadeRegiaoSumOrderByAggregateInput = {
    localidadeId?: SortOrder
    regiaoId?: SortOrder
  }

  export type tipoLocalidadeCountOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoLocalidadeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tipoLocalidadeMaxOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoLocalidadeMinOrderByAggregateInput = {
    id?: SortOrder
    descricao?: SortOrder
  }

  export type tipoLocalidadeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumrolesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles | EnumrolesFieldRefInput<$PrismaModel>
    in?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    not?: NestedEnumrolesFilter<$PrismaModel> | $Enums.roles
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrder
    verifiedWhatsapp?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrder
    verifiedWhatsapp?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    whatsapp?: SortOrder
    verifiedWhatsapp?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumrolesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles | EnumrolesFieldRefInput<$PrismaModel>
    in?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    not?: NestedEnumrolesWithAggregatesFilter<$PrismaModel> | $Enums.roles
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrolesFilter<$PrismaModel>
    _max?: NestedEnumrolesFilter<$PrismaModel>
  }

  export type estadoCreateNestedManyWithoutPaisInput = {
    create?: XOR<estadoCreateWithoutPaisInput, estadoUncheckedCreateWithoutPaisInput> | estadoCreateWithoutPaisInput[] | estadoUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: estadoCreateOrConnectWithoutPaisInput | estadoCreateOrConnectWithoutPaisInput[]
    createMany?: estadoCreateManyPaisInputEnvelope
    connect?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
  }

  export type estadoUncheckedCreateNestedManyWithoutPaisInput = {
    create?: XOR<estadoCreateWithoutPaisInput, estadoUncheckedCreateWithoutPaisInput> | estadoCreateWithoutPaisInput[] | estadoUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: estadoCreateOrConnectWithoutPaisInput | estadoCreateOrConnectWithoutPaisInput[]
    createMany?: estadoCreateManyPaisInputEnvelope
    connect?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type estadoUpdateManyWithoutPaisNestedInput = {
    create?: XOR<estadoCreateWithoutPaisInput, estadoUncheckedCreateWithoutPaisInput> | estadoCreateWithoutPaisInput[] | estadoUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: estadoCreateOrConnectWithoutPaisInput | estadoCreateOrConnectWithoutPaisInput[]
    upsert?: estadoUpsertWithWhereUniqueWithoutPaisInput | estadoUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: estadoCreateManyPaisInputEnvelope
    set?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
    disconnect?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
    delete?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
    connect?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
    update?: estadoUpdateWithWhereUniqueWithoutPaisInput | estadoUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: estadoUpdateManyWithWhereWithoutPaisInput | estadoUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: estadoScalarWhereInput | estadoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type estadoUncheckedUpdateManyWithoutPaisNestedInput = {
    create?: XOR<estadoCreateWithoutPaisInput, estadoUncheckedCreateWithoutPaisInput> | estadoCreateWithoutPaisInput[] | estadoUncheckedCreateWithoutPaisInput[]
    connectOrCreate?: estadoCreateOrConnectWithoutPaisInput | estadoCreateOrConnectWithoutPaisInput[]
    upsert?: estadoUpsertWithWhereUniqueWithoutPaisInput | estadoUpsertWithWhereUniqueWithoutPaisInput[]
    createMany?: estadoCreateManyPaisInputEnvelope
    set?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
    disconnect?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
    delete?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
    connect?: estadoWhereUniqueInput | estadoWhereUniqueInput[]
    update?: estadoUpdateWithWhereUniqueWithoutPaisInput | estadoUpdateWithWhereUniqueWithoutPaisInput[]
    updateMany?: estadoUpdateManyWithWhereWithoutPaisInput | estadoUpdateManyWithWhereWithoutPaisInput[]
    deleteMany?: estadoScalarWhereInput | estadoScalarWhereInput[]
  }

  export type paisCreateNestedOneWithoutEstadoInput = {
    create?: XOR<paisCreateWithoutEstadoInput, paisUncheckedCreateWithoutEstadoInput>
    connectOrCreate?: paisCreateOrConnectWithoutEstadoInput
    connect?: paisWhereUniqueInput
  }

  export type cidadeCreateNestedManyWithoutEstadoInput = {
    create?: XOR<cidadeCreateWithoutEstadoInput, cidadeUncheckedCreateWithoutEstadoInput> | cidadeCreateWithoutEstadoInput[] | cidadeUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: cidadeCreateOrConnectWithoutEstadoInput | cidadeCreateOrConnectWithoutEstadoInput[]
    createMany?: cidadeCreateManyEstadoInputEnvelope
    connect?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
  }

  export type cidadeUncheckedCreateNestedManyWithoutEstadoInput = {
    create?: XOR<cidadeCreateWithoutEstadoInput, cidadeUncheckedCreateWithoutEstadoInput> | cidadeCreateWithoutEstadoInput[] | cidadeUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: cidadeCreateOrConnectWithoutEstadoInput | cidadeCreateOrConnectWithoutEstadoInput[]
    createMany?: cidadeCreateManyEstadoInputEnvelope
    connect?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type paisUpdateOneRequiredWithoutEstadoNestedInput = {
    create?: XOR<paisCreateWithoutEstadoInput, paisUncheckedCreateWithoutEstadoInput>
    connectOrCreate?: paisCreateOrConnectWithoutEstadoInput
    upsert?: paisUpsertWithoutEstadoInput
    connect?: paisWhereUniqueInput
    update?: XOR<XOR<paisUpdateToOneWithWhereWithoutEstadoInput, paisUpdateWithoutEstadoInput>, paisUncheckedUpdateWithoutEstadoInput>
  }

  export type cidadeUpdateManyWithoutEstadoNestedInput = {
    create?: XOR<cidadeCreateWithoutEstadoInput, cidadeUncheckedCreateWithoutEstadoInput> | cidadeCreateWithoutEstadoInput[] | cidadeUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: cidadeCreateOrConnectWithoutEstadoInput | cidadeCreateOrConnectWithoutEstadoInput[]
    upsert?: cidadeUpsertWithWhereUniqueWithoutEstadoInput | cidadeUpsertWithWhereUniqueWithoutEstadoInput[]
    createMany?: cidadeCreateManyEstadoInputEnvelope
    set?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
    disconnect?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
    delete?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
    connect?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
    update?: cidadeUpdateWithWhereUniqueWithoutEstadoInput | cidadeUpdateWithWhereUniqueWithoutEstadoInput[]
    updateMany?: cidadeUpdateManyWithWhereWithoutEstadoInput | cidadeUpdateManyWithWhereWithoutEstadoInput[]
    deleteMany?: cidadeScalarWhereInput | cidadeScalarWhereInput[]
  }

  export type cidadeUncheckedUpdateManyWithoutEstadoNestedInput = {
    create?: XOR<cidadeCreateWithoutEstadoInput, cidadeUncheckedCreateWithoutEstadoInput> | cidadeCreateWithoutEstadoInput[] | cidadeUncheckedCreateWithoutEstadoInput[]
    connectOrCreate?: cidadeCreateOrConnectWithoutEstadoInput | cidadeCreateOrConnectWithoutEstadoInput[]
    upsert?: cidadeUpsertWithWhereUniqueWithoutEstadoInput | cidadeUpsertWithWhereUniqueWithoutEstadoInput[]
    createMany?: cidadeCreateManyEstadoInputEnvelope
    set?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
    disconnect?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
    delete?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
    connect?: cidadeWhereUniqueInput | cidadeWhereUniqueInput[]
    update?: cidadeUpdateWithWhereUniqueWithoutEstadoInput | cidadeUpdateWithWhereUniqueWithoutEstadoInput[]
    updateMany?: cidadeUpdateManyWithWhereWithoutEstadoInput | cidadeUpdateManyWithWhereWithoutEstadoInput[]
    deleteMany?: cidadeScalarWhereInput | cidadeScalarWhereInput[]
  }

  export type estadoCreateNestedOneWithoutCidadeInput = {
    create?: XOR<estadoCreateWithoutCidadeInput, estadoUncheckedCreateWithoutCidadeInput>
    connectOrCreate?: estadoCreateOrConnectWithoutCidadeInput
    connect?: estadoWhereUniqueInput
  }

  export type estadoUpdateOneRequiredWithoutCidadeNestedInput = {
    create?: XOR<estadoCreateWithoutCidadeInput, estadoUncheckedCreateWithoutCidadeInput>
    connectOrCreate?: estadoCreateOrConnectWithoutCidadeInput
    upsert?: estadoUpsertWithoutCidadeInput
    connect?: estadoWhereUniqueInput
    update?: XOR<XOR<estadoUpdateToOneWithWhereWithoutCidadeInput, estadoUpdateWithoutCidadeInput>, estadoUncheckedUpdateWithoutCidadeInput>
  }

  export type paroquiaCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<paroquiaCreateWithoutEnderecoInput, paroquiaUncheckedCreateWithoutEnderecoInput> | paroquiaCreateWithoutEnderecoInput[] | paroquiaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: paroquiaCreateOrConnectWithoutEnderecoInput | paroquiaCreateOrConnectWithoutEnderecoInput[]
    createMany?: paroquiaCreateManyEnderecoInputEnvelope
    connect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
  }

  export type pessoaEnderecoCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<pessoaEnderecoCreateWithoutEnderecoInput, pessoaEnderecoUncheckedCreateWithoutEnderecoInput> | pessoaEnderecoCreateWithoutEnderecoInput[] | pessoaEnderecoUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: pessoaEnderecoCreateOrConnectWithoutEnderecoInput | pessoaEnderecoCreateOrConnectWithoutEnderecoInput[]
    createMany?: pessoaEnderecoCreateManyEnderecoInputEnvelope
    connect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
  }

  export type localidadeCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<localidadeCreateWithoutEnderecoInput, localidadeUncheckedCreateWithoutEnderecoInput> | localidadeCreateWithoutEnderecoInput[] | localidadeUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutEnderecoInput | localidadeCreateOrConnectWithoutEnderecoInput[]
    createMany?: localidadeCreateManyEnderecoInputEnvelope
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
  }

  export type dioceseCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<dioceseCreateWithoutEnderecoInput, dioceseUncheckedCreateWithoutEnderecoInput> | dioceseCreateWithoutEnderecoInput[] | dioceseUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: dioceseCreateOrConnectWithoutEnderecoInput | dioceseCreateOrConnectWithoutEnderecoInput[]
    createMany?: dioceseCreateManyEnderecoInputEnvelope
    connect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
  }

  export type paroquiaUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<paroquiaCreateWithoutEnderecoInput, paroquiaUncheckedCreateWithoutEnderecoInput> | paroquiaCreateWithoutEnderecoInput[] | paroquiaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: paroquiaCreateOrConnectWithoutEnderecoInput | paroquiaCreateOrConnectWithoutEnderecoInput[]
    createMany?: paroquiaCreateManyEnderecoInputEnvelope
    connect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
  }

  export type pessoaEnderecoUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<pessoaEnderecoCreateWithoutEnderecoInput, pessoaEnderecoUncheckedCreateWithoutEnderecoInput> | pessoaEnderecoCreateWithoutEnderecoInput[] | pessoaEnderecoUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: pessoaEnderecoCreateOrConnectWithoutEnderecoInput | pessoaEnderecoCreateOrConnectWithoutEnderecoInput[]
    createMany?: pessoaEnderecoCreateManyEnderecoInputEnvelope
    connect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
  }

  export type localidadeUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<localidadeCreateWithoutEnderecoInput, localidadeUncheckedCreateWithoutEnderecoInput> | localidadeCreateWithoutEnderecoInput[] | localidadeUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutEnderecoInput | localidadeCreateOrConnectWithoutEnderecoInput[]
    createMany?: localidadeCreateManyEnderecoInputEnvelope
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
  }

  export type dioceseUncheckedCreateNestedManyWithoutEnderecoInput = {
    create?: XOR<dioceseCreateWithoutEnderecoInput, dioceseUncheckedCreateWithoutEnderecoInput> | dioceseCreateWithoutEnderecoInput[] | dioceseUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: dioceseCreateOrConnectWithoutEnderecoInput | dioceseCreateOrConnectWithoutEnderecoInput[]
    createMany?: dioceseCreateManyEnderecoInputEnvelope
    connect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
  }

  export type paroquiaUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<paroquiaCreateWithoutEnderecoInput, paroquiaUncheckedCreateWithoutEnderecoInput> | paroquiaCreateWithoutEnderecoInput[] | paroquiaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: paroquiaCreateOrConnectWithoutEnderecoInput | paroquiaCreateOrConnectWithoutEnderecoInput[]
    upsert?: paroquiaUpsertWithWhereUniqueWithoutEnderecoInput | paroquiaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: paroquiaCreateManyEnderecoInputEnvelope
    set?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    disconnect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    delete?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    connect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    update?: paroquiaUpdateWithWhereUniqueWithoutEnderecoInput | paroquiaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: paroquiaUpdateManyWithWhereWithoutEnderecoInput | paroquiaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: paroquiaScalarWhereInput | paroquiaScalarWhereInput[]
  }

  export type pessoaEnderecoUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<pessoaEnderecoCreateWithoutEnderecoInput, pessoaEnderecoUncheckedCreateWithoutEnderecoInput> | pessoaEnderecoCreateWithoutEnderecoInput[] | pessoaEnderecoUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: pessoaEnderecoCreateOrConnectWithoutEnderecoInput | pessoaEnderecoCreateOrConnectWithoutEnderecoInput[]
    upsert?: pessoaEnderecoUpsertWithWhereUniqueWithoutEnderecoInput | pessoaEnderecoUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: pessoaEnderecoCreateManyEnderecoInputEnvelope
    set?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    disconnect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    delete?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    connect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    update?: pessoaEnderecoUpdateWithWhereUniqueWithoutEnderecoInput | pessoaEnderecoUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: pessoaEnderecoUpdateManyWithWhereWithoutEnderecoInput | pessoaEnderecoUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: pessoaEnderecoScalarWhereInput | pessoaEnderecoScalarWhereInput[]
  }

  export type localidadeUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<localidadeCreateWithoutEnderecoInput, localidadeUncheckedCreateWithoutEnderecoInput> | localidadeCreateWithoutEnderecoInput[] | localidadeUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutEnderecoInput | localidadeCreateOrConnectWithoutEnderecoInput[]
    upsert?: localidadeUpsertWithWhereUniqueWithoutEnderecoInput | localidadeUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: localidadeCreateManyEnderecoInputEnvelope
    set?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    disconnect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    delete?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    update?: localidadeUpdateWithWhereUniqueWithoutEnderecoInput | localidadeUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: localidadeUpdateManyWithWhereWithoutEnderecoInput | localidadeUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: localidadeScalarWhereInput | localidadeScalarWhereInput[]
  }

  export type dioceseUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<dioceseCreateWithoutEnderecoInput, dioceseUncheckedCreateWithoutEnderecoInput> | dioceseCreateWithoutEnderecoInput[] | dioceseUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: dioceseCreateOrConnectWithoutEnderecoInput | dioceseCreateOrConnectWithoutEnderecoInput[]
    upsert?: dioceseUpsertWithWhereUniqueWithoutEnderecoInput | dioceseUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: dioceseCreateManyEnderecoInputEnvelope
    set?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    disconnect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    delete?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    connect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    update?: dioceseUpdateWithWhereUniqueWithoutEnderecoInput | dioceseUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: dioceseUpdateManyWithWhereWithoutEnderecoInput | dioceseUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: dioceseScalarWhereInput | dioceseScalarWhereInput[]
  }

  export type paroquiaUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<paroquiaCreateWithoutEnderecoInput, paroquiaUncheckedCreateWithoutEnderecoInput> | paroquiaCreateWithoutEnderecoInput[] | paroquiaUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: paroquiaCreateOrConnectWithoutEnderecoInput | paroquiaCreateOrConnectWithoutEnderecoInput[]
    upsert?: paroquiaUpsertWithWhereUniqueWithoutEnderecoInput | paroquiaUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: paroquiaCreateManyEnderecoInputEnvelope
    set?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    disconnect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    delete?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    connect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    update?: paroquiaUpdateWithWhereUniqueWithoutEnderecoInput | paroquiaUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: paroquiaUpdateManyWithWhereWithoutEnderecoInput | paroquiaUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: paroquiaScalarWhereInput | paroquiaScalarWhereInput[]
  }

  export type pessoaEnderecoUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<pessoaEnderecoCreateWithoutEnderecoInput, pessoaEnderecoUncheckedCreateWithoutEnderecoInput> | pessoaEnderecoCreateWithoutEnderecoInput[] | pessoaEnderecoUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: pessoaEnderecoCreateOrConnectWithoutEnderecoInput | pessoaEnderecoCreateOrConnectWithoutEnderecoInput[]
    upsert?: pessoaEnderecoUpsertWithWhereUniqueWithoutEnderecoInput | pessoaEnderecoUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: pessoaEnderecoCreateManyEnderecoInputEnvelope
    set?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    disconnect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    delete?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    connect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    update?: pessoaEnderecoUpdateWithWhereUniqueWithoutEnderecoInput | pessoaEnderecoUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: pessoaEnderecoUpdateManyWithWhereWithoutEnderecoInput | pessoaEnderecoUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: pessoaEnderecoScalarWhereInput | pessoaEnderecoScalarWhereInput[]
  }

  export type localidadeUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<localidadeCreateWithoutEnderecoInput, localidadeUncheckedCreateWithoutEnderecoInput> | localidadeCreateWithoutEnderecoInput[] | localidadeUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutEnderecoInput | localidadeCreateOrConnectWithoutEnderecoInput[]
    upsert?: localidadeUpsertWithWhereUniqueWithoutEnderecoInput | localidadeUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: localidadeCreateManyEnderecoInputEnvelope
    set?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    disconnect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    delete?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    update?: localidadeUpdateWithWhereUniqueWithoutEnderecoInput | localidadeUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: localidadeUpdateManyWithWhereWithoutEnderecoInput | localidadeUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: localidadeScalarWhereInput | localidadeScalarWhereInput[]
  }

  export type dioceseUncheckedUpdateManyWithoutEnderecoNestedInput = {
    create?: XOR<dioceseCreateWithoutEnderecoInput, dioceseUncheckedCreateWithoutEnderecoInput> | dioceseCreateWithoutEnderecoInput[] | dioceseUncheckedCreateWithoutEnderecoInput[]
    connectOrCreate?: dioceseCreateOrConnectWithoutEnderecoInput | dioceseCreateOrConnectWithoutEnderecoInput[]
    upsert?: dioceseUpsertWithWhereUniqueWithoutEnderecoInput | dioceseUpsertWithWhereUniqueWithoutEnderecoInput[]
    createMany?: dioceseCreateManyEnderecoInputEnvelope
    set?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    disconnect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    delete?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    connect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    update?: dioceseUpdateWithWhereUniqueWithoutEnderecoInput | dioceseUpdateWithWhereUniqueWithoutEnderecoInput[]
    updateMany?: dioceseUpdateManyWithWhereWithoutEnderecoInput | dioceseUpdateManyWithWhereWithoutEnderecoInput[]
    deleteMany?: dioceseScalarWhereInput | dioceseScalarWhereInput[]
  }

  export type pessoaCarismaCreateNestedManyWithoutTipoCarismaInput = {
    create?: XOR<pessoaCarismaCreateWithoutTipoCarismaInput, pessoaCarismaUncheckedCreateWithoutTipoCarismaInput> | pessoaCarismaCreateWithoutTipoCarismaInput[] | pessoaCarismaUncheckedCreateWithoutTipoCarismaInput[]
    connectOrCreate?: pessoaCarismaCreateOrConnectWithoutTipoCarismaInput | pessoaCarismaCreateOrConnectWithoutTipoCarismaInput[]
    createMany?: pessoaCarismaCreateManyTipoCarismaInputEnvelope
    connect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
  }

  export type pessoaCarismaUncheckedCreateNestedManyWithoutTipoCarismaInput = {
    create?: XOR<pessoaCarismaCreateWithoutTipoCarismaInput, pessoaCarismaUncheckedCreateWithoutTipoCarismaInput> | pessoaCarismaCreateWithoutTipoCarismaInput[] | pessoaCarismaUncheckedCreateWithoutTipoCarismaInput[]
    connectOrCreate?: pessoaCarismaCreateOrConnectWithoutTipoCarismaInput | pessoaCarismaCreateOrConnectWithoutTipoCarismaInput[]
    createMany?: pessoaCarismaCreateManyTipoCarismaInputEnvelope
    connect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
  }

  export type pessoaCarismaUpdateManyWithoutTipoCarismaNestedInput = {
    create?: XOR<pessoaCarismaCreateWithoutTipoCarismaInput, pessoaCarismaUncheckedCreateWithoutTipoCarismaInput> | pessoaCarismaCreateWithoutTipoCarismaInput[] | pessoaCarismaUncheckedCreateWithoutTipoCarismaInput[]
    connectOrCreate?: pessoaCarismaCreateOrConnectWithoutTipoCarismaInput | pessoaCarismaCreateOrConnectWithoutTipoCarismaInput[]
    upsert?: pessoaCarismaUpsertWithWhereUniqueWithoutTipoCarismaInput | pessoaCarismaUpsertWithWhereUniqueWithoutTipoCarismaInput[]
    createMany?: pessoaCarismaCreateManyTipoCarismaInputEnvelope
    set?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    disconnect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    delete?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    connect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    update?: pessoaCarismaUpdateWithWhereUniqueWithoutTipoCarismaInput | pessoaCarismaUpdateWithWhereUniqueWithoutTipoCarismaInput[]
    updateMany?: pessoaCarismaUpdateManyWithWhereWithoutTipoCarismaInput | pessoaCarismaUpdateManyWithWhereWithoutTipoCarismaInput[]
    deleteMany?: pessoaCarismaScalarWhereInput | pessoaCarismaScalarWhereInput[]
  }

  export type pessoaCarismaUncheckedUpdateManyWithoutTipoCarismaNestedInput = {
    create?: XOR<pessoaCarismaCreateWithoutTipoCarismaInput, pessoaCarismaUncheckedCreateWithoutTipoCarismaInput> | pessoaCarismaCreateWithoutTipoCarismaInput[] | pessoaCarismaUncheckedCreateWithoutTipoCarismaInput[]
    connectOrCreate?: pessoaCarismaCreateOrConnectWithoutTipoCarismaInput | pessoaCarismaCreateOrConnectWithoutTipoCarismaInput[]
    upsert?: pessoaCarismaUpsertWithWhereUniqueWithoutTipoCarismaInput | pessoaCarismaUpsertWithWhereUniqueWithoutTipoCarismaInput[]
    createMany?: pessoaCarismaCreateManyTipoCarismaInputEnvelope
    set?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    disconnect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    delete?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    connect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    update?: pessoaCarismaUpdateWithWhereUniqueWithoutTipoCarismaInput | pessoaCarismaUpdateWithWhereUniqueWithoutTipoCarismaInput[]
    updateMany?: pessoaCarismaUpdateManyWithWhereWithoutTipoCarismaInput | pessoaCarismaUpdateManyWithWhereWithoutTipoCarismaInput[]
    deleteMany?: pessoaCarismaScalarWhereInput | pessoaCarismaScalarWhereInput[]
  }

  export type pessoaCreateNestedManyWithoutEstadoCivilInput = {
    create?: XOR<pessoaCreateWithoutEstadoCivilInput, pessoaUncheckedCreateWithoutEstadoCivilInput> | pessoaCreateWithoutEstadoCivilInput[] | pessoaUncheckedCreateWithoutEstadoCivilInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEstadoCivilInput | pessoaCreateOrConnectWithoutEstadoCivilInput[]
    createMany?: pessoaCreateManyEstadoCivilInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUncheckedCreateNestedManyWithoutEstadoCivilInput = {
    create?: XOR<pessoaCreateWithoutEstadoCivilInput, pessoaUncheckedCreateWithoutEstadoCivilInput> | pessoaCreateWithoutEstadoCivilInput[] | pessoaUncheckedCreateWithoutEstadoCivilInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEstadoCivilInput | pessoaCreateOrConnectWithoutEstadoCivilInput[]
    createMany?: pessoaCreateManyEstadoCivilInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUpdateManyWithoutEstadoCivilNestedInput = {
    create?: XOR<pessoaCreateWithoutEstadoCivilInput, pessoaUncheckedCreateWithoutEstadoCivilInput> | pessoaCreateWithoutEstadoCivilInput[] | pessoaUncheckedCreateWithoutEstadoCivilInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEstadoCivilInput | pessoaCreateOrConnectWithoutEstadoCivilInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutEstadoCivilInput | pessoaUpsertWithWhereUniqueWithoutEstadoCivilInput[]
    createMany?: pessoaCreateManyEstadoCivilInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutEstadoCivilInput | pessoaUpdateWithWhereUniqueWithoutEstadoCivilInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutEstadoCivilInput | pessoaUpdateManyWithWhereWithoutEstadoCivilInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type pessoaUncheckedUpdateManyWithoutEstadoCivilNestedInput = {
    create?: XOR<pessoaCreateWithoutEstadoCivilInput, pessoaUncheckedCreateWithoutEstadoCivilInput> | pessoaCreateWithoutEstadoCivilInput[] | pessoaUncheckedCreateWithoutEstadoCivilInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEstadoCivilInput | pessoaCreateOrConnectWithoutEstadoCivilInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutEstadoCivilInput | pessoaUpsertWithWhereUniqueWithoutEstadoCivilInput[]
    createMany?: pessoaCreateManyEstadoCivilInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutEstadoCivilInput | pessoaUpdateWithWhereUniqueWithoutEstadoCivilInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutEstadoCivilInput | pessoaUpdateManyWithWhereWithoutEstadoCivilInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type pessoaCreateNestedManyWithoutEscolaridadeInput = {
    create?: XOR<pessoaCreateWithoutEscolaridadeInput, pessoaUncheckedCreateWithoutEscolaridadeInput> | pessoaCreateWithoutEscolaridadeInput[] | pessoaUncheckedCreateWithoutEscolaridadeInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEscolaridadeInput | pessoaCreateOrConnectWithoutEscolaridadeInput[]
    createMany?: pessoaCreateManyEscolaridadeInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUncheckedCreateNestedManyWithoutEscolaridadeInput = {
    create?: XOR<pessoaCreateWithoutEscolaridadeInput, pessoaUncheckedCreateWithoutEscolaridadeInput> | pessoaCreateWithoutEscolaridadeInput[] | pessoaUncheckedCreateWithoutEscolaridadeInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEscolaridadeInput | pessoaCreateOrConnectWithoutEscolaridadeInput[]
    createMany?: pessoaCreateManyEscolaridadeInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUpdateManyWithoutEscolaridadeNestedInput = {
    create?: XOR<pessoaCreateWithoutEscolaridadeInput, pessoaUncheckedCreateWithoutEscolaridadeInput> | pessoaCreateWithoutEscolaridadeInput[] | pessoaUncheckedCreateWithoutEscolaridadeInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEscolaridadeInput | pessoaCreateOrConnectWithoutEscolaridadeInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutEscolaridadeInput | pessoaUpsertWithWhereUniqueWithoutEscolaridadeInput[]
    createMany?: pessoaCreateManyEscolaridadeInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutEscolaridadeInput | pessoaUpdateWithWhereUniqueWithoutEscolaridadeInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutEscolaridadeInput | pessoaUpdateManyWithWhereWithoutEscolaridadeInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type pessoaUncheckedUpdateManyWithoutEscolaridadeNestedInput = {
    create?: XOR<pessoaCreateWithoutEscolaridadeInput, pessoaUncheckedCreateWithoutEscolaridadeInput> | pessoaCreateWithoutEscolaridadeInput[] | pessoaUncheckedCreateWithoutEscolaridadeInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutEscolaridadeInput | pessoaCreateOrConnectWithoutEscolaridadeInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutEscolaridadeInput | pessoaUpsertWithWhereUniqueWithoutEscolaridadeInput[]
    createMany?: pessoaCreateManyEscolaridadeInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutEscolaridadeInput | pessoaUpdateWithWhereUniqueWithoutEscolaridadeInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutEscolaridadeInput | pessoaUpdateManyWithWhereWithoutEscolaridadeInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type estadoCivilCreateNestedOneWithoutPessoasInput = {
    create?: XOR<estadoCivilCreateWithoutPessoasInput, estadoCivilUncheckedCreateWithoutPessoasInput>
    connectOrCreate?: estadoCivilCreateOrConnectWithoutPessoasInput
    connect?: estadoCivilWhereUniqueInput
  }

  export type escolaridadeCreateNestedOneWithoutPessoasInput = {
    create?: XOR<escolaridadeCreateWithoutPessoasInput, escolaridadeUncheckedCreateWithoutPessoasInput>
    connectOrCreate?: escolaridadeCreateOrConnectWithoutPessoasInput
    connect?: escolaridadeWhereUniqueInput
  }

  export type tipoPessoaCreateNestedOneWithoutPessoaInput = {
    create?: XOR<tipoPessoaCreateWithoutPessoaInput, tipoPessoaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: tipoPessoaCreateOrConnectWithoutPessoaInput
    connect?: tipoPessoaWhereUniqueInput
  }

  export type passaportePessoaCreateNestedManyWithoutPessoaInput = {
    create?: XOR<passaportePessoaCreateWithoutPessoaInput, passaportePessoaUncheckedCreateWithoutPessoaInput> | passaportePessoaCreateWithoutPessoaInput[] | passaportePessoaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: passaportePessoaCreateOrConnectWithoutPessoaInput | passaportePessoaCreateOrConnectWithoutPessoaInput[]
    createMany?: passaportePessoaCreateManyPessoaInputEnvelope
    connect?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
  }

  export type pessoaContatoCreateNestedManyWithoutPessoaInput = {
    create?: XOR<pessoaContatoCreateWithoutPessoaInput, pessoaContatoUncheckedCreateWithoutPessoaInput> | pessoaContatoCreateWithoutPessoaInput[] | pessoaContatoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaContatoCreateOrConnectWithoutPessoaInput | pessoaContatoCreateOrConnectWithoutPessoaInput[]
    createMany?: pessoaContatoCreateManyPessoaInputEnvelope
    connect?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
  }

  export type paroquiaPessoasCreateNestedManyWithoutPessoaInput = {
    create?: XOR<paroquiaPessoasCreateWithoutPessoaInput, paroquiaPessoasUncheckedCreateWithoutPessoaInput> | paroquiaPessoasCreateWithoutPessoaInput[] | paroquiaPessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: paroquiaPessoasCreateOrConnectWithoutPessoaInput | paroquiaPessoasCreateOrConnectWithoutPessoaInput[]
    createMany?: paroquiaPessoasCreateManyPessoaInputEnvelope
    connect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
  }

  export type pessoaCasalCreateNestedManyWithoutMaridoInput = {
    create?: XOR<pessoaCasalCreateWithoutMaridoInput, pessoaCasalUncheckedCreateWithoutMaridoInput> | pessoaCasalCreateWithoutMaridoInput[] | pessoaCasalUncheckedCreateWithoutMaridoInput[]
    connectOrCreate?: pessoaCasalCreateOrConnectWithoutMaridoInput | pessoaCasalCreateOrConnectWithoutMaridoInput[]
    createMany?: pessoaCasalCreateManyMaridoInputEnvelope
    connect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
  }

  export type pessoaCasalCreateNestedManyWithoutMulherInput = {
    create?: XOR<pessoaCasalCreateWithoutMulherInput, pessoaCasalUncheckedCreateWithoutMulherInput> | pessoaCasalCreateWithoutMulherInput[] | pessoaCasalUncheckedCreateWithoutMulherInput[]
    connectOrCreate?: pessoaCasalCreateOrConnectWithoutMulherInput | pessoaCasalCreateOrConnectWithoutMulherInput[]
    createMany?: pessoaCasalCreateManyMulherInputEnvelope
    connect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
  }

  export type pessoaEnderecoCreateNestedManyWithoutPessoaInput = {
    create?: XOR<pessoaEnderecoCreateWithoutPessoaInput, pessoaEnderecoUncheckedCreateWithoutPessoaInput> | pessoaEnderecoCreateWithoutPessoaInput[] | pessoaEnderecoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaEnderecoCreateOrConnectWithoutPessoaInput | pessoaEnderecoCreateOrConnectWithoutPessoaInput[]
    createMany?: pessoaEnderecoCreateManyPessoaInputEnvelope
    connect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
  }

  export type equipePessoasCreateNestedManyWithoutPessoaInput = {
    create?: XOR<equipePessoasCreateWithoutPessoaInput, equipePessoasUncheckedCreateWithoutPessoaInput> | equipePessoasCreateWithoutPessoaInput[] | equipePessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: equipePessoasCreateOrConnectWithoutPessoaInput | equipePessoasCreateOrConnectWithoutPessoaInput[]
    createMany?: equipePessoasCreateManyPessoaInputEnvelope
    connect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
  }

  export type pessoaCarismaCreateNestedManyWithoutPessoaInput = {
    create?: XOR<pessoaCarismaCreateWithoutPessoaInput, pessoaCarismaUncheckedCreateWithoutPessoaInput> | pessoaCarismaCreateWithoutPessoaInput[] | pessoaCarismaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaCarismaCreateOrConnectWithoutPessoaInput | pessoaCarismaCreateOrConnectWithoutPessoaInput[]
    createMany?: pessoaCarismaCreateManyPessoaInputEnvelope
    connect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
  }

  export type passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<passaportePessoaCreateWithoutPessoaInput, passaportePessoaUncheckedCreateWithoutPessoaInput> | passaportePessoaCreateWithoutPessoaInput[] | passaportePessoaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: passaportePessoaCreateOrConnectWithoutPessoaInput | passaportePessoaCreateOrConnectWithoutPessoaInput[]
    createMany?: passaportePessoaCreateManyPessoaInputEnvelope
    connect?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
  }

  export type pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<pessoaContatoCreateWithoutPessoaInput, pessoaContatoUncheckedCreateWithoutPessoaInput> | pessoaContatoCreateWithoutPessoaInput[] | pessoaContatoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaContatoCreateOrConnectWithoutPessoaInput | pessoaContatoCreateOrConnectWithoutPessoaInput[]
    createMany?: pessoaContatoCreateManyPessoaInputEnvelope
    connect?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
  }

  export type paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<paroquiaPessoasCreateWithoutPessoaInput, paroquiaPessoasUncheckedCreateWithoutPessoaInput> | paroquiaPessoasCreateWithoutPessoaInput[] | paroquiaPessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: paroquiaPessoasCreateOrConnectWithoutPessoaInput | paroquiaPessoasCreateOrConnectWithoutPessoaInput[]
    createMany?: paroquiaPessoasCreateManyPessoaInputEnvelope
    connect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
  }

  export type pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput = {
    create?: XOR<pessoaCasalCreateWithoutMaridoInput, pessoaCasalUncheckedCreateWithoutMaridoInput> | pessoaCasalCreateWithoutMaridoInput[] | pessoaCasalUncheckedCreateWithoutMaridoInput[]
    connectOrCreate?: pessoaCasalCreateOrConnectWithoutMaridoInput | pessoaCasalCreateOrConnectWithoutMaridoInput[]
    createMany?: pessoaCasalCreateManyMaridoInputEnvelope
    connect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
  }

  export type pessoaCasalUncheckedCreateNestedManyWithoutMulherInput = {
    create?: XOR<pessoaCasalCreateWithoutMulherInput, pessoaCasalUncheckedCreateWithoutMulherInput> | pessoaCasalCreateWithoutMulherInput[] | pessoaCasalUncheckedCreateWithoutMulherInput[]
    connectOrCreate?: pessoaCasalCreateOrConnectWithoutMulherInput | pessoaCasalCreateOrConnectWithoutMulherInput[]
    createMany?: pessoaCasalCreateManyMulherInputEnvelope
    connect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
  }

  export type pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<pessoaEnderecoCreateWithoutPessoaInput, pessoaEnderecoUncheckedCreateWithoutPessoaInput> | pessoaEnderecoCreateWithoutPessoaInput[] | pessoaEnderecoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaEnderecoCreateOrConnectWithoutPessoaInput | pessoaEnderecoCreateOrConnectWithoutPessoaInput[]
    createMany?: pessoaEnderecoCreateManyPessoaInputEnvelope
    connect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
  }

  export type equipePessoasUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<equipePessoasCreateWithoutPessoaInput, equipePessoasUncheckedCreateWithoutPessoaInput> | equipePessoasCreateWithoutPessoaInput[] | equipePessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: equipePessoasCreateOrConnectWithoutPessoaInput | equipePessoasCreateOrConnectWithoutPessoaInput[]
    createMany?: equipePessoasCreateManyPessoaInputEnvelope
    connect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
  }

  export type pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput = {
    create?: XOR<pessoaCarismaCreateWithoutPessoaInput, pessoaCarismaUncheckedCreateWithoutPessoaInput> | pessoaCarismaCreateWithoutPessoaInput[] | pessoaCarismaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaCarismaCreateOrConnectWithoutPessoaInput | pessoaCarismaCreateOrConnectWithoutPessoaInput[]
    createMany?: pessoaCarismaCreateManyPessoaInputEnvelope
    connect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
  }

  export type EnumSexoFieldUpdateOperationsInput = {
    set?: $Enums.Sexo
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type estadoCivilUpdateOneRequiredWithoutPessoasNestedInput = {
    create?: XOR<estadoCivilCreateWithoutPessoasInput, estadoCivilUncheckedCreateWithoutPessoasInput>
    connectOrCreate?: estadoCivilCreateOrConnectWithoutPessoasInput
    upsert?: estadoCivilUpsertWithoutPessoasInput
    connect?: estadoCivilWhereUniqueInput
    update?: XOR<XOR<estadoCivilUpdateToOneWithWhereWithoutPessoasInput, estadoCivilUpdateWithoutPessoasInput>, estadoCivilUncheckedUpdateWithoutPessoasInput>
  }

  export type escolaridadeUpdateOneWithoutPessoasNestedInput = {
    create?: XOR<escolaridadeCreateWithoutPessoasInput, escolaridadeUncheckedCreateWithoutPessoasInput>
    connectOrCreate?: escolaridadeCreateOrConnectWithoutPessoasInput
    upsert?: escolaridadeUpsertWithoutPessoasInput
    disconnect?: escolaridadeWhereInput | boolean
    delete?: escolaridadeWhereInput | boolean
    connect?: escolaridadeWhereUniqueInput
    update?: XOR<XOR<escolaridadeUpdateToOneWithWhereWithoutPessoasInput, escolaridadeUpdateWithoutPessoasInput>, escolaridadeUncheckedUpdateWithoutPessoasInput>
  }

  export type tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput = {
    create?: XOR<tipoPessoaCreateWithoutPessoaInput, tipoPessoaUncheckedCreateWithoutPessoaInput>
    connectOrCreate?: tipoPessoaCreateOrConnectWithoutPessoaInput
    upsert?: tipoPessoaUpsertWithoutPessoaInput
    connect?: tipoPessoaWhereUniqueInput
    update?: XOR<XOR<tipoPessoaUpdateToOneWithWhereWithoutPessoaInput, tipoPessoaUpdateWithoutPessoaInput>, tipoPessoaUncheckedUpdateWithoutPessoaInput>
  }

  export type passaportePessoaUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<passaportePessoaCreateWithoutPessoaInput, passaportePessoaUncheckedCreateWithoutPessoaInput> | passaportePessoaCreateWithoutPessoaInput[] | passaportePessoaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: passaportePessoaCreateOrConnectWithoutPessoaInput | passaportePessoaCreateOrConnectWithoutPessoaInput[]
    upsert?: passaportePessoaUpsertWithWhereUniqueWithoutPessoaInput | passaportePessoaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: passaportePessoaCreateManyPessoaInputEnvelope
    set?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
    disconnect?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
    delete?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
    connect?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
    update?: passaportePessoaUpdateWithWhereUniqueWithoutPessoaInput | passaportePessoaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: passaportePessoaUpdateManyWithWhereWithoutPessoaInput | passaportePessoaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: passaportePessoaScalarWhereInput | passaportePessoaScalarWhereInput[]
  }

  export type pessoaContatoUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<pessoaContatoCreateWithoutPessoaInput, pessoaContatoUncheckedCreateWithoutPessoaInput> | pessoaContatoCreateWithoutPessoaInput[] | pessoaContatoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaContatoCreateOrConnectWithoutPessoaInput | pessoaContatoCreateOrConnectWithoutPessoaInput[]
    upsert?: pessoaContatoUpsertWithWhereUniqueWithoutPessoaInput | pessoaContatoUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: pessoaContatoCreateManyPessoaInputEnvelope
    set?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
    disconnect?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
    delete?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
    connect?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
    update?: pessoaContatoUpdateWithWhereUniqueWithoutPessoaInput | pessoaContatoUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: pessoaContatoUpdateManyWithWhereWithoutPessoaInput | pessoaContatoUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: pessoaContatoScalarWhereInput | pessoaContatoScalarWhereInput[]
  }

  export type paroquiaPessoasUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<paroquiaPessoasCreateWithoutPessoaInput, paroquiaPessoasUncheckedCreateWithoutPessoaInput> | paroquiaPessoasCreateWithoutPessoaInput[] | paroquiaPessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: paroquiaPessoasCreateOrConnectWithoutPessoaInput | paroquiaPessoasCreateOrConnectWithoutPessoaInput[]
    upsert?: paroquiaPessoasUpsertWithWhereUniqueWithoutPessoaInput | paroquiaPessoasUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: paroquiaPessoasCreateManyPessoaInputEnvelope
    set?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    disconnect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    delete?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    connect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    update?: paroquiaPessoasUpdateWithWhereUniqueWithoutPessoaInput | paroquiaPessoasUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: paroquiaPessoasUpdateManyWithWhereWithoutPessoaInput | paroquiaPessoasUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: paroquiaPessoasScalarWhereInput | paroquiaPessoasScalarWhereInput[]
  }

  export type pessoaCasalUpdateManyWithoutMaridoNestedInput = {
    create?: XOR<pessoaCasalCreateWithoutMaridoInput, pessoaCasalUncheckedCreateWithoutMaridoInput> | pessoaCasalCreateWithoutMaridoInput[] | pessoaCasalUncheckedCreateWithoutMaridoInput[]
    connectOrCreate?: pessoaCasalCreateOrConnectWithoutMaridoInput | pessoaCasalCreateOrConnectWithoutMaridoInput[]
    upsert?: pessoaCasalUpsertWithWhereUniqueWithoutMaridoInput | pessoaCasalUpsertWithWhereUniqueWithoutMaridoInput[]
    createMany?: pessoaCasalCreateManyMaridoInputEnvelope
    set?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    disconnect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    delete?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    connect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    update?: pessoaCasalUpdateWithWhereUniqueWithoutMaridoInput | pessoaCasalUpdateWithWhereUniqueWithoutMaridoInput[]
    updateMany?: pessoaCasalUpdateManyWithWhereWithoutMaridoInput | pessoaCasalUpdateManyWithWhereWithoutMaridoInput[]
    deleteMany?: pessoaCasalScalarWhereInput | pessoaCasalScalarWhereInput[]
  }

  export type pessoaCasalUpdateManyWithoutMulherNestedInput = {
    create?: XOR<pessoaCasalCreateWithoutMulherInput, pessoaCasalUncheckedCreateWithoutMulherInput> | pessoaCasalCreateWithoutMulherInput[] | pessoaCasalUncheckedCreateWithoutMulherInput[]
    connectOrCreate?: pessoaCasalCreateOrConnectWithoutMulherInput | pessoaCasalCreateOrConnectWithoutMulherInput[]
    upsert?: pessoaCasalUpsertWithWhereUniqueWithoutMulherInput | pessoaCasalUpsertWithWhereUniqueWithoutMulherInput[]
    createMany?: pessoaCasalCreateManyMulherInputEnvelope
    set?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    disconnect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    delete?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    connect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    update?: pessoaCasalUpdateWithWhereUniqueWithoutMulherInput | pessoaCasalUpdateWithWhereUniqueWithoutMulherInput[]
    updateMany?: pessoaCasalUpdateManyWithWhereWithoutMulherInput | pessoaCasalUpdateManyWithWhereWithoutMulherInput[]
    deleteMany?: pessoaCasalScalarWhereInput | pessoaCasalScalarWhereInput[]
  }

  export type pessoaEnderecoUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<pessoaEnderecoCreateWithoutPessoaInput, pessoaEnderecoUncheckedCreateWithoutPessoaInput> | pessoaEnderecoCreateWithoutPessoaInput[] | pessoaEnderecoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaEnderecoCreateOrConnectWithoutPessoaInput | pessoaEnderecoCreateOrConnectWithoutPessoaInput[]
    upsert?: pessoaEnderecoUpsertWithWhereUniqueWithoutPessoaInput | pessoaEnderecoUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: pessoaEnderecoCreateManyPessoaInputEnvelope
    set?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    disconnect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    delete?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    connect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    update?: pessoaEnderecoUpdateWithWhereUniqueWithoutPessoaInput | pessoaEnderecoUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: pessoaEnderecoUpdateManyWithWhereWithoutPessoaInput | pessoaEnderecoUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: pessoaEnderecoScalarWhereInput | pessoaEnderecoScalarWhereInput[]
  }

  export type equipePessoasUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<equipePessoasCreateWithoutPessoaInput, equipePessoasUncheckedCreateWithoutPessoaInput> | equipePessoasCreateWithoutPessoaInput[] | equipePessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: equipePessoasCreateOrConnectWithoutPessoaInput | equipePessoasCreateOrConnectWithoutPessoaInput[]
    upsert?: equipePessoasUpsertWithWhereUniqueWithoutPessoaInput | equipePessoasUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: equipePessoasCreateManyPessoaInputEnvelope
    set?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    disconnect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    delete?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    connect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    update?: equipePessoasUpdateWithWhereUniqueWithoutPessoaInput | equipePessoasUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: equipePessoasUpdateManyWithWhereWithoutPessoaInput | equipePessoasUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: equipePessoasScalarWhereInput | equipePessoasScalarWhereInput[]
  }

  export type pessoaCarismaUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<pessoaCarismaCreateWithoutPessoaInput, pessoaCarismaUncheckedCreateWithoutPessoaInput> | pessoaCarismaCreateWithoutPessoaInput[] | pessoaCarismaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaCarismaCreateOrConnectWithoutPessoaInput | pessoaCarismaCreateOrConnectWithoutPessoaInput[]
    upsert?: pessoaCarismaUpsertWithWhereUniqueWithoutPessoaInput | pessoaCarismaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: pessoaCarismaCreateManyPessoaInputEnvelope
    set?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    disconnect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    delete?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    connect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    update?: pessoaCarismaUpdateWithWhereUniqueWithoutPessoaInput | pessoaCarismaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: pessoaCarismaUpdateManyWithWhereWithoutPessoaInput | pessoaCarismaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: pessoaCarismaScalarWhereInput | pessoaCarismaScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<passaportePessoaCreateWithoutPessoaInput, passaportePessoaUncheckedCreateWithoutPessoaInput> | passaportePessoaCreateWithoutPessoaInput[] | passaportePessoaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: passaportePessoaCreateOrConnectWithoutPessoaInput | passaportePessoaCreateOrConnectWithoutPessoaInput[]
    upsert?: passaportePessoaUpsertWithWhereUniqueWithoutPessoaInput | passaportePessoaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: passaportePessoaCreateManyPessoaInputEnvelope
    set?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
    disconnect?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
    delete?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
    connect?: passaportePessoaWhereUniqueInput | passaportePessoaWhereUniqueInput[]
    update?: passaportePessoaUpdateWithWhereUniqueWithoutPessoaInput | passaportePessoaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: passaportePessoaUpdateManyWithWhereWithoutPessoaInput | passaportePessoaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: passaportePessoaScalarWhereInput | passaportePessoaScalarWhereInput[]
  }

  export type pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<pessoaContatoCreateWithoutPessoaInput, pessoaContatoUncheckedCreateWithoutPessoaInput> | pessoaContatoCreateWithoutPessoaInput[] | pessoaContatoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaContatoCreateOrConnectWithoutPessoaInput | pessoaContatoCreateOrConnectWithoutPessoaInput[]
    upsert?: pessoaContatoUpsertWithWhereUniqueWithoutPessoaInput | pessoaContatoUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: pessoaContatoCreateManyPessoaInputEnvelope
    set?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
    disconnect?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
    delete?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
    connect?: pessoaContatoWhereUniqueInput | pessoaContatoWhereUniqueInput[]
    update?: pessoaContatoUpdateWithWhereUniqueWithoutPessoaInput | pessoaContatoUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: pessoaContatoUpdateManyWithWhereWithoutPessoaInput | pessoaContatoUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: pessoaContatoScalarWhereInput | pessoaContatoScalarWhereInput[]
  }

  export type paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<paroquiaPessoasCreateWithoutPessoaInput, paroquiaPessoasUncheckedCreateWithoutPessoaInput> | paroquiaPessoasCreateWithoutPessoaInput[] | paroquiaPessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: paroquiaPessoasCreateOrConnectWithoutPessoaInput | paroquiaPessoasCreateOrConnectWithoutPessoaInput[]
    upsert?: paroquiaPessoasUpsertWithWhereUniqueWithoutPessoaInput | paroquiaPessoasUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: paroquiaPessoasCreateManyPessoaInputEnvelope
    set?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    disconnect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    delete?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    connect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    update?: paroquiaPessoasUpdateWithWhereUniqueWithoutPessoaInput | paroquiaPessoasUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: paroquiaPessoasUpdateManyWithWhereWithoutPessoaInput | paroquiaPessoasUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: paroquiaPessoasScalarWhereInput | paroquiaPessoasScalarWhereInput[]
  }

  export type pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput = {
    create?: XOR<pessoaCasalCreateWithoutMaridoInput, pessoaCasalUncheckedCreateWithoutMaridoInput> | pessoaCasalCreateWithoutMaridoInput[] | pessoaCasalUncheckedCreateWithoutMaridoInput[]
    connectOrCreate?: pessoaCasalCreateOrConnectWithoutMaridoInput | pessoaCasalCreateOrConnectWithoutMaridoInput[]
    upsert?: pessoaCasalUpsertWithWhereUniqueWithoutMaridoInput | pessoaCasalUpsertWithWhereUniqueWithoutMaridoInput[]
    createMany?: pessoaCasalCreateManyMaridoInputEnvelope
    set?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    disconnect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    delete?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    connect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    update?: pessoaCasalUpdateWithWhereUniqueWithoutMaridoInput | pessoaCasalUpdateWithWhereUniqueWithoutMaridoInput[]
    updateMany?: pessoaCasalUpdateManyWithWhereWithoutMaridoInput | pessoaCasalUpdateManyWithWhereWithoutMaridoInput[]
    deleteMany?: pessoaCasalScalarWhereInput | pessoaCasalScalarWhereInput[]
  }

  export type pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput = {
    create?: XOR<pessoaCasalCreateWithoutMulherInput, pessoaCasalUncheckedCreateWithoutMulherInput> | pessoaCasalCreateWithoutMulherInput[] | pessoaCasalUncheckedCreateWithoutMulherInput[]
    connectOrCreate?: pessoaCasalCreateOrConnectWithoutMulherInput | pessoaCasalCreateOrConnectWithoutMulherInput[]
    upsert?: pessoaCasalUpsertWithWhereUniqueWithoutMulherInput | pessoaCasalUpsertWithWhereUniqueWithoutMulherInput[]
    createMany?: pessoaCasalCreateManyMulherInputEnvelope
    set?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    disconnect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    delete?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    connect?: pessoaCasalWhereUniqueInput | pessoaCasalWhereUniqueInput[]
    update?: pessoaCasalUpdateWithWhereUniqueWithoutMulherInput | pessoaCasalUpdateWithWhereUniqueWithoutMulherInput[]
    updateMany?: pessoaCasalUpdateManyWithWhereWithoutMulherInput | pessoaCasalUpdateManyWithWhereWithoutMulherInput[]
    deleteMany?: pessoaCasalScalarWhereInput | pessoaCasalScalarWhereInput[]
  }

  export type pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<pessoaEnderecoCreateWithoutPessoaInput, pessoaEnderecoUncheckedCreateWithoutPessoaInput> | pessoaEnderecoCreateWithoutPessoaInput[] | pessoaEnderecoUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaEnderecoCreateOrConnectWithoutPessoaInput | pessoaEnderecoCreateOrConnectWithoutPessoaInput[]
    upsert?: pessoaEnderecoUpsertWithWhereUniqueWithoutPessoaInput | pessoaEnderecoUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: pessoaEnderecoCreateManyPessoaInputEnvelope
    set?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    disconnect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    delete?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    connect?: pessoaEnderecoWhereUniqueInput | pessoaEnderecoWhereUniqueInput[]
    update?: pessoaEnderecoUpdateWithWhereUniqueWithoutPessoaInput | pessoaEnderecoUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: pessoaEnderecoUpdateManyWithWhereWithoutPessoaInput | pessoaEnderecoUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: pessoaEnderecoScalarWhereInput | pessoaEnderecoScalarWhereInput[]
  }

  export type equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<equipePessoasCreateWithoutPessoaInput, equipePessoasUncheckedCreateWithoutPessoaInput> | equipePessoasCreateWithoutPessoaInput[] | equipePessoasUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: equipePessoasCreateOrConnectWithoutPessoaInput | equipePessoasCreateOrConnectWithoutPessoaInput[]
    upsert?: equipePessoasUpsertWithWhereUniqueWithoutPessoaInput | equipePessoasUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: equipePessoasCreateManyPessoaInputEnvelope
    set?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    disconnect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    delete?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    connect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    update?: equipePessoasUpdateWithWhereUniqueWithoutPessoaInput | equipePessoasUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: equipePessoasUpdateManyWithWhereWithoutPessoaInput | equipePessoasUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: equipePessoasScalarWhereInput | equipePessoasScalarWhereInput[]
  }

  export type pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput = {
    create?: XOR<pessoaCarismaCreateWithoutPessoaInput, pessoaCarismaUncheckedCreateWithoutPessoaInput> | pessoaCarismaCreateWithoutPessoaInput[] | pessoaCarismaUncheckedCreateWithoutPessoaInput[]
    connectOrCreate?: pessoaCarismaCreateOrConnectWithoutPessoaInput | pessoaCarismaCreateOrConnectWithoutPessoaInput[]
    upsert?: pessoaCarismaUpsertWithWhereUniqueWithoutPessoaInput | pessoaCarismaUpsertWithWhereUniqueWithoutPessoaInput[]
    createMany?: pessoaCarismaCreateManyPessoaInputEnvelope
    set?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    disconnect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    delete?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    connect?: pessoaCarismaWhereUniqueInput | pessoaCarismaWhereUniqueInput[]
    update?: pessoaCarismaUpdateWithWhereUniqueWithoutPessoaInput | pessoaCarismaUpdateWithWhereUniqueWithoutPessoaInput[]
    updateMany?: pessoaCarismaUpdateManyWithWhereWithoutPessoaInput | pessoaCarismaUpdateManyWithWhereWithoutPessoaInput[]
    deleteMany?: pessoaCarismaScalarWhereInput | pessoaCarismaScalarWhereInput[]
  }

  export type pessoaCreateNestedManyWithoutTipoPessoaInput = {
    create?: XOR<pessoaCreateWithoutTipoPessoaInput, pessoaUncheckedCreateWithoutTipoPessoaInput> | pessoaCreateWithoutTipoPessoaInput[] | pessoaUncheckedCreateWithoutTipoPessoaInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutTipoPessoaInput | pessoaCreateOrConnectWithoutTipoPessoaInput[]
    createMany?: pessoaCreateManyTipoPessoaInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUncheckedCreateNestedManyWithoutTipoPessoaInput = {
    create?: XOR<pessoaCreateWithoutTipoPessoaInput, pessoaUncheckedCreateWithoutTipoPessoaInput> | pessoaCreateWithoutTipoPessoaInput[] | pessoaUncheckedCreateWithoutTipoPessoaInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutTipoPessoaInput | pessoaCreateOrConnectWithoutTipoPessoaInput[]
    createMany?: pessoaCreateManyTipoPessoaInputEnvelope
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
  }

  export type pessoaUpdateManyWithoutTipoPessoaNestedInput = {
    create?: XOR<pessoaCreateWithoutTipoPessoaInput, pessoaUncheckedCreateWithoutTipoPessoaInput> | pessoaCreateWithoutTipoPessoaInput[] | pessoaUncheckedCreateWithoutTipoPessoaInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutTipoPessoaInput | pessoaCreateOrConnectWithoutTipoPessoaInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutTipoPessoaInput | pessoaUpsertWithWhereUniqueWithoutTipoPessoaInput[]
    createMany?: pessoaCreateManyTipoPessoaInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutTipoPessoaInput | pessoaUpdateWithWhereUniqueWithoutTipoPessoaInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutTipoPessoaInput | pessoaUpdateManyWithWhereWithoutTipoPessoaInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type pessoaUncheckedUpdateManyWithoutTipoPessoaNestedInput = {
    create?: XOR<pessoaCreateWithoutTipoPessoaInput, pessoaUncheckedCreateWithoutTipoPessoaInput> | pessoaCreateWithoutTipoPessoaInput[] | pessoaUncheckedCreateWithoutTipoPessoaInput[]
    connectOrCreate?: pessoaCreateOrConnectWithoutTipoPessoaInput | pessoaCreateOrConnectWithoutTipoPessoaInput[]
    upsert?: pessoaUpsertWithWhereUniqueWithoutTipoPessoaInput | pessoaUpsertWithWhereUniqueWithoutTipoPessoaInput[]
    createMany?: pessoaCreateManyTipoPessoaInputEnvelope
    set?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    disconnect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    delete?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    connect?: pessoaWhereUniqueInput | pessoaWhereUniqueInput[]
    update?: pessoaUpdateWithWhereUniqueWithoutTipoPessoaInput | pessoaUpdateWithWhereUniqueWithoutTipoPessoaInput[]
    updateMany?: pessoaUpdateManyWithWhereWithoutTipoPessoaInput | pessoaUpdateManyWithWhereWithoutTipoPessoaInput[]
    deleteMany?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
  }

  export type pessoaCreateNestedOneWithoutEnderecosInput = {
    create?: XOR<pessoaCreateWithoutEnderecosInput, pessoaUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutEnderecosInput
    connect?: pessoaWhereUniqueInput
  }

  export type enderecoCreateNestedOneWithoutPessoasInput = {
    create?: XOR<enderecoCreateWithoutPessoasInput, enderecoUncheckedCreateWithoutPessoasInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutPessoasInput
    connect?: enderecoWhereUniqueInput
  }

  export type pessoaUpdateOneRequiredWithoutEnderecosNestedInput = {
    create?: XOR<pessoaCreateWithoutEnderecosInput, pessoaUncheckedCreateWithoutEnderecosInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutEnderecosInput
    upsert?: pessoaUpsertWithoutEnderecosInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutEnderecosInput, pessoaUpdateWithoutEnderecosInput>, pessoaUncheckedUpdateWithoutEnderecosInput>
  }

  export type enderecoUpdateOneRequiredWithoutPessoasNestedInput = {
    create?: XOR<enderecoCreateWithoutPessoasInput, enderecoUncheckedCreateWithoutPessoasInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutPessoasInput
    upsert?: enderecoUpsertWithoutPessoasInput
    connect?: enderecoWhereUniqueInput
    update?: XOR<XOR<enderecoUpdateToOneWithWhereWithoutPessoasInput, enderecoUpdateWithoutPessoasInput>, enderecoUncheckedUpdateWithoutPessoasInput>
  }

  export type pessoaCreateNestedOneWithoutCasamentosComoMaridoInput = {
    create?: XOR<pessoaCreateWithoutCasamentosComoMaridoInput, pessoaUncheckedCreateWithoutCasamentosComoMaridoInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutCasamentosComoMaridoInput
    connect?: pessoaWhereUniqueInput
  }

  export type pessoaCreateNestedOneWithoutCasamentosComoMulherInput = {
    create?: XOR<pessoaCreateWithoutCasamentosComoMulherInput, pessoaUncheckedCreateWithoutCasamentosComoMulherInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutCasamentosComoMulherInput
    connect?: pessoaWhereUniqueInput
  }

  export type pessoaUpdateOneRequiredWithoutCasamentosComoMaridoNestedInput = {
    create?: XOR<pessoaCreateWithoutCasamentosComoMaridoInput, pessoaUncheckedCreateWithoutCasamentosComoMaridoInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutCasamentosComoMaridoInput
    upsert?: pessoaUpsertWithoutCasamentosComoMaridoInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutCasamentosComoMaridoInput, pessoaUpdateWithoutCasamentosComoMaridoInput>, pessoaUncheckedUpdateWithoutCasamentosComoMaridoInput>
  }

  export type pessoaUpdateOneRequiredWithoutCasamentosComoMulherNestedInput = {
    create?: XOR<pessoaCreateWithoutCasamentosComoMulherInput, pessoaUncheckedCreateWithoutCasamentosComoMulherInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutCasamentosComoMulherInput
    upsert?: pessoaUpsertWithoutCasamentosComoMulherInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutCasamentosComoMulherInput, pessoaUpdateWithoutCasamentosComoMulherInput>, pessoaUncheckedUpdateWithoutCasamentosComoMulherInput>
  }

  export type pessoaCreateNestedOneWithoutPessoaCarismaInput = {
    create?: XOR<pessoaCreateWithoutPessoaCarismaInput, pessoaUncheckedCreateWithoutPessoaCarismaInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutPessoaCarismaInput
    connect?: pessoaWhereUniqueInput
  }

  export type tipoCarismaCreateNestedOneWithoutPessoaCarismaInput = {
    create?: XOR<tipoCarismaCreateWithoutPessoaCarismaInput, tipoCarismaUncheckedCreateWithoutPessoaCarismaInput>
    connectOrCreate?: tipoCarismaCreateOrConnectWithoutPessoaCarismaInput
    connect?: tipoCarismaWhereUniqueInput
  }

  export type pessoaUpdateOneRequiredWithoutPessoaCarismaNestedInput = {
    create?: XOR<pessoaCreateWithoutPessoaCarismaInput, pessoaUncheckedCreateWithoutPessoaCarismaInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutPessoaCarismaInput
    upsert?: pessoaUpsertWithoutPessoaCarismaInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutPessoaCarismaInput, pessoaUpdateWithoutPessoaCarismaInput>, pessoaUncheckedUpdateWithoutPessoaCarismaInput>
  }

  export type tipoCarismaUpdateOneRequiredWithoutPessoaCarismaNestedInput = {
    create?: XOR<tipoCarismaCreateWithoutPessoaCarismaInput, tipoCarismaUncheckedCreateWithoutPessoaCarismaInput>
    connectOrCreate?: tipoCarismaCreateOrConnectWithoutPessoaCarismaInput
    upsert?: tipoCarismaUpsertWithoutPessoaCarismaInput
    connect?: tipoCarismaWhereUniqueInput
    update?: XOR<XOR<tipoCarismaUpdateToOneWithWhereWithoutPessoaCarismaInput, tipoCarismaUpdateWithoutPessoaCarismaInput>, tipoCarismaUncheckedUpdateWithoutPessoaCarismaInput>
  }

  export type pessoaCreateNestedOneWithoutPassaportesInput = {
    create?: XOR<pessoaCreateWithoutPassaportesInput, pessoaUncheckedCreateWithoutPassaportesInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutPassaportesInput
    connect?: pessoaWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type pessoaUpdateOneRequiredWithoutPassaportesNestedInput = {
    create?: XOR<pessoaCreateWithoutPassaportesInput, pessoaUncheckedCreateWithoutPassaportesInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutPassaportesInput
    upsert?: pessoaUpsertWithoutPassaportesInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutPassaportesInput, pessoaUpdateWithoutPassaportesInput>, pessoaUncheckedUpdateWithoutPassaportesInput>
  }

  export type pessoaCreateNestedOneWithoutContatosInput = {
    create?: XOR<pessoaCreateWithoutContatosInput, pessoaUncheckedCreateWithoutContatosInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutContatosInput
    connect?: pessoaWhereUniqueInput
  }

  export type pessoaUpdateOneRequiredWithoutContatosNestedInput = {
    create?: XOR<pessoaCreateWithoutContatosInput, pessoaUncheckedCreateWithoutContatosInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutContatosInput
    upsert?: pessoaUpsertWithoutContatosInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutContatosInput, pessoaUpdateWithoutContatosInput>, pessoaUncheckedUpdateWithoutContatosInput>
  }

  export type dioceseCreateNestedManyWithoutTipoDioceseInput = {
    create?: XOR<dioceseCreateWithoutTipoDioceseInput, dioceseUncheckedCreateWithoutTipoDioceseInput> | dioceseCreateWithoutTipoDioceseInput[] | dioceseUncheckedCreateWithoutTipoDioceseInput[]
    connectOrCreate?: dioceseCreateOrConnectWithoutTipoDioceseInput | dioceseCreateOrConnectWithoutTipoDioceseInput[]
    createMany?: dioceseCreateManyTipoDioceseInputEnvelope
    connect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
  }

  export type dioceseUncheckedCreateNestedManyWithoutTipoDioceseInput = {
    create?: XOR<dioceseCreateWithoutTipoDioceseInput, dioceseUncheckedCreateWithoutTipoDioceseInput> | dioceseCreateWithoutTipoDioceseInput[] | dioceseUncheckedCreateWithoutTipoDioceseInput[]
    connectOrCreate?: dioceseCreateOrConnectWithoutTipoDioceseInput | dioceseCreateOrConnectWithoutTipoDioceseInput[]
    createMany?: dioceseCreateManyTipoDioceseInputEnvelope
    connect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
  }

  export type dioceseUpdateManyWithoutTipoDioceseNestedInput = {
    create?: XOR<dioceseCreateWithoutTipoDioceseInput, dioceseUncheckedCreateWithoutTipoDioceseInput> | dioceseCreateWithoutTipoDioceseInput[] | dioceseUncheckedCreateWithoutTipoDioceseInput[]
    connectOrCreate?: dioceseCreateOrConnectWithoutTipoDioceseInput | dioceseCreateOrConnectWithoutTipoDioceseInput[]
    upsert?: dioceseUpsertWithWhereUniqueWithoutTipoDioceseInput | dioceseUpsertWithWhereUniqueWithoutTipoDioceseInput[]
    createMany?: dioceseCreateManyTipoDioceseInputEnvelope
    set?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    disconnect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    delete?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    connect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    update?: dioceseUpdateWithWhereUniqueWithoutTipoDioceseInput | dioceseUpdateWithWhereUniqueWithoutTipoDioceseInput[]
    updateMany?: dioceseUpdateManyWithWhereWithoutTipoDioceseInput | dioceseUpdateManyWithWhereWithoutTipoDioceseInput[]
    deleteMany?: dioceseScalarWhereInput | dioceseScalarWhereInput[]
  }

  export type dioceseUncheckedUpdateManyWithoutTipoDioceseNestedInput = {
    create?: XOR<dioceseCreateWithoutTipoDioceseInput, dioceseUncheckedCreateWithoutTipoDioceseInput> | dioceseCreateWithoutTipoDioceseInput[] | dioceseUncheckedCreateWithoutTipoDioceseInput[]
    connectOrCreate?: dioceseCreateOrConnectWithoutTipoDioceseInput | dioceseCreateOrConnectWithoutTipoDioceseInput[]
    upsert?: dioceseUpsertWithWhereUniqueWithoutTipoDioceseInput | dioceseUpsertWithWhereUniqueWithoutTipoDioceseInput[]
    createMany?: dioceseCreateManyTipoDioceseInputEnvelope
    set?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    disconnect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    delete?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    connect?: dioceseWhereUniqueInput | dioceseWhereUniqueInput[]
    update?: dioceseUpdateWithWhereUniqueWithoutTipoDioceseInput | dioceseUpdateWithWhereUniqueWithoutTipoDioceseInput[]
    updateMany?: dioceseUpdateManyWithWhereWithoutTipoDioceseInput | dioceseUpdateManyWithWhereWithoutTipoDioceseInput[]
    deleteMany?: dioceseScalarWhereInput | dioceseScalarWhereInput[]
  }

  export type tipoDioceseCreateNestedOneWithoutDiocesesInput = {
    create?: XOR<tipoDioceseCreateWithoutDiocesesInput, tipoDioceseUncheckedCreateWithoutDiocesesInput>
    connectOrCreate?: tipoDioceseCreateOrConnectWithoutDiocesesInput
    connect?: tipoDioceseWhereUniqueInput
  }

  export type enderecoCreateNestedOneWithoutDioceseInput = {
    create?: XOR<enderecoCreateWithoutDioceseInput, enderecoUncheckedCreateWithoutDioceseInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutDioceseInput
    connect?: enderecoWhereUniqueInput
  }

  export type paroquiaCreateNestedManyWithoutDioceseInput = {
    create?: XOR<paroquiaCreateWithoutDioceseInput, paroquiaUncheckedCreateWithoutDioceseInput> | paroquiaCreateWithoutDioceseInput[] | paroquiaUncheckedCreateWithoutDioceseInput[]
    connectOrCreate?: paroquiaCreateOrConnectWithoutDioceseInput | paroquiaCreateOrConnectWithoutDioceseInput[]
    createMany?: paroquiaCreateManyDioceseInputEnvelope
    connect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
  }

  export type localidadeCreateNestedManyWithoutDioceseInput = {
    create?: XOR<localidadeCreateWithoutDioceseInput, localidadeUncheckedCreateWithoutDioceseInput> | localidadeCreateWithoutDioceseInput[] | localidadeUncheckedCreateWithoutDioceseInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutDioceseInput | localidadeCreateOrConnectWithoutDioceseInput[]
    createMany?: localidadeCreateManyDioceseInputEnvelope
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
  }

  export type paroquiaUncheckedCreateNestedManyWithoutDioceseInput = {
    create?: XOR<paroquiaCreateWithoutDioceseInput, paroquiaUncheckedCreateWithoutDioceseInput> | paroquiaCreateWithoutDioceseInput[] | paroquiaUncheckedCreateWithoutDioceseInput[]
    connectOrCreate?: paroquiaCreateOrConnectWithoutDioceseInput | paroquiaCreateOrConnectWithoutDioceseInput[]
    createMany?: paroquiaCreateManyDioceseInputEnvelope
    connect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
  }

  export type localidadeUncheckedCreateNestedManyWithoutDioceseInput = {
    create?: XOR<localidadeCreateWithoutDioceseInput, localidadeUncheckedCreateWithoutDioceseInput> | localidadeCreateWithoutDioceseInput[] | localidadeUncheckedCreateWithoutDioceseInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutDioceseInput | localidadeCreateOrConnectWithoutDioceseInput[]
    createMany?: localidadeCreateManyDioceseInputEnvelope
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
  }

  export type tipoDioceseUpdateOneRequiredWithoutDiocesesNestedInput = {
    create?: XOR<tipoDioceseCreateWithoutDiocesesInput, tipoDioceseUncheckedCreateWithoutDiocesesInput>
    connectOrCreate?: tipoDioceseCreateOrConnectWithoutDiocesesInput
    upsert?: tipoDioceseUpsertWithoutDiocesesInput
    connect?: tipoDioceseWhereUniqueInput
    update?: XOR<XOR<tipoDioceseUpdateToOneWithWhereWithoutDiocesesInput, tipoDioceseUpdateWithoutDiocesesInput>, tipoDioceseUncheckedUpdateWithoutDiocesesInput>
  }

  export type enderecoUpdateOneRequiredWithoutDioceseNestedInput = {
    create?: XOR<enderecoCreateWithoutDioceseInput, enderecoUncheckedCreateWithoutDioceseInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutDioceseInput
    upsert?: enderecoUpsertWithoutDioceseInput
    connect?: enderecoWhereUniqueInput
    update?: XOR<XOR<enderecoUpdateToOneWithWhereWithoutDioceseInput, enderecoUpdateWithoutDioceseInput>, enderecoUncheckedUpdateWithoutDioceseInput>
  }

  export type paroquiaUpdateManyWithoutDioceseNestedInput = {
    create?: XOR<paroquiaCreateWithoutDioceseInput, paroquiaUncheckedCreateWithoutDioceseInput> | paroquiaCreateWithoutDioceseInput[] | paroquiaUncheckedCreateWithoutDioceseInput[]
    connectOrCreate?: paroquiaCreateOrConnectWithoutDioceseInput | paroquiaCreateOrConnectWithoutDioceseInput[]
    upsert?: paroquiaUpsertWithWhereUniqueWithoutDioceseInput | paroquiaUpsertWithWhereUniqueWithoutDioceseInput[]
    createMany?: paroquiaCreateManyDioceseInputEnvelope
    set?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    disconnect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    delete?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    connect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    update?: paroquiaUpdateWithWhereUniqueWithoutDioceseInput | paroquiaUpdateWithWhereUniqueWithoutDioceseInput[]
    updateMany?: paroquiaUpdateManyWithWhereWithoutDioceseInput | paroquiaUpdateManyWithWhereWithoutDioceseInput[]
    deleteMany?: paroquiaScalarWhereInput | paroquiaScalarWhereInput[]
  }

  export type localidadeUpdateManyWithoutDioceseNestedInput = {
    create?: XOR<localidadeCreateWithoutDioceseInput, localidadeUncheckedCreateWithoutDioceseInput> | localidadeCreateWithoutDioceseInput[] | localidadeUncheckedCreateWithoutDioceseInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutDioceseInput | localidadeCreateOrConnectWithoutDioceseInput[]
    upsert?: localidadeUpsertWithWhereUniqueWithoutDioceseInput | localidadeUpsertWithWhereUniqueWithoutDioceseInput[]
    createMany?: localidadeCreateManyDioceseInputEnvelope
    set?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    disconnect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    delete?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    update?: localidadeUpdateWithWhereUniqueWithoutDioceseInput | localidadeUpdateWithWhereUniqueWithoutDioceseInput[]
    updateMany?: localidadeUpdateManyWithWhereWithoutDioceseInput | localidadeUpdateManyWithWhereWithoutDioceseInput[]
    deleteMany?: localidadeScalarWhereInput | localidadeScalarWhereInput[]
  }

  export type paroquiaUncheckedUpdateManyWithoutDioceseNestedInput = {
    create?: XOR<paroquiaCreateWithoutDioceseInput, paroquiaUncheckedCreateWithoutDioceseInput> | paroquiaCreateWithoutDioceseInput[] | paroquiaUncheckedCreateWithoutDioceseInput[]
    connectOrCreate?: paroquiaCreateOrConnectWithoutDioceseInput | paroquiaCreateOrConnectWithoutDioceseInput[]
    upsert?: paroquiaUpsertWithWhereUniqueWithoutDioceseInput | paroquiaUpsertWithWhereUniqueWithoutDioceseInput[]
    createMany?: paroquiaCreateManyDioceseInputEnvelope
    set?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    disconnect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    delete?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    connect?: paroquiaWhereUniqueInput | paroquiaWhereUniqueInput[]
    update?: paroquiaUpdateWithWhereUniqueWithoutDioceseInput | paroquiaUpdateWithWhereUniqueWithoutDioceseInput[]
    updateMany?: paroquiaUpdateManyWithWhereWithoutDioceseInput | paroquiaUpdateManyWithWhereWithoutDioceseInput[]
    deleteMany?: paroquiaScalarWhereInput | paroquiaScalarWhereInput[]
  }

  export type localidadeUncheckedUpdateManyWithoutDioceseNestedInput = {
    create?: XOR<localidadeCreateWithoutDioceseInput, localidadeUncheckedCreateWithoutDioceseInput> | localidadeCreateWithoutDioceseInput[] | localidadeUncheckedCreateWithoutDioceseInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutDioceseInput | localidadeCreateOrConnectWithoutDioceseInput[]
    upsert?: localidadeUpsertWithWhereUniqueWithoutDioceseInput | localidadeUpsertWithWhereUniqueWithoutDioceseInput[]
    createMany?: localidadeCreateManyDioceseInputEnvelope
    set?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    disconnect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    delete?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    update?: localidadeUpdateWithWhereUniqueWithoutDioceseInput | localidadeUpdateWithWhereUniqueWithoutDioceseInput[]
    updateMany?: localidadeUpdateManyWithWhereWithoutDioceseInput | localidadeUpdateManyWithWhereWithoutDioceseInput[]
    deleteMany?: localidadeScalarWhereInput | localidadeScalarWhereInput[]
  }

  export type enderecoCreateNestedOneWithoutParoquiasInput = {
    create?: XOR<enderecoCreateWithoutParoquiasInput, enderecoUncheckedCreateWithoutParoquiasInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutParoquiasInput
    connect?: enderecoWhereUniqueInput
  }

  export type dioceseCreateNestedOneWithoutParoquiasInput = {
    create?: XOR<dioceseCreateWithoutParoquiasInput, dioceseUncheckedCreateWithoutParoquiasInput>
    connectOrCreate?: dioceseCreateOrConnectWithoutParoquiasInput
    connect?: dioceseWhereUniqueInput
  }

  export type paroquiaPessoasCreateNestedManyWithoutParoquiaInput = {
    create?: XOR<paroquiaPessoasCreateWithoutParoquiaInput, paroquiaPessoasUncheckedCreateWithoutParoquiaInput> | paroquiaPessoasCreateWithoutParoquiaInput[] | paroquiaPessoasUncheckedCreateWithoutParoquiaInput[]
    connectOrCreate?: paroquiaPessoasCreateOrConnectWithoutParoquiaInput | paroquiaPessoasCreateOrConnectWithoutParoquiaInput[]
    createMany?: paroquiaPessoasCreateManyParoquiaInputEnvelope
    connect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
  }

  export type paroquiaPessoasUncheckedCreateNestedManyWithoutParoquiaInput = {
    create?: XOR<paroquiaPessoasCreateWithoutParoquiaInput, paroquiaPessoasUncheckedCreateWithoutParoquiaInput> | paroquiaPessoasCreateWithoutParoquiaInput[] | paroquiaPessoasUncheckedCreateWithoutParoquiaInput[]
    connectOrCreate?: paroquiaPessoasCreateOrConnectWithoutParoquiaInput | paroquiaPessoasCreateOrConnectWithoutParoquiaInput[]
    createMany?: paroquiaPessoasCreateManyParoquiaInputEnvelope
    connect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
  }

  export type enderecoUpdateOneRequiredWithoutParoquiasNestedInput = {
    create?: XOR<enderecoCreateWithoutParoquiasInput, enderecoUncheckedCreateWithoutParoquiasInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutParoquiasInput
    upsert?: enderecoUpsertWithoutParoquiasInput
    connect?: enderecoWhereUniqueInput
    update?: XOR<XOR<enderecoUpdateToOneWithWhereWithoutParoquiasInput, enderecoUpdateWithoutParoquiasInput>, enderecoUncheckedUpdateWithoutParoquiasInput>
  }

  export type dioceseUpdateOneRequiredWithoutParoquiasNestedInput = {
    create?: XOR<dioceseCreateWithoutParoquiasInput, dioceseUncheckedCreateWithoutParoquiasInput>
    connectOrCreate?: dioceseCreateOrConnectWithoutParoquiasInput
    upsert?: dioceseUpsertWithoutParoquiasInput
    connect?: dioceseWhereUniqueInput
    update?: XOR<XOR<dioceseUpdateToOneWithWhereWithoutParoquiasInput, dioceseUpdateWithoutParoquiasInput>, dioceseUncheckedUpdateWithoutParoquiasInput>
  }

  export type paroquiaPessoasUpdateManyWithoutParoquiaNestedInput = {
    create?: XOR<paroquiaPessoasCreateWithoutParoquiaInput, paroquiaPessoasUncheckedCreateWithoutParoquiaInput> | paroquiaPessoasCreateWithoutParoquiaInput[] | paroquiaPessoasUncheckedCreateWithoutParoquiaInput[]
    connectOrCreate?: paroquiaPessoasCreateOrConnectWithoutParoquiaInput | paroquiaPessoasCreateOrConnectWithoutParoquiaInput[]
    upsert?: paroquiaPessoasUpsertWithWhereUniqueWithoutParoquiaInput | paroquiaPessoasUpsertWithWhereUniqueWithoutParoquiaInput[]
    createMany?: paroquiaPessoasCreateManyParoquiaInputEnvelope
    set?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    disconnect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    delete?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    connect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    update?: paroquiaPessoasUpdateWithWhereUniqueWithoutParoquiaInput | paroquiaPessoasUpdateWithWhereUniqueWithoutParoquiaInput[]
    updateMany?: paroquiaPessoasUpdateManyWithWhereWithoutParoquiaInput | paroquiaPessoasUpdateManyWithWhereWithoutParoquiaInput[]
    deleteMany?: paroquiaPessoasScalarWhereInput | paroquiaPessoasScalarWhereInput[]
  }

  export type paroquiaPessoasUncheckedUpdateManyWithoutParoquiaNestedInput = {
    create?: XOR<paroquiaPessoasCreateWithoutParoquiaInput, paroquiaPessoasUncheckedCreateWithoutParoquiaInput> | paroquiaPessoasCreateWithoutParoquiaInput[] | paroquiaPessoasUncheckedCreateWithoutParoquiaInput[]
    connectOrCreate?: paroquiaPessoasCreateOrConnectWithoutParoquiaInput | paroquiaPessoasCreateOrConnectWithoutParoquiaInput[]
    upsert?: paroquiaPessoasUpsertWithWhereUniqueWithoutParoquiaInput | paroquiaPessoasUpsertWithWhereUniqueWithoutParoquiaInput[]
    createMany?: paroquiaPessoasCreateManyParoquiaInputEnvelope
    set?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    disconnect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    delete?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    connect?: paroquiaPessoasWhereUniqueInput | paroquiaPessoasWhereUniqueInput[]
    update?: paroquiaPessoasUpdateWithWhereUniqueWithoutParoquiaInput | paroquiaPessoasUpdateWithWhereUniqueWithoutParoquiaInput[]
    updateMany?: paroquiaPessoasUpdateManyWithWhereWithoutParoquiaInput | paroquiaPessoasUpdateManyWithWhereWithoutParoquiaInput[]
    deleteMany?: paroquiaPessoasScalarWhereInput | paroquiaPessoasScalarWhereInput[]
  }

  export type pessoaCreateNestedOneWithoutParoquiasInput = {
    create?: XOR<pessoaCreateWithoutParoquiasInput, pessoaUncheckedCreateWithoutParoquiasInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutParoquiasInput
    connect?: pessoaWhereUniqueInput
  }

  export type paroquiaCreateNestedOneWithoutPessoasInput = {
    create?: XOR<paroquiaCreateWithoutPessoasInput, paroquiaUncheckedCreateWithoutPessoasInput>
    connectOrCreate?: paroquiaCreateOrConnectWithoutPessoasInput
    connect?: paroquiaWhereUniqueInput
  }

  export type pessoaUpdateOneRequiredWithoutParoquiasNestedInput = {
    create?: XOR<pessoaCreateWithoutParoquiasInput, pessoaUncheckedCreateWithoutParoquiasInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutParoquiasInput
    upsert?: pessoaUpsertWithoutParoquiasInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutParoquiasInput, pessoaUpdateWithoutParoquiasInput>, pessoaUncheckedUpdateWithoutParoquiasInput>
  }

  export type paroquiaUpdateOneRequiredWithoutPessoasNestedInput = {
    create?: XOR<paroquiaCreateWithoutPessoasInput, paroquiaUncheckedCreateWithoutPessoasInput>
    connectOrCreate?: paroquiaCreateOrConnectWithoutPessoasInput
    upsert?: paroquiaUpsertWithoutPessoasInput
    connect?: paroquiaWhereUniqueInput
    update?: XOR<XOR<paroquiaUpdateToOneWithWhereWithoutPessoasInput, paroquiaUpdateWithoutPessoasInput>, paroquiaUncheckedUpdateWithoutPessoasInput>
  }

  export type equipeRegiaoCreateNestedManyWithoutRegiaoInput = {
    create?: XOR<equipeRegiaoCreateWithoutRegiaoInput, equipeRegiaoUncheckedCreateWithoutRegiaoInput> | equipeRegiaoCreateWithoutRegiaoInput[] | equipeRegiaoUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: equipeRegiaoCreateOrConnectWithoutRegiaoInput | equipeRegiaoCreateOrConnectWithoutRegiaoInput[]
    createMany?: equipeRegiaoCreateManyRegiaoInputEnvelope
    connect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
  }

  export type localidadeRegiaoCreateNestedManyWithoutRegiaoInput = {
    create?: XOR<localidadeRegiaoCreateWithoutRegiaoInput, localidadeRegiaoUncheckedCreateWithoutRegiaoInput> | localidadeRegiaoCreateWithoutRegiaoInput[] | localidadeRegiaoUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: localidadeRegiaoCreateOrConnectWithoutRegiaoInput | localidadeRegiaoCreateOrConnectWithoutRegiaoInput[]
    createMany?: localidadeRegiaoCreateManyRegiaoInputEnvelope
    connect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
  }

  export type equipeRegiaoUncheckedCreateNestedManyWithoutRegiaoInput = {
    create?: XOR<equipeRegiaoCreateWithoutRegiaoInput, equipeRegiaoUncheckedCreateWithoutRegiaoInput> | equipeRegiaoCreateWithoutRegiaoInput[] | equipeRegiaoUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: equipeRegiaoCreateOrConnectWithoutRegiaoInput | equipeRegiaoCreateOrConnectWithoutRegiaoInput[]
    createMany?: equipeRegiaoCreateManyRegiaoInputEnvelope
    connect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
  }

  export type localidadeRegiaoUncheckedCreateNestedManyWithoutRegiaoInput = {
    create?: XOR<localidadeRegiaoCreateWithoutRegiaoInput, localidadeRegiaoUncheckedCreateWithoutRegiaoInput> | localidadeRegiaoCreateWithoutRegiaoInput[] | localidadeRegiaoUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: localidadeRegiaoCreateOrConnectWithoutRegiaoInput | localidadeRegiaoCreateOrConnectWithoutRegiaoInput[]
    createMany?: localidadeRegiaoCreateManyRegiaoInputEnvelope
    connect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
  }

  export type equipeRegiaoUpdateManyWithoutRegiaoNestedInput = {
    create?: XOR<equipeRegiaoCreateWithoutRegiaoInput, equipeRegiaoUncheckedCreateWithoutRegiaoInput> | equipeRegiaoCreateWithoutRegiaoInput[] | equipeRegiaoUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: equipeRegiaoCreateOrConnectWithoutRegiaoInput | equipeRegiaoCreateOrConnectWithoutRegiaoInput[]
    upsert?: equipeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput | equipeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput[]
    createMany?: equipeRegiaoCreateManyRegiaoInputEnvelope
    set?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    disconnect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    delete?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    connect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    update?: equipeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput | equipeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput[]
    updateMany?: equipeRegiaoUpdateManyWithWhereWithoutRegiaoInput | equipeRegiaoUpdateManyWithWhereWithoutRegiaoInput[]
    deleteMany?: equipeRegiaoScalarWhereInput | equipeRegiaoScalarWhereInput[]
  }

  export type localidadeRegiaoUpdateManyWithoutRegiaoNestedInput = {
    create?: XOR<localidadeRegiaoCreateWithoutRegiaoInput, localidadeRegiaoUncheckedCreateWithoutRegiaoInput> | localidadeRegiaoCreateWithoutRegiaoInput[] | localidadeRegiaoUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: localidadeRegiaoCreateOrConnectWithoutRegiaoInput | localidadeRegiaoCreateOrConnectWithoutRegiaoInput[]
    upsert?: localidadeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput | localidadeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput[]
    createMany?: localidadeRegiaoCreateManyRegiaoInputEnvelope
    set?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    disconnect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    delete?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    connect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    update?: localidadeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput | localidadeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput[]
    updateMany?: localidadeRegiaoUpdateManyWithWhereWithoutRegiaoInput | localidadeRegiaoUpdateManyWithWhereWithoutRegiaoInput[]
    deleteMany?: localidadeRegiaoScalarWhereInput | localidadeRegiaoScalarWhereInput[]
  }

  export type equipeRegiaoUncheckedUpdateManyWithoutRegiaoNestedInput = {
    create?: XOR<equipeRegiaoCreateWithoutRegiaoInput, equipeRegiaoUncheckedCreateWithoutRegiaoInput> | equipeRegiaoCreateWithoutRegiaoInput[] | equipeRegiaoUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: equipeRegiaoCreateOrConnectWithoutRegiaoInput | equipeRegiaoCreateOrConnectWithoutRegiaoInput[]
    upsert?: equipeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput | equipeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput[]
    createMany?: equipeRegiaoCreateManyRegiaoInputEnvelope
    set?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    disconnect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    delete?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    connect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    update?: equipeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput | equipeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput[]
    updateMany?: equipeRegiaoUpdateManyWithWhereWithoutRegiaoInput | equipeRegiaoUpdateManyWithWhereWithoutRegiaoInput[]
    deleteMany?: equipeRegiaoScalarWhereInput | equipeRegiaoScalarWhereInput[]
  }

  export type localidadeRegiaoUncheckedUpdateManyWithoutRegiaoNestedInput = {
    create?: XOR<localidadeRegiaoCreateWithoutRegiaoInput, localidadeRegiaoUncheckedCreateWithoutRegiaoInput> | localidadeRegiaoCreateWithoutRegiaoInput[] | localidadeRegiaoUncheckedCreateWithoutRegiaoInput[]
    connectOrCreate?: localidadeRegiaoCreateOrConnectWithoutRegiaoInput | localidadeRegiaoCreateOrConnectWithoutRegiaoInput[]
    upsert?: localidadeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput | localidadeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput[]
    createMany?: localidadeRegiaoCreateManyRegiaoInputEnvelope
    set?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    disconnect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    delete?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    connect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    update?: localidadeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput | localidadeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput[]
    updateMany?: localidadeRegiaoUpdateManyWithWhereWithoutRegiaoInput | localidadeRegiaoUpdateManyWithWhereWithoutRegiaoInput[]
    deleteMany?: localidadeRegiaoScalarWhereInput | localidadeRegiaoScalarWhereInput[]
  }

  export type equipeTipoEquipeCreateNestedManyWithoutTipoEquipeInput = {
    create?: XOR<equipeTipoEquipeCreateWithoutTipoEquipeInput, equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput> | equipeTipoEquipeCreateWithoutTipoEquipeInput[] | equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput[]
    connectOrCreate?: equipeTipoEquipeCreateOrConnectWithoutTipoEquipeInput | equipeTipoEquipeCreateOrConnectWithoutTipoEquipeInput[]
    createMany?: equipeTipoEquipeCreateManyTipoEquipeInputEnvelope
    connect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
  }

  export type equipeTipoEquipeUncheckedCreateNestedManyWithoutTipoEquipeInput = {
    create?: XOR<equipeTipoEquipeCreateWithoutTipoEquipeInput, equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput> | equipeTipoEquipeCreateWithoutTipoEquipeInput[] | equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput[]
    connectOrCreate?: equipeTipoEquipeCreateOrConnectWithoutTipoEquipeInput | equipeTipoEquipeCreateOrConnectWithoutTipoEquipeInput[]
    createMany?: equipeTipoEquipeCreateManyTipoEquipeInputEnvelope
    connect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
  }

  export type equipeTipoEquipeUpdateManyWithoutTipoEquipeNestedInput = {
    create?: XOR<equipeTipoEquipeCreateWithoutTipoEquipeInput, equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput> | equipeTipoEquipeCreateWithoutTipoEquipeInput[] | equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput[]
    connectOrCreate?: equipeTipoEquipeCreateOrConnectWithoutTipoEquipeInput | equipeTipoEquipeCreateOrConnectWithoutTipoEquipeInput[]
    upsert?: equipeTipoEquipeUpsertWithWhereUniqueWithoutTipoEquipeInput | equipeTipoEquipeUpsertWithWhereUniqueWithoutTipoEquipeInput[]
    createMany?: equipeTipoEquipeCreateManyTipoEquipeInputEnvelope
    set?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    disconnect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    delete?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    connect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    update?: equipeTipoEquipeUpdateWithWhereUniqueWithoutTipoEquipeInput | equipeTipoEquipeUpdateWithWhereUniqueWithoutTipoEquipeInput[]
    updateMany?: equipeTipoEquipeUpdateManyWithWhereWithoutTipoEquipeInput | equipeTipoEquipeUpdateManyWithWhereWithoutTipoEquipeInput[]
    deleteMany?: equipeTipoEquipeScalarWhereInput | equipeTipoEquipeScalarWhereInput[]
  }

  export type equipeTipoEquipeUncheckedUpdateManyWithoutTipoEquipeNestedInput = {
    create?: XOR<equipeTipoEquipeCreateWithoutTipoEquipeInput, equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput> | equipeTipoEquipeCreateWithoutTipoEquipeInput[] | equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput[]
    connectOrCreate?: equipeTipoEquipeCreateOrConnectWithoutTipoEquipeInput | equipeTipoEquipeCreateOrConnectWithoutTipoEquipeInput[]
    upsert?: equipeTipoEquipeUpsertWithWhereUniqueWithoutTipoEquipeInput | equipeTipoEquipeUpsertWithWhereUniqueWithoutTipoEquipeInput[]
    createMany?: equipeTipoEquipeCreateManyTipoEquipeInputEnvelope
    set?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    disconnect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    delete?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    connect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    update?: equipeTipoEquipeUpdateWithWhereUniqueWithoutTipoEquipeInput | equipeTipoEquipeUpdateWithWhereUniqueWithoutTipoEquipeInput[]
    updateMany?: equipeTipoEquipeUpdateManyWithWhereWithoutTipoEquipeInput | equipeTipoEquipeUpdateManyWithWhereWithoutTipoEquipeInput[]
    deleteMany?: equipeTipoEquipeScalarWhereInput | equipeTipoEquipeScalarWhereInput[]
  }

  export type equipeRegiaoCreateNestedManyWithoutEquipeInput = {
    create?: XOR<equipeRegiaoCreateWithoutEquipeInput, equipeRegiaoUncheckedCreateWithoutEquipeInput> | equipeRegiaoCreateWithoutEquipeInput[] | equipeRegiaoUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipeRegiaoCreateOrConnectWithoutEquipeInput | equipeRegiaoCreateOrConnectWithoutEquipeInput[]
    createMany?: equipeRegiaoCreateManyEquipeInputEnvelope
    connect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
  }

  export type equipePessoasCreateNestedManyWithoutEquipeInput = {
    create?: XOR<equipePessoasCreateWithoutEquipeInput, equipePessoasUncheckedCreateWithoutEquipeInput> | equipePessoasCreateWithoutEquipeInput[] | equipePessoasUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipePessoasCreateOrConnectWithoutEquipeInput | equipePessoasCreateOrConnectWithoutEquipeInput[]
    createMany?: equipePessoasCreateManyEquipeInputEnvelope
    connect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
  }

  export type equipeTipoEquipeCreateNestedManyWithoutEquipeInput = {
    create?: XOR<equipeTipoEquipeCreateWithoutEquipeInput, equipeTipoEquipeUncheckedCreateWithoutEquipeInput> | equipeTipoEquipeCreateWithoutEquipeInput[] | equipeTipoEquipeUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipeTipoEquipeCreateOrConnectWithoutEquipeInput | equipeTipoEquipeCreateOrConnectWithoutEquipeInput[]
    createMany?: equipeTipoEquipeCreateManyEquipeInputEnvelope
    connect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
  }

  export type equipeRegiaoUncheckedCreateNestedManyWithoutEquipeInput = {
    create?: XOR<equipeRegiaoCreateWithoutEquipeInput, equipeRegiaoUncheckedCreateWithoutEquipeInput> | equipeRegiaoCreateWithoutEquipeInput[] | equipeRegiaoUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipeRegiaoCreateOrConnectWithoutEquipeInput | equipeRegiaoCreateOrConnectWithoutEquipeInput[]
    createMany?: equipeRegiaoCreateManyEquipeInputEnvelope
    connect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
  }

  export type equipePessoasUncheckedCreateNestedManyWithoutEquipeInput = {
    create?: XOR<equipePessoasCreateWithoutEquipeInput, equipePessoasUncheckedCreateWithoutEquipeInput> | equipePessoasCreateWithoutEquipeInput[] | equipePessoasUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipePessoasCreateOrConnectWithoutEquipeInput | equipePessoasCreateOrConnectWithoutEquipeInput[]
    createMany?: equipePessoasCreateManyEquipeInputEnvelope
    connect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
  }

  export type equipeTipoEquipeUncheckedCreateNestedManyWithoutEquipeInput = {
    create?: XOR<equipeTipoEquipeCreateWithoutEquipeInput, equipeTipoEquipeUncheckedCreateWithoutEquipeInput> | equipeTipoEquipeCreateWithoutEquipeInput[] | equipeTipoEquipeUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipeTipoEquipeCreateOrConnectWithoutEquipeInput | equipeTipoEquipeCreateOrConnectWithoutEquipeInput[]
    createMany?: equipeTipoEquipeCreateManyEquipeInputEnvelope
    connect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
  }

  export type equipeRegiaoUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<equipeRegiaoCreateWithoutEquipeInput, equipeRegiaoUncheckedCreateWithoutEquipeInput> | equipeRegiaoCreateWithoutEquipeInput[] | equipeRegiaoUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipeRegiaoCreateOrConnectWithoutEquipeInput | equipeRegiaoCreateOrConnectWithoutEquipeInput[]
    upsert?: equipeRegiaoUpsertWithWhereUniqueWithoutEquipeInput | equipeRegiaoUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: equipeRegiaoCreateManyEquipeInputEnvelope
    set?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    disconnect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    delete?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    connect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    update?: equipeRegiaoUpdateWithWhereUniqueWithoutEquipeInput | equipeRegiaoUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: equipeRegiaoUpdateManyWithWhereWithoutEquipeInput | equipeRegiaoUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: equipeRegiaoScalarWhereInput | equipeRegiaoScalarWhereInput[]
  }

  export type equipePessoasUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<equipePessoasCreateWithoutEquipeInput, equipePessoasUncheckedCreateWithoutEquipeInput> | equipePessoasCreateWithoutEquipeInput[] | equipePessoasUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipePessoasCreateOrConnectWithoutEquipeInput | equipePessoasCreateOrConnectWithoutEquipeInput[]
    upsert?: equipePessoasUpsertWithWhereUniqueWithoutEquipeInput | equipePessoasUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: equipePessoasCreateManyEquipeInputEnvelope
    set?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    disconnect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    delete?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    connect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    update?: equipePessoasUpdateWithWhereUniqueWithoutEquipeInput | equipePessoasUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: equipePessoasUpdateManyWithWhereWithoutEquipeInput | equipePessoasUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: equipePessoasScalarWhereInput | equipePessoasScalarWhereInput[]
  }

  export type equipeTipoEquipeUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<equipeTipoEquipeCreateWithoutEquipeInput, equipeTipoEquipeUncheckedCreateWithoutEquipeInput> | equipeTipoEquipeCreateWithoutEquipeInput[] | equipeTipoEquipeUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipeTipoEquipeCreateOrConnectWithoutEquipeInput | equipeTipoEquipeCreateOrConnectWithoutEquipeInput[]
    upsert?: equipeTipoEquipeUpsertWithWhereUniqueWithoutEquipeInput | equipeTipoEquipeUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: equipeTipoEquipeCreateManyEquipeInputEnvelope
    set?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    disconnect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    delete?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    connect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    update?: equipeTipoEquipeUpdateWithWhereUniqueWithoutEquipeInput | equipeTipoEquipeUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: equipeTipoEquipeUpdateManyWithWhereWithoutEquipeInput | equipeTipoEquipeUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: equipeTipoEquipeScalarWhereInput | equipeTipoEquipeScalarWhereInput[]
  }

  export type equipeRegiaoUncheckedUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<equipeRegiaoCreateWithoutEquipeInput, equipeRegiaoUncheckedCreateWithoutEquipeInput> | equipeRegiaoCreateWithoutEquipeInput[] | equipeRegiaoUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipeRegiaoCreateOrConnectWithoutEquipeInput | equipeRegiaoCreateOrConnectWithoutEquipeInput[]
    upsert?: equipeRegiaoUpsertWithWhereUniqueWithoutEquipeInput | equipeRegiaoUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: equipeRegiaoCreateManyEquipeInputEnvelope
    set?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    disconnect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    delete?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    connect?: equipeRegiaoWhereUniqueInput | equipeRegiaoWhereUniqueInput[]
    update?: equipeRegiaoUpdateWithWhereUniqueWithoutEquipeInput | equipeRegiaoUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: equipeRegiaoUpdateManyWithWhereWithoutEquipeInput | equipeRegiaoUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: equipeRegiaoScalarWhereInput | equipeRegiaoScalarWhereInput[]
  }

  export type equipePessoasUncheckedUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<equipePessoasCreateWithoutEquipeInput, equipePessoasUncheckedCreateWithoutEquipeInput> | equipePessoasCreateWithoutEquipeInput[] | equipePessoasUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipePessoasCreateOrConnectWithoutEquipeInput | equipePessoasCreateOrConnectWithoutEquipeInput[]
    upsert?: equipePessoasUpsertWithWhereUniqueWithoutEquipeInput | equipePessoasUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: equipePessoasCreateManyEquipeInputEnvelope
    set?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    disconnect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    delete?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    connect?: equipePessoasWhereUniqueInput | equipePessoasWhereUniqueInput[]
    update?: equipePessoasUpdateWithWhereUniqueWithoutEquipeInput | equipePessoasUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: equipePessoasUpdateManyWithWhereWithoutEquipeInput | equipePessoasUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: equipePessoasScalarWhereInput | equipePessoasScalarWhereInput[]
  }

  export type equipeTipoEquipeUncheckedUpdateManyWithoutEquipeNestedInput = {
    create?: XOR<equipeTipoEquipeCreateWithoutEquipeInput, equipeTipoEquipeUncheckedCreateWithoutEquipeInput> | equipeTipoEquipeCreateWithoutEquipeInput[] | equipeTipoEquipeUncheckedCreateWithoutEquipeInput[]
    connectOrCreate?: equipeTipoEquipeCreateOrConnectWithoutEquipeInput | equipeTipoEquipeCreateOrConnectWithoutEquipeInput[]
    upsert?: equipeTipoEquipeUpsertWithWhereUniqueWithoutEquipeInput | equipeTipoEquipeUpsertWithWhereUniqueWithoutEquipeInput[]
    createMany?: equipeTipoEquipeCreateManyEquipeInputEnvelope
    set?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    disconnect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    delete?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    connect?: equipeTipoEquipeWhereUniqueInput | equipeTipoEquipeWhereUniqueInput[]
    update?: equipeTipoEquipeUpdateWithWhereUniqueWithoutEquipeInput | equipeTipoEquipeUpdateWithWhereUniqueWithoutEquipeInput[]
    updateMany?: equipeTipoEquipeUpdateManyWithWhereWithoutEquipeInput | equipeTipoEquipeUpdateManyWithWhereWithoutEquipeInput[]
    deleteMany?: equipeTipoEquipeScalarWhereInput | equipeTipoEquipeScalarWhereInput[]
  }

  export type equipeCreateNestedOneWithoutTiposInput = {
    create?: XOR<equipeCreateWithoutTiposInput, equipeUncheckedCreateWithoutTiposInput>
    connectOrCreate?: equipeCreateOrConnectWithoutTiposInput
    connect?: equipeWhereUniqueInput
  }

  export type tipoEquipeCreateNestedOneWithoutEquipesInput = {
    create?: XOR<tipoEquipeCreateWithoutEquipesInput, tipoEquipeUncheckedCreateWithoutEquipesInput>
    connectOrCreate?: tipoEquipeCreateOrConnectWithoutEquipesInput
    connect?: tipoEquipeWhereUniqueInput
  }

  export type equipeUpdateOneRequiredWithoutTiposNestedInput = {
    create?: XOR<equipeCreateWithoutTiposInput, equipeUncheckedCreateWithoutTiposInput>
    connectOrCreate?: equipeCreateOrConnectWithoutTiposInput
    upsert?: equipeUpsertWithoutTiposInput
    connect?: equipeWhereUniqueInput
    update?: XOR<XOR<equipeUpdateToOneWithWhereWithoutTiposInput, equipeUpdateWithoutTiposInput>, equipeUncheckedUpdateWithoutTiposInput>
  }

  export type tipoEquipeUpdateOneRequiredWithoutEquipesNestedInput = {
    create?: XOR<tipoEquipeCreateWithoutEquipesInput, tipoEquipeUncheckedCreateWithoutEquipesInput>
    connectOrCreate?: tipoEquipeCreateOrConnectWithoutEquipesInput
    upsert?: tipoEquipeUpsertWithoutEquipesInput
    connect?: tipoEquipeWhereUniqueInput
    update?: XOR<XOR<tipoEquipeUpdateToOneWithWhereWithoutEquipesInput, tipoEquipeUpdateWithoutEquipesInput>, tipoEquipeUncheckedUpdateWithoutEquipesInput>
  }

  export type equipeCreateNestedOneWithoutRegioesInput = {
    create?: XOR<equipeCreateWithoutRegioesInput, equipeUncheckedCreateWithoutRegioesInput>
    connectOrCreate?: equipeCreateOrConnectWithoutRegioesInput
    connect?: equipeWhereUniqueInput
  }

  export type regiaoCreateNestedOneWithoutEquipesInput = {
    create?: XOR<regiaoCreateWithoutEquipesInput, regiaoUncheckedCreateWithoutEquipesInput>
    connectOrCreate?: regiaoCreateOrConnectWithoutEquipesInput
    connect?: regiaoWhereUniqueInput
  }

  export type equipeUpdateOneRequiredWithoutRegioesNestedInput = {
    create?: XOR<equipeCreateWithoutRegioesInput, equipeUncheckedCreateWithoutRegioesInput>
    connectOrCreate?: equipeCreateOrConnectWithoutRegioesInput
    upsert?: equipeUpsertWithoutRegioesInput
    connect?: equipeWhereUniqueInput
    update?: XOR<XOR<equipeUpdateToOneWithWhereWithoutRegioesInput, equipeUpdateWithoutRegioesInput>, equipeUncheckedUpdateWithoutRegioesInput>
  }

  export type regiaoUpdateOneRequiredWithoutEquipesNestedInput = {
    create?: XOR<regiaoCreateWithoutEquipesInput, regiaoUncheckedCreateWithoutEquipesInput>
    connectOrCreate?: regiaoCreateOrConnectWithoutEquipesInput
    upsert?: regiaoUpsertWithoutEquipesInput
    connect?: regiaoWhereUniqueInput
    update?: XOR<XOR<regiaoUpdateToOneWithWhereWithoutEquipesInput, regiaoUpdateWithoutEquipesInput>, regiaoUncheckedUpdateWithoutEquipesInput>
  }

  export type equipeCreateNestedOneWithoutEquipePessoasInput = {
    create?: XOR<equipeCreateWithoutEquipePessoasInput, equipeUncheckedCreateWithoutEquipePessoasInput>
    connectOrCreate?: equipeCreateOrConnectWithoutEquipePessoasInput
    connect?: equipeWhereUniqueInput
  }

  export type pessoaCreateNestedOneWithoutEquipesInput = {
    create?: XOR<pessoaCreateWithoutEquipesInput, pessoaUncheckedCreateWithoutEquipesInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutEquipesInput
    connect?: pessoaWhereUniqueInput
  }

  export type equipeUpdateOneRequiredWithoutEquipePessoasNestedInput = {
    create?: XOR<equipeCreateWithoutEquipePessoasInput, equipeUncheckedCreateWithoutEquipePessoasInput>
    connectOrCreate?: equipeCreateOrConnectWithoutEquipePessoasInput
    upsert?: equipeUpsertWithoutEquipePessoasInput
    connect?: equipeWhereUniqueInput
    update?: XOR<XOR<equipeUpdateToOneWithWhereWithoutEquipePessoasInput, equipeUpdateWithoutEquipePessoasInput>, equipeUncheckedUpdateWithoutEquipePessoasInput>
  }

  export type pessoaUpdateOneRequiredWithoutEquipesNestedInput = {
    create?: XOR<pessoaCreateWithoutEquipesInput, pessoaUncheckedCreateWithoutEquipesInput>
    connectOrCreate?: pessoaCreateOrConnectWithoutEquipesInput
    upsert?: pessoaUpsertWithoutEquipesInput
    connect?: pessoaWhereUniqueInput
    update?: XOR<XOR<pessoaUpdateToOneWithWhereWithoutEquipesInput, pessoaUpdateWithoutEquipesInput>, pessoaUncheckedUpdateWithoutEquipesInput>
  }

  export type dioceseCreateNestedOneWithoutLocalidadeInput = {
    create?: XOR<dioceseCreateWithoutLocalidadeInput, dioceseUncheckedCreateWithoutLocalidadeInput>
    connectOrCreate?: dioceseCreateOrConnectWithoutLocalidadeInput
    connect?: dioceseWhereUniqueInput
  }

  export type tipoLocalidadeCreateNestedOneWithoutLocalidadeInput = {
    create?: XOR<tipoLocalidadeCreateWithoutLocalidadeInput, tipoLocalidadeUncheckedCreateWithoutLocalidadeInput>
    connectOrCreate?: tipoLocalidadeCreateOrConnectWithoutLocalidadeInput
    connect?: tipoLocalidadeWhereUniqueInput
  }

  export type enderecoCreateNestedOneWithoutLocalidadeInput = {
    create?: XOR<enderecoCreateWithoutLocalidadeInput, enderecoUncheckedCreateWithoutLocalidadeInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutLocalidadeInput
    connect?: enderecoWhereUniqueInput
  }

  export type localidadeRegiaoCreateNestedManyWithoutLocalidadeInput = {
    create?: XOR<localidadeRegiaoCreateWithoutLocalidadeInput, localidadeRegiaoUncheckedCreateWithoutLocalidadeInput> | localidadeRegiaoCreateWithoutLocalidadeInput[] | localidadeRegiaoUncheckedCreateWithoutLocalidadeInput[]
    connectOrCreate?: localidadeRegiaoCreateOrConnectWithoutLocalidadeInput | localidadeRegiaoCreateOrConnectWithoutLocalidadeInput[]
    createMany?: localidadeRegiaoCreateManyLocalidadeInputEnvelope
    connect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
  }

  export type localidadeRegiaoUncheckedCreateNestedManyWithoutLocalidadeInput = {
    create?: XOR<localidadeRegiaoCreateWithoutLocalidadeInput, localidadeRegiaoUncheckedCreateWithoutLocalidadeInput> | localidadeRegiaoCreateWithoutLocalidadeInput[] | localidadeRegiaoUncheckedCreateWithoutLocalidadeInput[]
    connectOrCreate?: localidadeRegiaoCreateOrConnectWithoutLocalidadeInput | localidadeRegiaoCreateOrConnectWithoutLocalidadeInput[]
    createMany?: localidadeRegiaoCreateManyLocalidadeInputEnvelope
    connect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
  }

  export type dioceseUpdateOneRequiredWithoutLocalidadeNestedInput = {
    create?: XOR<dioceseCreateWithoutLocalidadeInput, dioceseUncheckedCreateWithoutLocalidadeInput>
    connectOrCreate?: dioceseCreateOrConnectWithoutLocalidadeInput
    upsert?: dioceseUpsertWithoutLocalidadeInput
    connect?: dioceseWhereUniqueInput
    update?: XOR<XOR<dioceseUpdateToOneWithWhereWithoutLocalidadeInput, dioceseUpdateWithoutLocalidadeInput>, dioceseUncheckedUpdateWithoutLocalidadeInput>
  }

  export type tipoLocalidadeUpdateOneRequiredWithoutLocalidadeNestedInput = {
    create?: XOR<tipoLocalidadeCreateWithoutLocalidadeInput, tipoLocalidadeUncheckedCreateWithoutLocalidadeInput>
    connectOrCreate?: tipoLocalidadeCreateOrConnectWithoutLocalidadeInput
    upsert?: tipoLocalidadeUpsertWithoutLocalidadeInput
    connect?: tipoLocalidadeWhereUniqueInput
    update?: XOR<XOR<tipoLocalidadeUpdateToOneWithWhereWithoutLocalidadeInput, tipoLocalidadeUpdateWithoutLocalidadeInput>, tipoLocalidadeUncheckedUpdateWithoutLocalidadeInput>
  }

  export type enderecoUpdateOneRequiredWithoutLocalidadeNestedInput = {
    create?: XOR<enderecoCreateWithoutLocalidadeInput, enderecoUncheckedCreateWithoutLocalidadeInput>
    connectOrCreate?: enderecoCreateOrConnectWithoutLocalidadeInput
    upsert?: enderecoUpsertWithoutLocalidadeInput
    connect?: enderecoWhereUniqueInput
    update?: XOR<XOR<enderecoUpdateToOneWithWhereWithoutLocalidadeInput, enderecoUpdateWithoutLocalidadeInput>, enderecoUncheckedUpdateWithoutLocalidadeInput>
  }

  export type localidadeRegiaoUpdateManyWithoutLocalidadeNestedInput = {
    create?: XOR<localidadeRegiaoCreateWithoutLocalidadeInput, localidadeRegiaoUncheckedCreateWithoutLocalidadeInput> | localidadeRegiaoCreateWithoutLocalidadeInput[] | localidadeRegiaoUncheckedCreateWithoutLocalidadeInput[]
    connectOrCreate?: localidadeRegiaoCreateOrConnectWithoutLocalidadeInput | localidadeRegiaoCreateOrConnectWithoutLocalidadeInput[]
    upsert?: localidadeRegiaoUpsertWithWhereUniqueWithoutLocalidadeInput | localidadeRegiaoUpsertWithWhereUniqueWithoutLocalidadeInput[]
    createMany?: localidadeRegiaoCreateManyLocalidadeInputEnvelope
    set?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    disconnect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    delete?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    connect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    update?: localidadeRegiaoUpdateWithWhereUniqueWithoutLocalidadeInput | localidadeRegiaoUpdateWithWhereUniqueWithoutLocalidadeInput[]
    updateMany?: localidadeRegiaoUpdateManyWithWhereWithoutLocalidadeInput | localidadeRegiaoUpdateManyWithWhereWithoutLocalidadeInput[]
    deleteMany?: localidadeRegiaoScalarWhereInput | localidadeRegiaoScalarWhereInput[]
  }

  export type localidadeRegiaoUncheckedUpdateManyWithoutLocalidadeNestedInput = {
    create?: XOR<localidadeRegiaoCreateWithoutLocalidadeInput, localidadeRegiaoUncheckedCreateWithoutLocalidadeInput> | localidadeRegiaoCreateWithoutLocalidadeInput[] | localidadeRegiaoUncheckedCreateWithoutLocalidadeInput[]
    connectOrCreate?: localidadeRegiaoCreateOrConnectWithoutLocalidadeInput | localidadeRegiaoCreateOrConnectWithoutLocalidadeInput[]
    upsert?: localidadeRegiaoUpsertWithWhereUniqueWithoutLocalidadeInput | localidadeRegiaoUpsertWithWhereUniqueWithoutLocalidadeInput[]
    createMany?: localidadeRegiaoCreateManyLocalidadeInputEnvelope
    set?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    disconnect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    delete?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    connect?: localidadeRegiaoWhereUniqueInput | localidadeRegiaoWhereUniqueInput[]
    update?: localidadeRegiaoUpdateWithWhereUniqueWithoutLocalidadeInput | localidadeRegiaoUpdateWithWhereUniqueWithoutLocalidadeInput[]
    updateMany?: localidadeRegiaoUpdateManyWithWhereWithoutLocalidadeInput | localidadeRegiaoUpdateManyWithWhereWithoutLocalidadeInput[]
    deleteMany?: localidadeRegiaoScalarWhereInput | localidadeRegiaoScalarWhereInput[]
  }

  export type localidadeCreateNestedOneWithoutLocalidadeRegiaoInput = {
    create?: XOR<localidadeCreateWithoutLocalidadeRegiaoInput, localidadeUncheckedCreateWithoutLocalidadeRegiaoInput>
    connectOrCreate?: localidadeCreateOrConnectWithoutLocalidadeRegiaoInput
    connect?: localidadeWhereUniqueInput
  }

  export type regiaoCreateNestedOneWithoutLocalidadeRegiaoInput = {
    create?: XOR<regiaoCreateWithoutLocalidadeRegiaoInput, regiaoUncheckedCreateWithoutLocalidadeRegiaoInput>
    connectOrCreate?: regiaoCreateOrConnectWithoutLocalidadeRegiaoInput
    connect?: regiaoWhereUniqueInput
  }

  export type localidadeUpdateOneRequiredWithoutLocalidadeRegiaoNestedInput = {
    create?: XOR<localidadeCreateWithoutLocalidadeRegiaoInput, localidadeUncheckedCreateWithoutLocalidadeRegiaoInput>
    connectOrCreate?: localidadeCreateOrConnectWithoutLocalidadeRegiaoInput
    upsert?: localidadeUpsertWithoutLocalidadeRegiaoInput
    connect?: localidadeWhereUniqueInput
    update?: XOR<XOR<localidadeUpdateToOneWithWhereWithoutLocalidadeRegiaoInput, localidadeUpdateWithoutLocalidadeRegiaoInput>, localidadeUncheckedUpdateWithoutLocalidadeRegiaoInput>
  }

  export type regiaoUpdateOneRequiredWithoutLocalidadeRegiaoNestedInput = {
    create?: XOR<regiaoCreateWithoutLocalidadeRegiaoInput, regiaoUncheckedCreateWithoutLocalidadeRegiaoInput>
    connectOrCreate?: regiaoCreateOrConnectWithoutLocalidadeRegiaoInput
    upsert?: regiaoUpsertWithoutLocalidadeRegiaoInput
    connect?: regiaoWhereUniqueInput
    update?: XOR<XOR<regiaoUpdateToOneWithWhereWithoutLocalidadeRegiaoInput, regiaoUpdateWithoutLocalidadeRegiaoInput>, regiaoUncheckedUpdateWithoutLocalidadeRegiaoInput>
  }

  export type localidadeCreateNestedManyWithoutTipoLocalidadeInput = {
    create?: XOR<localidadeCreateWithoutTipoLocalidadeInput, localidadeUncheckedCreateWithoutTipoLocalidadeInput> | localidadeCreateWithoutTipoLocalidadeInput[] | localidadeUncheckedCreateWithoutTipoLocalidadeInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutTipoLocalidadeInput | localidadeCreateOrConnectWithoutTipoLocalidadeInput[]
    createMany?: localidadeCreateManyTipoLocalidadeInputEnvelope
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
  }

  export type localidadeUncheckedCreateNestedManyWithoutTipoLocalidadeInput = {
    create?: XOR<localidadeCreateWithoutTipoLocalidadeInput, localidadeUncheckedCreateWithoutTipoLocalidadeInput> | localidadeCreateWithoutTipoLocalidadeInput[] | localidadeUncheckedCreateWithoutTipoLocalidadeInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutTipoLocalidadeInput | localidadeCreateOrConnectWithoutTipoLocalidadeInput[]
    createMany?: localidadeCreateManyTipoLocalidadeInputEnvelope
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
  }

  export type localidadeUpdateManyWithoutTipoLocalidadeNestedInput = {
    create?: XOR<localidadeCreateWithoutTipoLocalidadeInput, localidadeUncheckedCreateWithoutTipoLocalidadeInput> | localidadeCreateWithoutTipoLocalidadeInput[] | localidadeUncheckedCreateWithoutTipoLocalidadeInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutTipoLocalidadeInput | localidadeCreateOrConnectWithoutTipoLocalidadeInput[]
    upsert?: localidadeUpsertWithWhereUniqueWithoutTipoLocalidadeInput | localidadeUpsertWithWhereUniqueWithoutTipoLocalidadeInput[]
    createMany?: localidadeCreateManyTipoLocalidadeInputEnvelope
    set?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    disconnect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    delete?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    update?: localidadeUpdateWithWhereUniqueWithoutTipoLocalidadeInput | localidadeUpdateWithWhereUniqueWithoutTipoLocalidadeInput[]
    updateMany?: localidadeUpdateManyWithWhereWithoutTipoLocalidadeInput | localidadeUpdateManyWithWhereWithoutTipoLocalidadeInput[]
    deleteMany?: localidadeScalarWhereInput | localidadeScalarWhereInput[]
  }

  export type localidadeUncheckedUpdateManyWithoutTipoLocalidadeNestedInput = {
    create?: XOR<localidadeCreateWithoutTipoLocalidadeInput, localidadeUncheckedCreateWithoutTipoLocalidadeInput> | localidadeCreateWithoutTipoLocalidadeInput[] | localidadeUncheckedCreateWithoutTipoLocalidadeInput[]
    connectOrCreate?: localidadeCreateOrConnectWithoutTipoLocalidadeInput | localidadeCreateOrConnectWithoutTipoLocalidadeInput[]
    upsert?: localidadeUpsertWithWhereUniqueWithoutTipoLocalidadeInput | localidadeUpsertWithWhereUniqueWithoutTipoLocalidadeInput[]
    createMany?: localidadeCreateManyTipoLocalidadeInputEnvelope
    set?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    disconnect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    delete?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    connect?: localidadeWhereUniqueInput | localidadeWhereUniqueInput[]
    update?: localidadeUpdateWithWhereUniqueWithoutTipoLocalidadeInput | localidadeUpdateWithWhereUniqueWithoutTipoLocalidadeInput[]
    updateMany?: localidadeUpdateManyWithWhereWithoutTipoLocalidadeInput | localidadeUpdateManyWithWhereWithoutTipoLocalidadeInput[]
    deleteMany?: localidadeScalarWhereInput | localidadeScalarWhereInput[]
  }

  export type EnumrolesFieldUpdateOperationsInput = {
    set?: $Enums.roles
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumSexoFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoFilter<$PrismaModel> | $Enums.Sexo
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSexoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel>
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel>
    not?: NestedEnumSexoWithAggregatesFilter<$PrismaModel> | $Enums.Sexo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexoFilter<$PrismaModel>
    _max?: NestedEnumSexoFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumrolesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles | EnumrolesFieldRefInput<$PrismaModel>
    in?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    not?: NestedEnumrolesFilter<$PrismaModel> | $Enums.roles
  }

  export type NestedEnumrolesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.roles | EnumrolesFieldRefInput<$PrismaModel>
    in?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    notIn?: $Enums.roles[] | ListEnumrolesFieldRefInput<$PrismaModel>
    not?: NestedEnumrolesWithAggregatesFilter<$PrismaModel> | $Enums.roles
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrolesFilter<$PrismaModel>
    _max?: NestedEnumrolesFilter<$PrismaModel>
  }

  export type estadoCreateWithoutPaisInput = {
    nome: string
    sigla: string
    ativo?: boolean
    cidade?: cidadeCreateNestedManyWithoutEstadoInput
  }

  export type estadoUncheckedCreateWithoutPaisInput = {
    id?: number
    nome: string
    sigla: string
    ativo?: boolean
    cidade?: cidadeUncheckedCreateNestedManyWithoutEstadoInput
  }

  export type estadoCreateOrConnectWithoutPaisInput = {
    where: estadoWhereUniqueInput
    create: XOR<estadoCreateWithoutPaisInput, estadoUncheckedCreateWithoutPaisInput>
  }

  export type estadoCreateManyPaisInputEnvelope = {
    data: estadoCreateManyPaisInput | estadoCreateManyPaisInput[]
    skipDuplicates?: boolean
  }

  export type estadoUpsertWithWhereUniqueWithoutPaisInput = {
    where: estadoWhereUniqueInput
    update: XOR<estadoUpdateWithoutPaisInput, estadoUncheckedUpdateWithoutPaisInput>
    create: XOR<estadoCreateWithoutPaisInput, estadoUncheckedCreateWithoutPaisInput>
  }

  export type estadoUpdateWithWhereUniqueWithoutPaisInput = {
    where: estadoWhereUniqueInput
    data: XOR<estadoUpdateWithoutPaisInput, estadoUncheckedUpdateWithoutPaisInput>
  }

  export type estadoUpdateManyWithWhereWithoutPaisInput = {
    where: estadoScalarWhereInput
    data: XOR<estadoUpdateManyMutationInput, estadoUncheckedUpdateManyWithoutPaisInput>
  }

  export type estadoScalarWhereInput = {
    AND?: estadoScalarWhereInput | estadoScalarWhereInput[]
    OR?: estadoScalarWhereInput[]
    NOT?: estadoScalarWhereInput | estadoScalarWhereInput[]
    id?: IntFilter<"estado"> | number
    nome?: StringFilter<"estado"> | string
    sigla?: StringFilter<"estado"> | string
    ativo?: BoolFilter<"estado"> | boolean
    paisId?: IntFilter<"estado"> | number
  }

  export type paisCreateWithoutEstadoInput = {
    isoAlpha2: string
    nome: string
    regiao: string
    subRegiao: string
    regiaoIntermediaria?: string | null
    lingua: string
    capital: string
  }

  export type paisUncheckedCreateWithoutEstadoInput = {
    id?: number
    isoAlpha2: string
    nome: string
    regiao: string
    subRegiao: string
    regiaoIntermediaria?: string | null
    lingua: string
    capital: string
  }

  export type paisCreateOrConnectWithoutEstadoInput = {
    where: paisWhereUniqueInput
    create: XOR<paisCreateWithoutEstadoInput, paisUncheckedCreateWithoutEstadoInput>
  }

  export type cidadeCreateWithoutEstadoInput = {
    nome: string
    ativo?: boolean
  }

  export type cidadeUncheckedCreateWithoutEstadoInput = {
    id?: number
    nome: string
    ativo?: boolean
  }

  export type cidadeCreateOrConnectWithoutEstadoInput = {
    where: cidadeWhereUniqueInput
    create: XOR<cidadeCreateWithoutEstadoInput, cidadeUncheckedCreateWithoutEstadoInput>
  }

  export type cidadeCreateManyEstadoInputEnvelope = {
    data: cidadeCreateManyEstadoInput | cidadeCreateManyEstadoInput[]
    skipDuplicates?: boolean
  }

  export type paisUpsertWithoutEstadoInput = {
    update: XOR<paisUpdateWithoutEstadoInput, paisUncheckedUpdateWithoutEstadoInput>
    create: XOR<paisCreateWithoutEstadoInput, paisUncheckedCreateWithoutEstadoInput>
    where?: paisWhereInput
  }

  export type paisUpdateToOneWithWhereWithoutEstadoInput = {
    where?: paisWhereInput
    data: XOR<paisUpdateWithoutEstadoInput, paisUncheckedUpdateWithoutEstadoInput>
  }

  export type paisUpdateWithoutEstadoInput = {
    isoAlpha2?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    regiao?: StringFieldUpdateOperationsInput | string
    subRegiao?: StringFieldUpdateOperationsInput | string
    regiaoIntermediaria?: NullableStringFieldUpdateOperationsInput | string | null
    lingua?: StringFieldUpdateOperationsInput | string
    capital?: StringFieldUpdateOperationsInput | string
  }

  export type paisUncheckedUpdateWithoutEstadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    isoAlpha2?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    regiao?: StringFieldUpdateOperationsInput | string
    subRegiao?: StringFieldUpdateOperationsInput | string
    regiaoIntermediaria?: NullableStringFieldUpdateOperationsInput | string | null
    lingua?: StringFieldUpdateOperationsInput | string
    capital?: StringFieldUpdateOperationsInput | string
  }

  export type cidadeUpsertWithWhereUniqueWithoutEstadoInput = {
    where: cidadeWhereUniqueInput
    update: XOR<cidadeUpdateWithoutEstadoInput, cidadeUncheckedUpdateWithoutEstadoInput>
    create: XOR<cidadeCreateWithoutEstadoInput, cidadeUncheckedCreateWithoutEstadoInput>
  }

  export type cidadeUpdateWithWhereUniqueWithoutEstadoInput = {
    where: cidadeWhereUniqueInput
    data: XOR<cidadeUpdateWithoutEstadoInput, cidadeUncheckedUpdateWithoutEstadoInput>
  }

  export type cidadeUpdateManyWithWhereWithoutEstadoInput = {
    where: cidadeScalarWhereInput
    data: XOR<cidadeUpdateManyMutationInput, cidadeUncheckedUpdateManyWithoutEstadoInput>
  }

  export type cidadeScalarWhereInput = {
    AND?: cidadeScalarWhereInput | cidadeScalarWhereInput[]
    OR?: cidadeScalarWhereInput[]
    NOT?: cidadeScalarWhereInput | cidadeScalarWhereInput[]
    id?: IntFilter<"cidade"> | number
    nome?: StringFilter<"cidade"> | string
    estadoId?: IntFilter<"cidade"> | number
    ativo?: BoolFilter<"cidade"> | boolean
  }

  export type estadoCreateWithoutCidadeInput = {
    nome: string
    sigla: string
    ativo?: boolean
    pais: paisCreateNestedOneWithoutEstadoInput
  }

  export type estadoUncheckedCreateWithoutCidadeInput = {
    id?: number
    nome: string
    sigla: string
    ativo?: boolean
    paisId: number
  }

  export type estadoCreateOrConnectWithoutCidadeInput = {
    where: estadoWhereUniqueInput
    create: XOR<estadoCreateWithoutCidadeInput, estadoUncheckedCreateWithoutCidadeInput>
  }

  export type estadoUpsertWithoutCidadeInput = {
    update: XOR<estadoUpdateWithoutCidadeInput, estadoUncheckedUpdateWithoutCidadeInput>
    create: XOR<estadoCreateWithoutCidadeInput, estadoUncheckedCreateWithoutCidadeInput>
    where?: estadoWhereInput
  }

  export type estadoUpdateToOneWithWhereWithoutCidadeInput = {
    where?: estadoWhereInput
    data: XOR<estadoUpdateWithoutCidadeInput, estadoUncheckedUpdateWithoutCidadeInput>
  }

  export type estadoUpdateWithoutCidadeInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    pais?: paisUpdateOneRequiredWithoutEstadoNestedInput
  }

  export type estadoUncheckedUpdateWithoutCidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    paisId?: IntFieldUpdateOperationsInput | number
  }

  export type paroquiaCreateWithoutEnderecoInput = {
    descricao: string
    diocese: dioceseCreateNestedOneWithoutParoquiasInput
    pessoas?: paroquiaPessoasCreateNestedManyWithoutParoquiaInput
  }

  export type paroquiaUncheckedCreateWithoutEnderecoInput = {
    id?: number
    dioceseId: number
    descricao: string
    pessoas?: paroquiaPessoasUncheckedCreateNestedManyWithoutParoquiaInput
  }

  export type paroquiaCreateOrConnectWithoutEnderecoInput = {
    where: paroquiaWhereUniqueInput
    create: XOR<paroquiaCreateWithoutEnderecoInput, paroquiaUncheckedCreateWithoutEnderecoInput>
  }

  export type paroquiaCreateManyEnderecoInputEnvelope = {
    data: paroquiaCreateManyEnderecoInput | paroquiaCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type pessoaEnderecoCreateWithoutEnderecoInput = {
    pessoa: pessoaCreateNestedOneWithoutEnderecosInput
  }

  export type pessoaEnderecoUncheckedCreateWithoutEnderecoInput = {
    pessoaId: number
  }

  export type pessoaEnderecoCreateOrConnectWithoutEnderecoInput = {
    where: pessoaEnderecoWhereUniqueInput
    create: XOR<pessoaEnderecoCreateWithoutEnderecoInput, pessoaEnderecoUncheckedCreateWithoutEnderecoInput>
  }

  export type pessoaEnderecoCreateManyEnderecoInputEnvelope = {
    data: pessoaEnderecoCreateManyEnderecoInput | pessoaEnderecoCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type localidadeCreateWithoutEnderecoInput = {
    descricao: string
    observacao?: string | null
    diocese: dioceseCreateNestedOneWithoutLocalidadeInput
    tipoLocalidade: tipoLocalidadeCreateNestedOneWithoutLocalidadeInput
    localidadeRegiao?: localidadeRegiaoCreateNestedManyWithoutLocalidadeInput
  }

  export type localidadeUncheckedCreateWithoutEnderecoInput = {
    id?: number
    descricao: string
    dioceseId: number
    tipoLocalidadeId: number
    observacao?: string | null
    localidadeRegiao?: localidadeRegiaoUncheckedCreateNestedManyWithoutLocalidadeInput
  }

  export type localidadeCreateOrConnectWithoutEnderecoInput = {
    where: localidadeWhereUniqueInput
    create: XOR<localidadeCreateWithoutEnderecoInput, localidadeUncheckedCreateWithoutEnderecoInput>
  }

  export type localidadeCreateManyEnderecoInputEnvelope = {
    data: localidadeCreateManyEnderecoInput | localidadeCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type dioceseCreateWithoutEnderecoInput = {
    descricao: string
    tipoDiocese: tipoDioceseCreateNestedOneWithoutDiocesesInput
    paroquias?: paroquiaCreateNestedManyWithoutDioceseInput
    localidade?: localidadeCreateNestedManyWithoutDioceseInput
  }

  export type dioceseUncheckedCreateWithoutEnderecoInput = {
    id?: number
    tipoDioceseId: number
    descricao: string
    paroquias?: paroquiaUncheckedCreateNestedManyWithoutDioceseInput
    localidade?: localidadeUncheckedCreateNestedManyWithoutDioceseInput
  }

  export type dioceseCreateOrConnectWithoutEnderecoInput = {
    where: dioceseWhereUniqueInput
    create: XOR<dioceseCreateWithoutEnderecoInput, dioceseUncheckedCreateWithoutEnderecoInput>
  }

  export type dioceseCreateManyEnderecoInputEnvelope = {
    data: dioceseCreateManyEnderecoInput | dioceseCreateManyEnderecoInput[]
    skipDuplicates?: boolean
  }

  export type paroquiaUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: paroquiaWhereUniqueInput
    update: XOR<paroquiaUpdateWithoutEnderecoInput, paroquiaUncheckedUpdateWithoutEnderecoInput>
    create: XOR<paroquiaCreateWithoutEnderecoInput, paroquiaUncheckedCreateWithoutEnderecoInput>
  }

  export type paroquiaUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: paroquiaWhereUniqueInput
    data: XOR<paroquiaUpdateWithoutEnderecoInput, paroquiaUncheckedUpdateWithoutEnderecoInput>
  }

  export type paroquiaUpdateManyWithWhereWithoutEnderecoInput = {
    where: paroquiaScalarWhereInput
    data: XOR<paroquiaUpdateManyMutationInput, paroquiaUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type paroquiaScalarWhereInput = {
    AND?: paroquiaScalarWhereInput | paroquiaScalarWhereInput[]
    OR?: paroquiaScalarWhereInput[]
    NOT?: paroquiaScalarWhereInput | paroquiaScalarWhereInput[]
    id?: IntFilter<"paroquia"> | number
    enderecoId?: IntFilter<"paroquia"> | number
    dioceseId?: IntFilter<"paroquia"> | number
    descricao?: StringFilter<"paroquia"> | string
  }

  export type pessoaEnderecoUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: pessoaEnderecoWhereUniqueInput
    update: XOR<pessoaEnderecoUpdateWithoutEnderecoInput, pessoaEnderecoUncheckedUpdateWithoutEnderecoInput>
    create: XOR<pessoaEnderecoCreateWithoutEnderecoInput, pessoaEnderecoUncheckedCreateWithoutEnderecoInput>
  }

  export type pessoaEnderecoUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: pessoaEnderecoWhereUniqueInput
    data: XOR<pessoaEnderecoUpdateWithoutEnderecoInput, pessoaEnderecoUncheckedUpdateWithoutEnderecoInput>
  }

  export type pessoaEnderecoUpdateManyWithWhereWithoutEnderecoInput = {
    where: pessoaEnderecoScalarWhereInput
    data: XOR<pessoaEnderecoUpdateManyMutationInput, pessoaEnderecoUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type pessoaEnderecoScalarWhereInput = {
    AND?: pessoaEnderecoScalarWhereInput | pessoaEnderecoScalarWhereInput[]
    OR?: pessoaEnderecoScalarWhereInput[]
    NOT?: pessoaEnderecoScalarWhereInput | pessoaEnderecoScalarWhereInput[]
    pessoaId?: IntFilter<"pessoaEndereco"> | number
    enderecoId?: IntFilter<"pessoaEndereco"> | number
  }

  export type localidadeUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: localidadeWhereUniqueInput
    update: XOR<localidadeUpdateWithoutEnderecoInput, localidadeUncheckedUpdateWithoutEnderecoInput>
    create: XOR<localidadeCreateWithoutEnderecoInput, localidadeUncheckedCreateWithoutEnderecoInput>
  }

  export type localidadeUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: localidadeWhereUniqueInput
    data: XOR<localidadeUpdateWithoutEnderecoInput, localidadeUncheckedUpdateWithoutEnderecoInput>
  }

  export type localidadeUpdateManyWithWhereWithoutEnderecoInput = {
    where: localidadeScalarWhereInput
    data: XOR<localidadeUpdateManyMutationInput, localidadeUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type localidadeScalarWhereInput = {
    AND?: localidadeScalarWhereInput | localidadeScalarWhereInput[]
    OR?: localidadeScalarWhereInput[]
    NOT?: localidadeScalarWhereInput | localidadeScalarWhereInput[]
    id?: IntFilter<"localidade"> | number
    descricao?: StringFilter<"localidade"> | string
    dioceseId?: IntFilter<"localidade"> | number
    tipoLocalidadeId?: IntFilter<"localidade"> | number
    observacao?: StringNullableFilter<"localidade"> | string | null
    enderecoId?: IntFilter<"localidade"> | number
  }

  export type dioceseUpsertWithWhereUniqueWithoutEnderecoInput = {
    where: dioceseWhereUniqueInput
    update: XOR<dioceseUpdateWithoutEnderecoInput, dioceseUncheckedUpdateWithoutEnderecoInput>
    create: XOR<dioceseCreateWithoutEnderecoInput, dioceseUncheckedCreateWithoutEnderecoInput>
  }

  export type dioceseUpdateWithWhereUniqueWithoutEnderecoInput = {
    where: dioceseWhereUniqueInput
    data: XOR<dioceseUpdateWithoutEnderecoInput, dioceseUncheckedUpdateWithoutEnderecoInput>
  }

  export type dioceseUpdateManyWithWhereWithoutEnderecoInput = {
    where: dioceseScalarWhereInput
    data: XOR<dioceseUpdateManyMutationInput, dioceseUncheckedUpdateManyWithoutEnderecoInput>
  }

  export type dioceseScalarWhereInput = {
    AND?: dioceseScalarWhereInput | dioceseScalarWhereInput[]
    OR?: dioceseScalarWhereInput[]
    NOT?: dioceseScalarWhereInput | dioceseScalarWhereInput[]
    id?: IntFilter<"diocese"> | number
    tipoDioceseId?: IntFilter<"diocese"> | number
    descricao?: StringFilter<"diocese"> | string
    enderecoId?: IntFilter<"diocese"> | number
  }

  export type pessoaCarismaCreateWithoutTipoCarismaInput = {
    pessoa: pessoaCreateNestedOneWithoutPessoaCarismaInput
  }

  export type pessoaCarismaUncheckedCreateWithoutTipoCarismaInput = {
    pessoaId: number
  }

  export type pessoaCarismaCreateOrConnectWithoutTipoCarismaInput = {
    where: pessoaCarismaWhereUniqueInput
    create: XOR<pessoaCarismaCreateWithoutTipoCarismaInput, pessoaCarismaUncheckedCreateWithoutTipoCarismaInput>
  }

  export type pessoaCarismaCreateManyTipoCarismaInputEnvelope = {
    data: pessoaCarismaCreateManyTipoCarismaInput | pessoaCarismaCreateManyTipoCarismaInput[]
    skipDuplicates?: boolean
  }

  export type pessoaCarismaUpsertWithWhereUniqueWithoutTipoCarismaInput = {
    where: pessoaCarismaWhereUniqueInput
    update: XOR<pessoaCarismaUpdateWithoutTipoCarismaInput, pessoaCarismaUncheckedUpdateWithoutTipoCarismaInput>
    create: XOR<pessoaCarismaCreateWithoutTipoCarismaInput, pessoaCarismaUncheckedCreateWithoutTipoCarismaInput>
  }

  export type pessoaCarismaUpdateWithWhereUniqueWithoutTipoCarismaInput = {
    where: pessoaCarismaWhereUniqueInput
    data: XOR<pessoaCarismaUpdateWithoutTipoCarismaInput, pessoaCarismaUncheckedUpdateWithoutTipoCarismaInput>
  }

  export type pessoaCarismaUpdateManyWithWhereWithoutTipoCarismaInput = {
    where: pessoaCarismaScalarWhereInput
    data: XOR<pessoaCarismaUpdateManyMutationInput, pessoaCarismaUncheckedUpdateManyWithoutTipoCarismaInput>
  }

  export type pessoaCarismaScalarWhereInput = {
    AND?: pessoaCarismaScalarWhereInput | pessoaCarismaScalarWhereInput[]
    OR?: pessoaCarismaScalarWhereInput[]
    NOT?: pessoaCarismaScalarWhereInput | pessoaCarismaScalarWhereInput[]
    pessoaId?: IntFilter<"pessoaCarisma"> | number
    tipoCarismaId?: IntFilter<"pessoaCarisma"> | number
  }

  export type pessoaCreateWithoutEstadoCivilInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutEstadoCivilInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutEstadoCivilInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutEstadoCivilInput, pessoaUncheckedCreateWithoutEstadoCivilInput>
  }

  export type pessoaCreateManyEstadoCivilInputEnvelope = {
    data: pessoaCreateManyEstadoCivilInput | pessoaCreateManyEstadoCivilInput[]
    skipDuplicates?: boolean
  }

  export type pessoaUpsertWithWhereUniqueWithoutEstadoCivilInput = {
    where: pessoaWhereUniqueInput
    update: XOR<pessoaUpdateWithoutEstadoCivilInput, pessoaUncheckedUpdateWithoutEstadoCivilInput>
    create: XOR<pessoaCreateWithoutEstadoCivilInput, pessoaUncheckedCreateWithoutEstadoCivilInput>
  }

  export type pessoaUpdateWithWhereUniqueWithoutEstadoCivilInput = {
    where: pessoaWhereUniqueInput
    data: XOR<pessoaUpdateWithoutEstadoCivilInput, pessoaUncheckedUpdateWithoutEstadoCivilInput>
  }

  export type pessoaUpdateManyWithWhereWithoutEstadoCivilInput = {
    where: pessoaScalarWhereInput
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyWithoutEstadoCivilInput>
  }

  export type pessoaScalarWhereInput = {
    AND?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
    OR?: pessoaScalarWhereInput[]
    NOT?: pessoaScalarWhereInput | pessoaScalarWhereInput[]
    id?: IntFilter<"pessoa"> | number
    nome?: StringFilter<"pessoa"> | string
    conhecidoPor?: StringNullableFilter<"pessoa"> | string | null
    sexo?: EnumSexoFilter<"pessoa"> | $Enums.Sexo
    cpf?: StringNullableFilter<"pessoa"> | string | null
    nacionalidade?: StringFilter<"pessoa"> | string
    dataNascimento?: DateTimeNullableFilter<"pessoa"> | Date | string | null
    estadoCivilId?: IntFilter<"pessoa"> | number
    foto?: StringNullableFilter<"pessoa"> | string | null
    escolaridadeId?: IntNullableFilter<"pessoa"> | number | null
    ativo?: BoolFilter<"pessoa"> | boolean
    tipoPessoaId?: IntFilter<"pessoa"> | number
  }

  export type pessoaCreateWithoutEscolaridadeInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutEscolaridadeInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutEscolaridadeInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutEscolaridadeInput, pessoaUncheckedCreateWithoutEscolaridadeInput>
  }

  export type pessoaCreateManyEscolaridadeInputEnvelope = {
    data: pessoaCreateManyEscolaridadeInput | pessoaCreateManyEscolaridadeInput[]
    skipDuplicates?: boolean
  }

  export type pessoaUpsertWithWhereUniqueWithoutEscolaridadeInput = {
    where: pessoaWhereUniqueInput
    update: XOR<pessoaUpdateWithoutEscolaridadeInput, pessoaUncheckedUpdateWithoutEscolaridadeInput>
    create: XOR<pessoaCreateWithoutEscolaridadeInput, pessoaUncheckedCreateWithoutEscolaridadeInput>
  }

  export type pessoaUpdateWithWhereUniqueWithoutEscolaridadeInput = {
    where: pessoaWhereUniqueInput
    data: XOR<pessoaUpdateWithoutEscolaridadeInput, pessoaUncheckedUpdateWithoutEscolaridadeInput>
  }

  export type pessoaUpdateManyWithWhereWithoutEscolaridadeInput = {
    where: pessoaScalarWhereInput
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyWithoutEscolaridadeInput>
  }

  export type estadoCivilCreateWithoutPessoasInput = {
    descricao: string
  }

  export type estadoCivilUncheckedCreateWithoutPessoasInput = {
    id?: number
    descricao: string
  }

  export type estadoCivilCreateOrConnectWithoutPessoasInput = {
    where: estadoCivilWhereUniqueInput
    create: XOR<estadoCivilCreateWithoutPessoasInput, estadoCivilUncheckedCreateWithoutPessoasInput>
  }

  export type escolaridadeCreateWithoutPessoasInput = {
    descricao: string
  }

  export type escolaridadeUncheckedCreateWithoutPessoasInput = {
    id?: number
    descricao: string
  }

  export type escolaridadeCreateOrConnectWithoutPessoasInput = {
    where: escolaridadeWhereUniqueInput
    create: XOR<escolaridadeCreateWithoutPessoasInput, escolaridadeUncheckedCreateWithoutPessoasInput>
  }

  export type tipoPessoaCreateWithoutPessoaInput = {
    descricao: string
  }

  export type tipoPessoaUncheckedCreateWithoutPessoaInput = {
    id?: number
    descricao: string
  }

  export type tipoPessoaCreateOrConnectWithoutPessoaInput = {
    where: tipoPessoaWhereUniqueInput
    create: XOR<tipoPessoaCreateWithoutPessoaInput, tipoPessoaUncheckedCreateWithoutPessoaInput>
  }

  export type passaportePessoaCreateWithoutPessoaInput = {
    numero: string
    dataExpiracao: Date | string
    renovado?: boolean
    dataRenovacao?: Date | string | null
  }

  export type passaportePessoaUncheckedCreateWithoutPessoaInput = {
    id?: number
    numero: string
    dataExpiracao: Date | string
    renovado?: boolean
    dataRenovacao?: Date | string | null
  }

  export type passaportePessoaCreateOrConnectWithoutPessoaInput = {
    where: passaportePessoaWhereUniqueInput
    create: XOR<passaportePessoaCreateWithoutPessoaInput, passaportePessoaUncheckedCreateWithoutPessoaInput>
  }

  export type passaportePessoaCreateManyPessoaInputEnvelope = {
    data: passaportePessoaCreateManyPessoaInput | passaportePessoaCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type pessoaContatoCreateWithoutPessoaInput = {
    telefoneResidencial?: string | null
    telefoneCelular?: string | null
    observacao?: string | null
    ativo?: boolean
    email?: string | null
  }

  export type pessoaContatoUncheckedCreateWithoutPessoaInput = {
    id?: number
    telefoneResidencial?: string | null
    telefoneCelular?: string | null
    observacao?: string | null
    ativo?: boolean
    email?: string | null
  }

  export type pessoaContatoCreateOrConnectWithoutPessoaInput = {
    where: pessoaContatoWhereUniqueInput
    create: XOR<pessoaContatoCreateWithoutPessoaInput, pessoaContatoUncheckedCreateWithoutPessoaInput>
  }

  export type pessoaContatoCreateManyPessoaInputEnvelope = {
    data: pessoaContatoCreateManyPessoaInput | pessoaContatoCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type paroquiaPessoasCreateWithoutPessoaInput = {
    paroquia: paroquiaCreateNestedOneWithoutPessoasInput
  }

  export type paroquiaPessoasUncheckedCreateWithoutPessoaInput = {
    paroquiaId: number
  }

  export type paroquiaPessoasCreateOrConnectWithoutPessoaInput = {
    where: paroquiaPessoasWhereUniqueInput
    create: XOR<paroquiaPessoasCreateWithoutPessoaInput, paroquiaPessoasUncheckedCreateWithoutPessoaInput>
  }

  export type paroquiaPessoasCreateManyPessoaInputEnvelope = {
    data: paroquiaPessoasCreateManyPessoaInput | paroquiaPessoasCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type pessoaCasalCreateWithoutMaridoInput = {
    mulher: pessoaCreateNestedOneWithoutCasamentosComoMulherInput
  }

  export type pessoaCasalUncheckedCreateWithoutMaridoInput = {
    id?: number
    pessoaMulherId: number
  }

  export type pessoaCasalCreateOrConnectWithoutMaridoInput = {
    where: pessoaCasalWhereUniqueInput
    create: XOR<pessoaCasalCreateWithoutMaridoInput, pessoaCasalUncheckedCreateWithoutMaridoInput>
  }

  export type pessoaCasalCreateManyMaridoInputEnvelope = {
    data: pessoaCasalCreateManyMaridoInput | pessoaCasalCreateManyMaridoInput[]
    skipDuplicates?: boolean
  }

  export type pessoaCasalCreateWithoutMulherInput = {
    marido: pessoaCreateNestedOneWithoutCasamentosComoMaridoInput
  }

  export type pessoaCasalUncheckedCreateWithoutMulherInput = {
    id?: number
    pessoaMaridoId: number
  }

  export type pessoaCasalCreateOrConnectWithoutMulherInput = {
    where: pessoaCasalWhereUniqueInput
    create: XOR<pessoaCasalCreateWithoutMulherInput, pessoaCasalUncheckedCreateWithoutMulherInput>
  }

  export type pessoaCasalCreateManyMulherInputEnvelope = {
    data: pessoaCasalCreateManyMulherInput | pessoaCasalCreateManyMulherInput[]
    skipDuplicates?: boolean
  }

  export type pessoaEnderecoCreateWithoutPessoaInput = {
    endereco: enderecoCreateNestedOneWithoutPessoasInput
  }

  export type pessoaEnderecoUncheckedCreateWithoutPessoaInput = {
    enderecoId: number
  }

  export type pessoaEnderecoCreateOrConnectWithoutPessoaInput = {
    where: pessoaEnderecoWhereUniqueInput
    create: XOR<pessoaEnderecoCreateWithoutPessoaInput, pessoaEnderecoUncheckedCreateWithoutPessoaInput>
  }

  export type pessoaEnderecoCreateManyPessoaInputEnvelope = {
    data: pessoaEnderecoCreateManyPessoaInput | pessoaEnderecoCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type equipePessoasCreateWithoutPessoaInput = {
    equipe: equipeCreateNestedOneWithoutEquipePessoasInput
  }

  export type equipePessoasUncheckedCreateWithoutPessoaInput = {
    equipeId: number
  }

  export type equipePessoasCreateOrConnectWithoutPessoaInput = {
    where: equipePessoasWhereUniqueInput
    create: XOR<equipePessoasCreateWithoutPessoaInput, equipePessoasUncheckedCreateWithoutPessoaInput>
  }

  export type equipePessoasCreateManyPessoaInputEnvelope = {
    data: equipePessoasCreateManyPessoaInput | equipePessoasCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type pessoaCarismaCreateWithoutPessoaInput = {
    tipoCarisma: tipoCarismaCreateNestedOneWithoutPessoaCarismaInput
  }

  export type pessoaCarismaUncheckedCreateWithoutPessoaInput = {
    tipoCarismaId: number
  }

  export type pessoaCarismaCreateOrConnectWithoutPessoaInput = {
    where: pessoaCarismaWhereUniqueInput
    create: XOR<pessoaCarismaCreateWithoutPessoaInput, pessoaCarismaUncheckedCreateWithoutPessoaInput>
  }

  export type pessoaCarismaCreateManyPessoaInputEnvelope = {
    data: pessoaCarismaCreateManyPessoaInput | pessoaCarismaCreateManyPessoaInput[]
    skipDuplicates?: boolean
  }

  export type estadoCivilUpsertWithoutPessoasInput = {
    update: XOR<estadoCivilUpdateWithoutPessoasInput, estadoCivilUncheckedUpdateWithoutPessoasInput>
    create: XOR<estadoCivilCreateWithoutPessoasInput, estadoCivilUncheckedCreateWithoutPessoasInput>
    where?: estadoCivilWhereInput
  }

  export type estadoCivilUpdateToOneWithWhereWithoutPessoasInput = {
    where?: estadoCivilWhereInput
    data: XOR<estadoCivilUpdateWithoutPessoasInput, estadoCivilUncheckedUpdateWithoutPessoasInput>
  }

  export type estadoCivilUpdateWithoutPessoasInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type estadoCivilUncheckedUpdateWithoutPessoasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type escolaridadeUpsertWithoutPessoasInput = {
    update: XOR<escolaridadeUpdateWithoutPessoasInput, escolaridadeUncheckedUpdateWithoutPessoasInput>
    create: XOR<escolaridadeCreateWithoutPessoasInput, escolaridadeUncheckedCreateWithoutPessoasInput>
    where?: escolaridadeWhereInput
  }

  export type escolaridadeUpdateToOneWithWhereWithoutPessoasInput = {
    where?: escolaridadeWhereInput
    data: XOR<escolaridadeUpdateWithoutPessoasInput, escolaridadeUncheckedUpdateWithoutPessoasInput>
  }

  export type escolaridadeUpdateWithoutPessoasInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type escolaridadeUncheckedUpdateWithoutPessoasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoPessoaUpsertWithoutPessoaInput = {
    update: XOR<tipoPessoaUpdateWithoutPessoaInput, tipoPessoaUncheckedUpdateWithoutPessoaInput>
    create: XOR<tipoPessoaCreateWithoutPessoaInput, tipoPessoaUncheckedCreateWithoutPessoaInput>
    where?: tipoPessoaWhereInput
  }

  export type tipoPessoaUpdateToOneWithWhereWithoutPessoaInput = {
    where?: tipoPessoaWhereInput
    data: XOR<tipoPessoaUpdateWithoutPessoaInput, tipoPessoaUncheckedUpdateWithoutPessoaInput>
  }

  export type tipoPessoaUpdateWithoutPessoaInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoPessoaUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type passaportePessoaUpsertWithWhereUniqueWithoutPessoaInput = {
    where: passaportePessoaWhereUniqueInput
    update: XOR<passaportePessoaUpdateWithoutPessoaInput, passaportePessoaUncheckedUpdateWithoutPessoaInput>
    create: XOR<passaportePessoaCreateWithoutPessoaInput, passaportePessoaUncheckedCreateWithoutPessoaInput>
  }

  export type passaportePessoaUpdateWithWhereUniqueWithoutPessoaInput = {
    where: passaportePessoaWhereUniqueInput
    data: XOR<passaportePessoaUpdateWithoutPessoaInput, passaportePessoaUncheckedUpdateWithoutPessoaInput>
  }

  export type passaportePessoaUpdateManyWithWhereWithoutPessoaInput = {
    where: passaportePessoaScalarWhereInput
    data: XOR<passaportePessoaUpdateManyMutationInput, passaportePessoaUncheckedUpdateManyWithoutPessoaInput>
  }

  export type passaportePessoaScalarWhereInput = {
    AND?: passaportePessoaScalarWhereInput | passaportePessoaScalarWhereInput[]
    OR?: passaportePessoaScalarWhereInput[]
    NOT?: passaportePessoaScalarWhereInput | passaportePessoaScalarWhereInput[]
    id?: IntFilter<"passaportePessoa"> | number
    pessoaId?: IntFilter<"passaportePessoa"> | number
    numero?: StringFilter<"passaportePessoa"> | string
    dataExpiracao?: DateTimeFilter<"passaportePessoa"> | Date | string
    renovado?: BoolFilter<"passaportePessoa"> | boolean
    dataRenovacao?: DateTimeNullableFilter<"passaportePessoa"> | Date | string | null
  }

  export type pessoaContatoUpsertWithWhereUniqueWithoutPessoaInput = {
    where: pessoaContatoWhereUniqueInput
    update: XOR<pessoaContatoUpdateWithoutPessoaInput, pessoaContatoUncheckedUpdateWithoutPessoaInput>
    create: XOR<pessoaContatoCreateWithoutPessoaInput, pessoaContatoUncheckedCreateWithoutPessoaInput>
  }

  export type pessoaContatoUpdateWithWhereUniqueWithoutPessoaInput = {
    where: pessoaContatoWhereUniqueInput
    data: XOR<pessoaContatoUpdateWithoutPessoaInput, pessoaContatoUncheckedUpdateWithoutPessoaInput>
  }

  export type pessoaContatoUpdateManyWithWhereWithoutPessoaInput = {
    where: pessoaContatoScalarWhereInput
    data: XOR<pessoaContatoUpdateManyMutationInput, pessoaContatoUncheckedUpdateManyWithoutPessoaInput>
  }

  export type pessoaContatoScalarWhereInput = {
    AND?: pessoaContatoScalarWhereInput | pessoaContatoScalarWhereInput[]
    OR?: pessoaContatoScalarWhereInput[]
    NOT?: pessoaContatoScalarWhereInput | pessoaContatoScalarWhereInput[]
    id?: IntFilter<"pessoaContato"> | number
    telefoneResidencial?: StringNullableFilter<"pessoaContato"> | string | null
    telefoneCelular?: StringNullableFilter<"pessoaContato"> | string | null
    observacao?: StringNullableFilter<"pessoaContato"> | string | null
    ativo?: BoolFilter<"pessoaContato"> | boolean
    email?: StringNullableFilter<"pessoaContato"> | string | null
    pessoaId?: IntFilter<"pessoaContato"> | number
  }

  export type paroquiaPessoasUpsertWithWhereUniqueWithoutPessoaInput = {
    where: paroquiaPessoasWhereUniqueInput
    update: XOR<paroquiaPessoasUpdateWithoutPessoaInput, paroquiaPessoasUncheckedUpdateWithoutPessoaInput>
    create: XOR<paroquiaPessoasCreateWithoutPessoaInput, paroquiaPessoasUncheckedCreateWithoutPessoaInput>
  }

  export type paroquiaPessoasUpdateWithWhereUniqueWithoutPessoaInput = {
    where: paroquiaPessoasWhereUniqueInput
    data: XOR<paroquiaPessoasUpdateWithoutPessoaInput, paroquiaPessoasUncheckedUpdateWithoutPessoaInput>
  }

  export type paroquiaPessoasUpdateManyWithWhereWithoutPessoaInput = {
    where: paroquiaPessoasScalarWhereInput
    data: XOR<paroquiaPessoasUpdateManyMutationInput, paroquiaPessoasUncheckedUpdateManyWithoutPessoaInput>
  }

  export type paroquiaPessoasScalarWhereInput = {
    AND?: paroquiaPessoasScalarWhereInput | paroquiaPessoasScalarWhereInput[]
    OR?: paroquiaPessoasScalarWhereInput[]
    NOT?: paroquiaPessoasScalarWhereInput | paroquiaPessoasScalarWhereInput[]
    pessoaId?: IntFilter<"paroquiaPessoas"> | number
    paroquiaId?: IntFilter<"paroquiaPessoas"> | number
  }

  export type pessoaCasalUpsertWithWhereUniqueWithoutMaridoInput = {
    where: pessoaCasalWhereUniqueInput
    update: XOR<pessoaCasalUpdateWithoutMaridoInput, pessoaCasalUncheckedUpdateWithoutMaridoInput>
    create: XOR<pessoaCasalCreateWithoutMaridoInput, pessoaCasalUncheckedCreateWithoutMaridoInput>
  }

  export type pessoaCasalUpdateWithWhereUniqueWithoutMaridoInput = {
    where: pessoaCasalWhereUniqueInput
    data: XOR<pessoaCasalUpdateWithoutMaridoInput, pessoaCasalUncheckedUpdateWithoutMaridoInput>
  }

  export type pessoaCasalUpdateManyWithWhereWithoutMaridoInput = {
    where: pessoaCasalScalarWhereInput
    data: XOR<pessoaCasalUpdateManyMutationInput, pessoaCasalUncheckedUpdateManyWithoutMaridoInput>
  }

  export type pessoaCasalScalarWhereInput = {
    AND?: pessoaCasalScalarWhereInput | pessoaCasalScalarWhereInput[]
    OR?: pessoaCasalScalarWhereInput[]
    NOT?: pessoaCasalScalarWhereInput | pessoaCasalScalarWhereInput[]
    id?: IntFilter<"pessoaCasal"> | number
    pessoaMaridoId?: IntFilter<"pessoaCasal"> | number
    pessoaMulherId?: IntFilter<"pessoaCasal"> | number
  }

  export type pessoaCasalUpsertWithWhereUniqueWithoutMulherInput = {
    where: pessoaCasalWhereUniqueInput
    update: XOR<pessoaCasalUpdateWithoutMulherInput, pessoaCasalUncheckedUpdateWithoutMulherInput>
    create: XOR<pessoaCasalCreateWithoutMulherInput, pessoaCasalUncheckedCreateWithoutMulherInput>
  }

  export type pessoaCasalUpdateWithWhereUniqueWithoutMulherInput = {
    where: pessoaCasalWhereUniqueInput
    data: XOR<pessoaCasalUpdateWithoutMulherInput, pessoaCasalUncheckedUpdateWithoutMulherInput>
  }

  export type pessoaCasalUpdateManyWithWhereWithoutMulherInput = {
    where: pessoaCasalScalarWhereInput
    data: XOR<pessoaCasalUpdateManyMutationInput, pessoaCasalUncheckedUpdateManyWithoutMulherInput>
  }

  export type pessoaEnderecoUpsertWithWhereUniqueWithoutPessoaInput = {
    where: pessoaEnderecoWhereUniqueInput
    update: XOR<pessoaEnderecoUpdateWithoutPessoaInput, pessoaEnderecoUncheckedUpdateWithoutPessoaInput>
    create: XOR<pessoaEnderecoCreateWithoutPessoaInput, pessoaEnderecoUncheckedCreateWithoutPessoaInput>
  }

  export type pessoaEnderecoUpdateWithWhereUniqueWithoutPessoaInput = {
    where: pessoaEnderecoWhereUniqueInput
    data: XOR<pessoaEnderecoUpdateWithoutPessoaInput, pessoaEnderecoUncheckedUpdateWithoutPessoaInput>
  }

  export type pessoaEnderecoUpdateManyWithWhereWithoutPessoaInput = {
    where: pessoaEnderecoScalarWhereInput
    data: XOR<pessoaEnderecoUpdateManyMutationInput, pessoaEnderecoUncheckedUpdateManyWithoutPessoaInput>
  }

  export type equipePessoasUpsertWithWhereUniqueWithoutPessoaInput = {
    where: equipePessoasWhereUniqueInput
    update: XOR<equipePessoasUpdateWithoutPessoaInput, equipePessoasUncheckedUpdateWithoutPessoaInput>
    create: XOR<equipePessoasCreateWithoutPessoaInput, equipePessoasUncheckedCreateWithoutPessoaInput>
  }

  export type equipePessoasUpdateWithWhereUniqueWithoutPessoaInput = {
    where: equipePessoasWhereUniqueInput
    data: XOR<equipePessoasUpdateWithoutPessoaInput, equipePessoasUncheckedUpdateWithoutPessoaInput>
  }

  export type equipePessoasUpdateManyWithWhereWithoutPessoaInput = {
    where: equipePessoasScalarWhereInput
    data: XOR<equipePessoasUpdateManyMutationInput, equipePessoasUncheckedUpdateManyWithoutPessoaInput>
  }

  export type equipePessoasScalarWhereInput = {
    AND?: equipePessoasScalarWhereInput | equipePessoasScalarWhereInput[]
    OR?: equipePessoasScalarWhereInput[]
    NOT?: equipePessoasScalarWhereInput | equipePessoasScalarWhereInput[]
    equipeId?: IntFilter<"equipePessoas"> | number
    pessoaId?: IntFilter<"equipePessoas"> | number
  }

  export type pessoaCarismaUpsertWithWhereUniqueWithoutPessoaInput = {
    where: pessoaCarismaWhereUniqueInput
    update: XOR<pessoaCarismaUpdateWithoutPessoaInput, pessoaCarismaUncheckedUpdateWithoutPessoaInput>
    create: XOR<pessoaCarismaCreateWithoutPessoaInput, pessoaCarismaUncheckedCreateWithoutPessoaInput>
  }

  export type pessoaCarismaUpdateWithWhereUniqueWithoutPessoaInput = {
    where: pessoaCarismaWhereUniqueInput
    data: XOR<pessoaCarismaUpdateWithoutPessoaInput, pessoaCarismaUncheckedUpdateWithoutPessoaInput>
  }

  export type pessoaCarismaUpdateManyWithWhereWithoutPessoaInput = {
    where: pessoaCarismaScalarWhereInput
    data: XOR<pessoaCarismaUpdateManyMutationInput, pessoaCarismaUncheckedUpdateManyWithoutPessoaInput>
  }

  export type pessoaCreateWithoutTipoPessoaInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutTipoPessoaInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutTipoPessoaInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutTipoPessoaInput, pessoaUncheckedCreateWithoutTipoPessoaInput>
  }

  export type pessoaCreateManyTipoPessoaInputEnvelope = {
    data: pessoaCreateManyTipoPessoaInput | pessoaCreateManyTipoPessoaInput[]
    skipDuplicates?: boolean
  }

  export type pessoaUpsertWithWhereUniqueWithoutTipoPessoaInput = {
    where: pessoaWhereUniqueInput
    update: XOR<pessoaUpdateWithoutTipoPessoaInput, pessoaUncheckedUpdateWithoutTipoPessoaInput>
    create: XOR<pessoaCreateWithoutTipoPessoaInput, pessoaUncheckedCreateWithoutTipoPessoaInput>
  }

  export type pessoaUpdateWithWhereUniqueWithoutTipoPessoaInput = {
    where: pessoaWhereUniqueInput
    data: XOR<pessoaUpdateWithoutTipoPessoaInput, pessoaUncheckedUpdateWithoutTipoPessoaInput>
  }

  export type pessoaUpdateManyWithWhereWithoutTipoPessoaInput = {
    where: pessoaScalarWhereInput
    data: XOR<pessoaUpdateManyMutationInput, pessoaUncheckedUpdateManyWithoutTipoPessoaInput>
  }

  export type pessoaCreateWithoutEnderecosInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutEnderecosInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutEnderecosInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutEnderecosInput, pessoaUncheckedCreateWithoutEnderecosInput>
  }

  export type enderecoCreateWithoutPessoasInput = {
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    paroquias?: paroquiaCreateNestedManyWithoutEnderecoInput
    localidade?: localidadeCreateNestedManyWithoutEnderecoInput
    diocese?: dioceseCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoUncheckedCreateWithoutPessoasInput = {
    id?: number
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    paroquias?: paroquiaUncheckedCreateNestedManyWithoutEnderecoInput
    localidade?: localidadeUncheckedCreateNestedManyWithoutEnderecoInput
    diocese?: dioceseUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoCreateOrConnectWithoutPessoasInput = {
    where: enderecoWhereUniqueInput
    create: XOR<enderecoCreateWithoutPessoasInput, enderecoUncheckedCreateWithoutPessoasInput>
  }

  export type pessoaUpsertWithoutEnderecosInput = {
    update: XOR<pessoaUpdateWithoutEnderecosInput, pessoaUncheckedUpdateWithoutEnderecosInput>
    create: XOR<pessoaCreateWithoutEnderecosInput, pessoaUncheckedCreateWithoutEnderecosInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutEnderecosInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutEnderecosInput, pessoaUncheckedUpdateWithoutEnderecosInput>
  }

  export type pessoaUpdateWithoutEnderecosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutEnderecosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type enderecoUpsertWithoutPessoasInput = {
    update: XOR<enderecoUpdateWithoutPessoasInput, enderecoUncheckedUpdateWithoutPessoasInput>
    create: XOR<enderecoCreateWithoutPessoasInput, enderecoUncheckedCreateWithoutPessoasInput>
    where?: enderecoWhereInput
  }

  export type enderecoUpdateToOneWithWhereWithoutPessoasInput = {
    where?: enderecoWhereInput
    data: XOR<enderecoUpdateWithoutPessoasInput, enderecoUncheckedUpdateWithoutPessoasInput>
  }

  export type enderecoUpdateWithoutPessoasInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    paroquias?: paroquiaUpdateManyWithoutEnderecoNestedInput
    localidade?: localidadeUpdateManyWithoutEnderecoNestedInput
    diocese?: dioceseUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoUncheckedUpdateWithoutPessoasInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    paroquias?: paroquiaUncheckedUpdateManyWithoutEnderecoNestedInput
    localidade?: localidadeUncheckedUpdateManyWithoutEnderecoNestedInput
    diocese?: dioceseUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type pessoaCreateWithoutCasamentosComoMaridoInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutCasamentosComoMaridoInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutCasamentosComoMaridoInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutCasamentosComoMaridoInput, pessoaUncheckedCreateWithoutCasamentosComoMaridoInput>
  }

  export type pessoaCreateWithoutCasamentosComoMulherInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutCasamentosComoMulherInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutCasamentosComoMulherInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutCasamentosComoMulherInput, pessoaUncheckedCreateWithoutCasamentosComoMulherInput>
  }

  export type pessoaUpsertWithoutCasamentosComoMaridoInput = {
    update: XOR<pessoaUpdateWithoutCasamentosComoMaridoInput, pessoaUncheckedUpdateWithoutCasamentosComoMaridoInput>
    create: XOR<pessoaCreateWithoutCasamentosComoMaridoInput, pessoaUncheckedCreateWithoutCasamentosComoMaridoInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutCasamentosComoMaridoInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutCasamentosComoMaridoInput, pessoaUncheckedUpdateWithoutCasamentosComoMaridoInput>
  }

  export type pessoaUpdateWithoutCasamentosComoMaridoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutCasamentosComoMaridoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUpsertWithoutCasamentosComoMulherInput = {
    update: XOR<pessoaUpdateWithoutCasamentosComoMulherInput, pessoaUncheckedUpdateWithoutCasamentosComoMulherInput>
    create: XOR<pessoaCreateWithoutCasamentosComoMulherInput, pessoaUncheckedCreateWithoutCasamentosComoMulherInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutCasamentosComoMulherInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutCasamentosComoMulherInput, pessoaUncheckedUpdateWithoutCasamentosComoMulherInput>
  }

  export type pessoaUpdateWithoutCasamentosComoMulherInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutCasamentosComoMulherInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaCreateWithoutPessoaCarismaInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutPessoaCarismaInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutPessoaCarismaInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutPessoaCarismaInput, pessoaUncheckedCreateWithoutPessoaCarismaInput>
  }

  export type tipoCarismaCreateWithoutPessoaCarismaInput = {
    descricao: string
  }

  export type tipoCarismaUncheckedCreateWithoutPessoaCarismaInput = {
    id?: number
    descricao: string
  }

  export type tipoCarismaCreateOrConnectWithoutPessoaCarismaInput = {
    where: tipoCarismaWhereUniqueInput
    create: XOR<tipoCarismaCreateWithoutPessoaCarismaInput, tipoCarismaUncheckedCreateWithoutPessoaCarismaInput>
  }

  export type pessoaUpsertWithoutPessoaCarismaInput = {
    update: XOR<pessoaUpdateWithoutPessoaCarismaInput, pessoaUncheckedUpdateWithoutPessoaCarismaInput>
    create: XOR<pessoaCreateWithoutPessoaCarismaInput, pessoaUncheckedCreateWithoutPessoaCarismaInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutPessoaCarismaInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutPessoaCarismaInput, pessoaUncheckedUpdateWithoutPessoaCarismaInput>
  }

  export type pessoaUpdateWithoutPessoaCarismaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutPessoaCarismaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type tipoCarismaUpsertWithoutPessoaCarismaInput = {
    update: XOR<tipoCarismaUpdateWithoutPessoaCarismaInput, tipoCarismaUncheckedUpdateWithoutPessoaCarismaInput>
    create: XOR<tipoCarismaCreateWithoutPessoaCarismaInput, tipoCarismaUncheckedCreateWithoutPessoaCarismaInput>
    where?: tipoCarismaWhereInput
  }

  export type tipoCarismaUpdateToOneWithWhereWithoutPessoaCarismaInput = {
    where?: tipoCarismaWhereInput
    data: XOR<tipoCarismaUpdateWithoutPessoaCarismaInput, tipoCarismaUncheckedUpdateWithoutPessoaCarismaInput>
  }

  export type tipoCarismaUpdateWithoutPessoaCarismaInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoCarismaUncheckedUpdateWithoutPessoaCarismaInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaCreateWithoutPassaportesInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutPassaportesInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutPassaportesInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutPassaportesInput, pessoaUncheckedCreateWithoutPassaportesInput>
  }

  export type pessoaUpsertWithoutPassaportesInput = {
    update: XOR<pessoaUpdateWithoutPassaportesInput, pessoaUncheckedUpdateWithoutPassaportesInput>
    create: XOR<pessoaCreateWithoutPassaportesInput, pessoaUncheckedCreateWithoutPassaportesInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutPassaportesInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutPassaportesInput, pessoaUncheckedUpdateWithoutPassaportesInput>
  }

  export type pessoaUpdateWithoutPassaportesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutPassaportesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaCreateWithoutContatosInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutContatosInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutContatosInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutContatosInput, pessoaUncheckedCreateWithoutContatosInput>
  }

  export type pessoaUpsertWithoutContatosInput = {
    update: XOR<pessoaUpdateWithoutContatosInput, pessoaUncheckedUpdateWithoutContatosInput>
    create: XOR<pessoaCreateWithoutContatosInput, pessoaUncheckedCreateWithoutContatosInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutContatosInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutContatosInput, pessoaUncheckedUpdateWithoutContatosInput>
  }

  export type pessoaUpdateWithoutContatosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutContatosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type dioceseCreateWithoutTipoDioceseInput = {
    descricao: string
    endereco: enderecoCreateNestedOneWithoutDioceseInput
    paroquias?: paroquiaCreateNestedManyWithoutDioceseInput
    localidade?: localidadeCreateNestedManyWithoutDioceseInput
  }

  export type dioceseUncheckedCreateWithoutTipoDioceseInput = {
    id?: number
    descricao: string
    enderecoId: number
    paroquias?: paroquiaUncheckedCreateNestedManyWithoutDioceseInput
    localidade?: localidadeUncheckedCreateNestedManyWithoutDioceseInput
  }

  export type dioceseCreateOrConnectWithoutTipoDioceseInput = {
    where: dioceseWhereUniqueInput
    create: XOR<dioceseCreateWithoutTipoDioceseInput, dioceseUncheckedCreateWithoutTipoDioceseInput>
  }

  export type dioceseCreateManyTipoDioceseInputEnvelope = {
    data: dioceseCreateManyTipoDioceseInput | dioceseCreateManyTipoDioceseInput[]
    skipDuplicates?: boolean
  }

  export type dioceseUpsertWithWhereUniqueWithoutTipoDioceseInput = {
    where: dioceseWhereUniqueInput
    update: XOR<dioceseUpdateWithoutTipoDioceseInput, dioceseUncheckedUpdateWithoutTipoDioceseInput>
    create: XOR<dioceseCreateWithoutTipoDioceseInput, dioceseUncheckedCreateWithoutTipoDioceseInput>
  }

  export type dioceseUpdateWithWhereUniqueWithoutTipoDioceseInput = {
    where: dioceseWhereUniqueInput
    data: XOR<dioceseUpdateWithoutTipoDioceseInput, dioceseUncheckedUpdateWithoutTipoDioceseInput>
  }

  export type dioceseUpdateManyWithWhereWithoutTipoDioceseInput = {
    where: dioceseScalarWhereInput
    data: XOR<dioceseUpdateManyMutationInput, dioceseUncheckedUpdateManyWithoutTipoDioceseInput>
  }

  export type tipoDioceseCreateWithoutDiocesesInput = {
    descricao: string
  }

  export type tipoDioceseUncheckedCreateWithoutDiocesesInput = {
    id?: number
    descricao: string
  }

  export type tipoDioceseCreateOrConnectWithoutDiocesesInput = {
    where: tipoDioceseWhereUniqueInput
    create: XOR<tipoDioceseCreateWithoutDiocesesInput, tipoDioceseUncheckedCreateWithoutDiocesesInput>
  }

  export type enderecoCreateWithoutDioceseInput = {
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    paroquias?: paroquiaCreateNestedManyWithoutEnderecoInput
    pessoas?: pessoaEnderecoCreateNestedManyWithoutEnderecoInput
    localidade?: localidadeCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoUncheckedCreateWithoutDioceseInput = {
    id?: number
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    paroquias?: paroquiaUncheckedCreateNestedManyWithoutEnderecoInput
    pessoas?: pessoaEnderecoUncheckedCreateNestedManyWithoutEnderecoInput
    localidade?: localidadeUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoCreateOrConnectWithoutDioceseInput = {
    where: enderecoWhereUniqueInput
    create: XOR<enderecoCreateWithoutDioceseInput, enderecoUncheckedCreateWithoutDioceseInput>
  }

  export type paroquiaCreateWithoutDioceseInput = {
    descricao: string
    endereco: enderecoCreateNestedOneWithoutParoquiasInput
    pessoas?: paroquiaPessoasCreateNestedManyWithoutParoquiaInput
  }

  export type paroquiaUncheckedCreateWithoutDioceseInput = {
    id?: number
    enderecoId: number
    descricao: string
    pessoas?: paroquiaPessoasUncheckedCreateNestedManyWithoutParoquiaInput
  }

  export type paroquiaCreateOrConnectWithoutDioceseInput = {
    where: paroquiaWhereUniqueInput
    create: XOR<paroquiaCreateWithoutDioceseInput, paroquiaUncheckedCreateWithoutDioceseInput>
  }

  export type paroquiaCreateManyDioceseInputEnvelope = {
    data: paroquiaCreateManyDioceseInput | paroquiaCreateManyDioceseInput[]
    skipDuplicates?: boolean
  }

  export type localidadeCreateWithoutDioceseInput = {
    descricao: string
    observacao?: string | null
    tipoLocalidade: tipoLocalidadeCreateNestedOneWithoutLocalidadeInput
    endereco: enderecoCreateNestedOneWithoutLocalidadeInput
    localidadeRegiao?: localidadeRegiaoCreateNestedManyWithoutLocalidadeInput
  }

  export type localidadeUncheckedCreateWithoutDioceseInput = {
    id?: number
    descricao: string
    tipoLocalidadeId: number
    observacao?: string | null
    enderecoId: number
    localidadeRegiao?: localidadeRegiaoUncheckedCreateNestedManyWithoutLocalidadeInput
  }

  export type localidadeCreateOrConnectWithoutDioceseInput = {
    where: localidadeWhereUniqueInput
    create: XOR<localidadeCreateWithoutDioceseInput, localidadeUncheckedCreateWithoutDioceseInput>
  }

  export type localidadeCreateManyDioceseInputEnvelope = {
    data: localidadeCreateManyDioceseInput | localidadeCreateManyDioceseInput[]
    skipDuplicates?: boolean
  }

  export type tipoDioceseUpsertWithoutDiocesesInput = {
    update: XOR<tipoDioceseUpdateWithoutDiocesesInput, tipoDioceseUncheckedUpdateWithoutDiocesesInput>
    create: XOR<tipoDioceseCreateWithoutDiocesesInput, tipoDioceseUncheckedCreateWithoutDiocesesInput>
    where?: tipoDioceseWhereInput
  }

  export type tipoDioceseUpdateToOneWithWhereWithoutDiocesesInput = {
    where?: tipoDioceseWhereInput
    data: XOR<tipoDioceseUpdateWithoutDiocesesInput, tipoDioceseUncheckedUpdateWithoutDiocesesInput>
  }

  export type tipoDioceseUpdateWithoutDiocesesInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoDioceseUncheckedUpdateWithoutDiocesesInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type enderecoUpsertWithoutDioceseInput = {
    update: XOR<enderecoUpdateWithoutDioceseInput, enderecoUncheckedUpdateWithoutDioceseInput>
    create: XOR<enderecoCreateWithoutDioceseInput, enderecoUncheckedCreateWithoutDioceseInput>
    where?: enderecoWhereInput
  }

  export type enderecoUpdateToOneWithWhereWithoutDioceseInput = {
    where?: enderecoWhereInput
    data: XOR<enderecoUpdateWithoutDioceseInput, enderecoUncheckedUpdateWithoutDioceseInput>
  }

  export type enderecoUpdateWithoutDioceseInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    paroquias?: paroquiaUpdateManyWithoutEnderecoNestedInput
    pessoas?: pessoaEnderecoUpdateManyWithoutEnderecoNestedInput
    localidade?: localidadeUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoUncheckedUpdateWithoutDioceseInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    paroquias?: paroquiaUncheckedUpdateManyWithoutEnderecoNestedInput
    pessoas?: pessoaEnderecoUncheckedUpdateManyWithoutEnderecoNestedInput
    localidade?: localidadeUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type paroquiaUpsertWithWhereUniqueWithoutDioceseInput = {
    where: paroquiaWhereUniqueInput
    update: XOR<paroquiaUpdateWithoutDioceseInput, paroquiaUncheckedUpdateWithoutDioceseInput>
    create: XOR<paroquiaCreateWithoutDioceseInput, paroquiaUncheckedCreateWithoutDioceseInput>
  }

  export type paroquiaUpdateWithWhereUniqueWithoutDioceseInput = {
    where: paroquiaWhereUniqueInput
    data: XOR<paroquiaUpdateWithoutDioceseInput, paroquiaUncheckedUpdateWithoutDioceseInput>
  }

  export type paroquiaUpdateManyWithWhereWithoutDioceseInput = {
    where: paroquiaScalarWhereInput
    data: XOR<paroquiaUpdateManyMutationInput, paroquiaUncheckedUpdateManyWithoutDioceseInput>
  }

  export type localidadeUpsertWithWhereUniqueWithoutDioceseInput = {
    where: localidadeWhereUniqueInput
    update: XOR<localidadeUpdateWithoutDioceseInput, localidadeUncheckedUpdateWithoutDioceseInput>
    create: XOR<localidadeCreateWithoutDioceseInput, localidadeUncheckedCreateWithoutDioceseInput>
  }

  export type localidadeUpdateWithWhereUniqueWithoutDioceseInput = {
    where: localidadeWhereUniqueInput
    data: XOR<localidadeUpdateWithoutDioceseInput, localidadeUncheckedUpdateWithoutDioceseInput>
  }

  export type localidadeUpdateManyWithWhereWithoutDioceseInput = {
    where: localidadeScalarWhereInput
    data: XOR<localidadeUpdateManyMutationInput, localidadeUncheckedUpdateManyWithoutDioceseInput>
  }

  export type enderecoCreateWithoutParoquiasInput = {
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    pessoas?: pessoaEnderecoCreateNestedManyWithoutEnderecoInput
    localidade?: localidadeCreateNestedManyWithoutEnderecoInput
    diocese?: dioceseCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoUncheckedCreateWithoutParoquiasInput = {
    id?: number
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    pessoas?: pessoaEnderecoUncheckedCreateNestedManyWithoutEnderecoInput
    localidade?: localidadeUncheckedCreateNestedManyWithoutEnderecoInput
    diocese?: dioceseUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoCreateOrConnectWithoutParoquiasInput = {
    where: enderecoWhereUniqueInput
    create: XOR<enderecoCreateWithoutParoquiasInput, enderecoUncheckedCreateWithoutParoquiasInput>
  }

  export type dioceseCreateWithoutParoquiasInput = {
    descricao: string
    tipoDiocese: tipoDioceseCreateNestedOneWithoutDiocesesInput
    endereco: enderecoCreateNestedOneWithoutDioceseInput
    localidade?: localidadeCreateNestedManyWithoutDioceseInput
  }

  export type dioceseUncheckedCreateWithoutParoquiasInput = {
    id?: number
    tipoDioceseId: number
    descricao: string
    enderecoId: number
    localidade?: localidadeUncheckedCreateNestedManyWithoutDioceseInput
  }

  export type dioceseCreateOrConnectWithoutParoquiasInput = {
    where: dioceseWhereUniqueInput
    create: XOR<dioceseCreateWithoutParoquiasInput, dioceseUncheckedCreateWithoutParoquiasInput>
  }

  export type paroquiaPessoasCreateWithoutParoquiaInput = {
    pessoa: pessoaCreateNestedOneWithoutParoquiasInput
  }

  export type paroquiaPessoasUncheckedCreateWithoutParoquiaInput = {
    pessoaId: number
  }

  export type paroquiaPessoasCreateOrConnectWithoutParoquiaInput = {
    where: paroquiaPessoasWhereUniqueInput
    create: XOR<paroquiaPessoasCreateWithoutParoquiaInput, paroquiaPessoasUncheckedCreateWithoutParoquiaInput>
  }

  export type paroquiaPessoasCreateManyParoquiaInputEnvelope = {
    data: paroquiaPessoasCreateManyParoquiaInput | paroquiaPessoasCreateManyParoquiaInput[]
    skipDuplicates?: boolean
  }

  export type enderecoUpsertWithoutParoquiasInput = {
    update: XOR<enderecoUpdateWithoutParoquiasInput, enderecoUncheckedUpdateWithoutParoquiasInput>
    create: XOR<enderecoCreateWithoutParoquiasInput, enderecoUncheckedCreateWithoutParoquiasInput>
    where?: enderecoWhereInput
  }

  export type enderecoUpdateToOneWithWhereWithoutParoquiasInput = {
    where?: enderecoWhereInput
    data: XOR<enderecoUpdateWithoutParoquiasInput, enderecoUncheckedUpdateWithoutParoquiasInput>
  }

  export type enderecoUpdateWithoutParoquiasInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    pessoas?: pessoaEnderecoUpdateManyWithoutEnderecoNestedInput
    localidade?: localidadeUpdateManyWithoutEnderecoNestedInput
    diocese?: dioceseUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoUncheckedUpdateWithoutParoquiasInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    pessoas?: pessoaEnderecoUncheckedUpdateManyWithoutEnderecoNestedInput
    localidade?: localidadeUncheckedUpdateManyWithoutEnderecoNestedInput
    diocese?: dioceseUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type dioceseUpsertWithoutParoquiasInput = {
    update: XOR<dioceseUpdateWithoutParoquiasInput, dioceseUncheckedUpdateWithoutParoquiasInput>
    create: XOR<dioceseCreateWithoutParoquiasInput, dioceseUncheckedCreateWithoutParoquiasInput>
    where?: dioceseWhereInput
  }

  export type dioceseUpdateToOneWithWhereWithoutParoquiasInput = {
    where?: dioceseWhereInput
    data: XOR<dioceseUpdateWithoutParoquiasInput, dioceseUncheckedUpdateWithoutParoquiasInput>
  }

  export type dioceseUpdateWithoutParoquiasInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    tipoDiocese?: tipoDioceseUpdateOneRequiredWithoutDiocesesNestedInput
    endereco?: enderecoUpdateOneRequiredWithoutDioceseNestedInput
    localidade?: localidadeUpdateManyWithoutDioceseNestedInput
  }

  export type dioceseUncheckedUpdateWithoutParoquiasInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoDioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    enderecoId?: IntFieldUpdateOperationsInput | number
    localidade?: localidadeUncheckedUpdateManyWithoutDioceseNestedInput
  }

  export type paroquiaPessoasUpsertWithWhereUniqueWithoutParoquiaInput = {
    where: paroquiaPessoasWhereUniqueInput
    update: XOR<paroquiaPessoasUpdateWithoutParoquiaInput, paroquiaPessoasUncheckedUpdateWithoutParoquiaInput>
    create: XOR<paroquiaPessoasCreateWithoutParoquiaInput, paroquiaPessoasUncheckedCreateWithoutParoquiaInput>
  }

  export type paroquiaPessoasUpdateWithWhereUniqueWithoutParoquiaInput = {
    where: paroquiaPessoasWhereUniqueInput
    data: XOR<paroquiaPessoasUpdateWithoutParoquiaInput, paroquiaPessoasUncheckedUpdateWithoutParoquiaInput>
  }

  export type paroquiaPessoasUpdateManyWithWhereWithoutParoquiaInput = {
    where: paroquiaPessoasScalarWhereInput
    data: XOR<paroquiaPessoasUpdateManyMutationInput, paroquiaPessoasUncheckedUpdateManyWithoutParoquiaInput>
  }

  export type pessoaCreateWithoutParoquiasInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutParoquiasInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    equipes?: equipePessoasUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutParoquiasInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutParoquiasInput, pessoaUncheckedCreateWithoutParoquiasInput>
  }

  export type paroquiaCreateWithoutPessoasInput = {
    descricao: string
    endereco: enderecoCreateNestedOneWithoutParoquiasInput
    diocese: dioceseCreateNestedOneWithoutParoquiasInput
  }

  export type paroquiaUncheckedCreateWithoutPessoasInput = {
    id?: number
    enderecoId: number
    dioceseId: number
    descricao: string
  }

  export type paroquiaCreateOrConnectWithoutPessoasInput = {
    where: paroquiaWhereUniqueInput
    create: XOR<paroquiaCreateWithoutPessoasInput, paroquiaUncheckedCreateWithoutPessoasInput>
  }

  export type pessoaUpsertWithoutParoquiasInput = {
    update: XOR<pessoaUpdateWithoutParoquiasInput, pessoaUncheckedUpdateWithoutParoquiasInput>
    create: XOR<pessoaCreateWithoutParoquiasInput, pessoaUncheckedCreateWithoutParoquiasInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutParoquiasInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutParoquiasInput, pessoaUncheckedUpdateWithoutParoquiasInput>
  }

  export type pessoaUpdateWithoutParoquiasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutParoquiasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type paroquiaUpsertWithoutPessoasInput = {
    update: XOR<paroquiaUpdateWithoutPessoasInput, paroquiaUncheckedUpdateWithoutPessoasInput>
    create: XOR<paroquiaCreateWithoutPessoasInput, paroquiaUncheckedCreateWithoutPessoasInput>
    where?: paroquiaWhereInput
  }

  export type paroquiaUpdateToOneWithWhereWithoutPessoasInput = {
    where?: paroquiaWhereInput
    data: XOR<paroquiaUpdateWithoutPessoasInput, paroquiaUncheckedUpdateWithoutPessoasInput>
  }

  export type paroquiaUpdateWithoutPessoasInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    endereco?: enderecoUpdateOneRequiredWithoutParoquiasNestedInput
    diocese?: dioceseUpdateOneRequiredWithoutParoquiasNestedInput
  }

  export type paroquiaUncheckedUpdateWithoutPessoasInput = {
    id?: IntFieldUpdateOperationsInput | number
    enderecoId?: IntFieldUpdateOperationsInput | number
    dioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type equipeRegiaoCreateWithoutRegiaoInput = {
    equipe: equipeCreateNestedOneWithoutRegioesInput
  }

  export type equipeRegiaoUncheckedCreateWithoutRegiaoInput = {
    equipeId: number
  }

  export type equipeRegiaoCreateOrConnectWithoutRegiaoInput = {
    where: equipeRegiaoWhereUniqueInput
    create: XOR<equipeRegiaoCreateWithoutRegiaoInput, equipeRegiaoUncheckedCreateWithoutRegiaoInput>
  }

  export type equipeRegiaoCreateManyRegiaoInputEnvelope = {
    data: equipeRegiaoCreateManyRegiaoInput | equipeRegiaoCreateManyRegiaoInput[]
    skipDuplicates?: boolean
  }

  export type localidadeRegiaoCreateWithoutRegiaoInput = {
    localidade: localidadeCreateNestedOneWithoutLocalidadeRegiaoInput
  }

  export type localidadeRegiaoUncheckedCreateWithoutRegiaoInput = {
    localidadeId: number
  }

  export type localidadeRegiaoCreateOrConnectWithoutRegiaoInput = {
    where: localidadeRegiaoWhereUniqueInput
    create: XOR<localidadeRegiaoCreateWithoutRegiaoInput, localidadeRegiaoUncheckedCreateWithoutRegiaoInput>
  }

  export type localidadeRegiaoCreateManyRegiaoInputEnvelope = {
    data: localidadeRegiaoCreateManyRegiaoInput | localidadeRegiaoCreateManyRegiaoInput[]
    skipDuplicates?: boolean
  }

  export type equipeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput = {
    where: equipeRegiaoWhereUniqueInput
    update: XOR<equipeRegiaoUpdateWithoutRegiaoInput, equipeRegiaoUncheckedUpdateWithoutRegiaoInput>
    create: XOR<equipeRegiaoCreateWithoutRegiaoInput, equipeRegiaoUncheckedCreateWithoutRegiaoInput>
  }

  export type equipeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput = {
    where: equipeRegiaoWhereUniqueInput
    data: XOR<equipeRegiaoUpdateWithoutRegiaoInput, equipeRegiaoUncheckedUpdateWithoutRegiaoInput>
  }

  export type equipeRegiaoUpdateManyWithWhereWithoutRegiaoInput = {
    where: equipeRegiaoScalarWhereInput
    data: XOR<equipeRegiaoUpdateManyMutationInput, equipeRegiaoUncheckedUpdateManyWithoutRegiaoInput>
  }

  export type equipeRegiaoScalarWhereInput = {
    AND?: equipeRegiaoScalarWhereInput | equipeRegiaoScalarWhereInput[]
    OR?: equipeRegiaoScalarWhereInput[]
    NOT?: equipeRegiaoScalarWhereInput | equipeRegiaoScalarWhereInput[]
    equipeId?: IntFilter<"equipeRegiao"> | number
    regiaoId?: IntFilter<"equipeRegiao"> | number
  }

  export type localidadeRegiaoUpsertWithWhereUniqueWithoutRegiaoInput = {
    where: localidadeRegiaoWhereUniqueInput
    update: XOR<localidadeRegiaoUpdateWithoutRegiaoInput, localidadeRegiaoUncheckedUpdateWithoutRegiaoInput>
    create: XOR<localidadeRegiaoCreateWithoutRegiaoInput, localidadeRegiaoUncheckedCreateWithoutRegiaoInput>
  }

  export type localidadeRegiaoUpdateWithWhereUniqueWithoutRegiaoInput = {
    where: localidadeRegiaoWhereUniqueInput
    data: XOR<localidadeRegiaoUpdateWithoutRegiaoInput, localidadeRegiaoUncheckedUpdateWithoutRegiaoInput>
  }

  export type localidadeRegiaoUpdateManyWithWhereWithoutRegiaoInput = {
    where: localidadeRegiaoScalarWhereInput
    data: XOR<localidadeRegiaoUpdateManyMutationInput, localidadeRegiaoUncheckedUpdateManyWithoutRegiaoInput>
  }

  export type localidadeRegiaoScalarWhereInput = {
    AND?: localidadeRegiaoScalarWhereInput | localidadeRegiaoScalarWhereInput[]
    OR?: localidadeRegiaoScalarWhereInput[]
    NOT?: localidadeRegiaoScalarWhereInput | localidadeRegiaoScalarWhereInput[]
    localidadeId?: IntFilter<"localidadeRegiao"> | number
    regiaoId?: IntFilter<"localidadeRegiao"> | number
  }

  export type equipeTipoEquipeCreateWithoutTipoEquipeInput = {
    equipe: equipeCreateNestedOneWithoutTiposInput
  }

  export type equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput = {
    equipeId: number
  }

  export type equipeTipoEquipeCreateOrConnectWithoutTipoEquipeInput = {
    where: equipeTipoEquipeWhereUniqueInput
    create: XOR<equipeTipoEquipeCreateWithoutTipoEquipeInput, equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput>
  }

  export type equipeTipoEquipeCreateManyTipoEquipeInputEnvelope = {
    data: equipeTipoEquipeCreateManyTipoEquipeInput | equipeTipoEquipeCreateManyTipoEquipeInput[]
    skipDuplicates?: boolean
  }

  export type equipeTipoEquipeUpsertWithWhereUniqueWithoutTipoEquipeInput = {
    where: equipeTipoEquipeWhereUniqueInput
    update: XOR<equipeTipoEquipeUpdateWithoutTipoEquipeInput, equipeTipoEquipeUncheckedUpdateWithoutTipoEquipeInput>
    create: XOR<equipeTipoEquipeCreateWithoutTipoEquipeInput, equipeTipoEquipeUncheckedCreateWithoutTipoEquipeInput>
  }

  export type equipeTipoEquipeUpdateWithWhereUniqueWithoutTipoEquipeInput = {
    where: equipeTipoEquipeWhereUniqueInput
    data: XOR<equipeTipoEquipeUpdateWithoutTipoEquipeInput, equipeTipoEquipeUncheckedUpdateWithoutTipoEquipeInput>
  }

  export type equipeTipoEquipeUpdateManyWithWhereWithoutTipoEquipeInput = {
    where: equipeTipoEquipeScalarWhereInput
    data: XOR<equipeTipoEquipeUpdateManyMutationInput, equipeTipoEquipeUncheckedUpdateManyWithoutTipoEquipeInput>
  }

  export type equipeTipoEquipeScalarWhereInput = {
    AND?: equipeTipoEquipeScalarWhereInput | equipeTipoEquipeScalarWhereInput[]
    OR?: equipeTipoEquipeScalarWhereInput[]
    NOT?: equipeTipoEquipeScalarWhereInput | equipeTipoEquipeScalarWhereInput[]
    equipeId?: IntFilter<"equipeTipoEquipe"> | number
    tipoEquipeId?: IntFilter<"equipeTipoEquipe"> | number
  }

  export type equipeRegiaoCreateWithoutEquipeInput = {
    regiao: regiaoCreateNestedOneWithoutEquipesInput
  }

  export type equipeRegiaoUncheckedCreateWithoutEquipeInput = {
    regiaoId: number
  }

  export type equipeRegiaoCreateOrConnectWithoutEquipeInput = {
    where: equipeRegiaoWhereUniqueInput
    create: XOR<equipeRegiaoCreateWithoutEquipeInput, equipeRegiaoUncheckedCreateWithoutEquipeInput>
  }

  export type equipeRegiaoCreateManyEquipeInputEnvelope = {
    data: equipeRegiaoCreateManyEquipeInput | equipeRegiaoCreateManyEquipeInput[]
    skipDuplicates?: boolean
  }

  export type equipePessoasCreateWithoutEquipeInput = {
    pessoa: pessoaCreateNestedOneWithoutEquipesInput
  }

  export type equipePessoasUncheckedCreateWithoutEquipeInput = {
    pessoaId: number
  }

  export type equipePessoasCreateOrConnectWithoutEquipeInput = {
    where: equipePessoasWhereUniqueInput
    create: XOR<equipePessoasCreateWithoutEquipeInput, equipePessoasUncheckedCreateWithoutEquipeInput>
  }

  export type equipePessoasCreateManyEquipeInputEnvelope = {
    data: equipePessoasCreateManyEquipeInput | equipePessoasCreateManyEquipeInput[]
    skipDuplicates?: boolean
  }

  export type equipeTipoEquipeCreateWithoutEquipeInput = {
    tipoEquipe: tipoEquipeCreateNestedOneWithoutEquipesInput
  }

  export type equipeTipoEquipeUncheckedCreateWithoutEquipeInput = {
    tipoEquipeId: number
  }

  export type equipeTipoEquipeCreateOrConnectWithoutEquipeInput = {
    where: equipeTipoEquipeWhereUniqueInput
    create: XOR<equipeTipoEquipeCreateWithoutEquipeInput, equipeTipoEquipeUncheckedCreateWithoutEquipeInput>
  }

  export type equipeTipoEquipeCreateManyEquipeInputEnvelope = {
    data: equipeTipoEquipeCreateManyEquipeInput | equipeTipoEquipeCreateManyEquipeInput[]
    skipDuplicates?: boolean
  }

  export type equipeRegiaoUpsertWithWhereUniqueWithoutEquipeInput = {
    where: equipeRegiaoWhereUniqueInput
    update: XOR<equipeRegiaoUpdateWithoutEquipeInput, equipeRegiaoUncheckedUpdateWithoutEquipeInput>
    create: XOR<equipeRegiaoCreateWithoutEquipeInput, equipeRegiaoUncheckedCreateWithoutEquipeInput>
  }

  export type equipeRegiaoUpdateWithWhereUniqueWithoutEquipeInput = {
    where: equipeRegiaoWhereUniqueInput
    data: XOR<equipeRegiaoUpdateWithoutEquipeInput, equipeRegiaoUncheckedUpdateWithoutEquipeInput>
  }

  export type equipeRegiaoUpdateManyWithWhereWithoutEquipeInput = {
    where: equipeRegiaoScalarWhereInput
    data: XOR<equipeRegiaoUpdateManyMutationInput, equipeRegiaoUncheckedUpdateManyWithoutEquipeInput>
  }

  export type equipePessoasUpsertWithWhereUniqueWithoutEquipeInput = {
    where: equipePessoasWhereUniqueInput
    update: XOR<equipePessoasUpdateWithoutEquipeInput, equipePessoasUncheckedUpdateWithoutEquipeInput>
    create: XOR<equipePessoasCreateWithoutEquipeInput, equipePessoasUncheckedCreateWithoutEquipeInput>
  }

  export type equipePessoasUpdateWithWhereUniqueWithoutEquipeInput = {
    where: equipePessoasWhereUniqueInput
    data: XOR<equipePessoasUpdateWithoutEquipeInput, equipePessoasUncheckedUpdateWithoutEquipeInput>
  }

  export type equipePessoasUpdateManyWithWhereWithoutEquipeInput = {
    where: equipePessoasScalarWhereInput
    data: XOR<equipePessoasUpdateManyMutationInput, equipePessoasUncheckedUpdateManyWithoutEquipeInput>
  }

  export type equipeTipoEquipeUpsertWithWhereUniqueWithoutEquipeInput = {
    where: equipeTipoEquipeWhereUniqueInput
    update: XOR<equipeTipoEquipeUpdateWithoutEquipeInput, equipeTipoEquipeUncheckedUpdateWithoutEquipeInput>
    create: XOR<equipeTipoEquipeCreateWithoutEquipeInput, equipeTipoEquipeUncheckedCreateWithoutEquipeInput>
  }

  export type equipeTipoEquipeUpdateWithWhereUniqueWithoutEquipeInput = {
    where: equipeTipoEquipeWhereUniqueInput
    data: XOR<equipeTipoEquipeUpdateWithoutEquipeInput, equipeTipoEquipeUncheckedUpdateWithoutEquipeInput>
  }

  export type equipeTipoEquipeUpdateManyWithWhereWithoutEquipeInput = {
    where: equipeTipoEquipeScalarWhereInput
    data: XOR<equipeTipoEquipeUpdateManyMutationInput, equipeTipoEquipeUncheckedUpdateManyWithoutEquipeInput>
  }

  export type equipeCreateWithoutTiposInput = {
    descricao: string
    regioes?: equipeRegiaoCreateNestedManyWithoutEquipeInput
    equipePessoas?: equipePessoasCreateNestedManyWithoutEquipeInput
  }

  export type equipeUncheckedCreateWithoutTiposInput = {
    id?: number
    descricao: string
    regioes?: equipeRegiaoUncheckedCreateNestedManyWithoutEquipeInput
    equipePessoas?: equipePessoasUncheckedCreateNestedManyWithoutEquipeInput
  }

  export type equipeCreateOrConnectWithoutTiposInput = {
    where: equipeWhereUniqueInput
    create: XOR<equipeCreateWithoutTiposInput, equipeUncheckedCreateWithoutTiposInput>
  }

  export type tipoEquipeCreateWithoutEquipesInput = {
    descricao: string
  }

  export type tipoEquipeUncheckedCreateWithoutEquipesInput = {
    id?: number
    descricao: string
  }

  export type tipoEquipeCreateOrConnectWithoutEquipesInput = {
    where: tipoEquipeWhereUniqueInput
    create: XOR<tipoEquipeCreateWithoutEquipesInput, tipoEquipeUncheckedCreateWithoutEquipesInput>
  }

  export type equipeUpsertWithoutTiposInput = {
    update: XOR<equipeUpdateWithoutTiposInput, equipeUncheckedUpdateWithoutTiposInput>
    create: XOR<equipeCreateWithoutTiposInput, equipeUncheckedCreateWithoutTiposInput>
    where?: equipeWhereInput
  }

  export type equipeUpdateToOneWithWhereWithoutTiposInput = {
    where?: equipeWhereInput
    data: XOR<equipeUpdateWithoutTiposInput, equipeUncheckedUpdateWithoutTiposInput>
  }

  export type equipeUpdateWithoutTiposInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    regioes?: equipeRegiaoUpdateManyWithoutEquipeNestedInput
    equipePessoas?: equipePessoasUpdateManyWithoutEquipeNestedInput
  }

  export type equipeUncheckedUpdateWithoutTiposInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    regioes?: equipeRegiaoUncheckedUpdateManyWithoutEquipeNestedInput
    equipePessoas?: equipePessoasUncheckedUpdateManyWithoutEquipeNestedInput
  }

  export type tipoEquipeUpsertWithoutEquipesInput = {
    update: XOR<tipoEquipeUpdateWithoutEquipesInput, tipoEquipeUncheckedUpdateWithoutEquipesInput>
    create: XOR<tipoEquipeCreateWithoutEquipesInput, tipoEquipeUncheckedCreateWithoutEquipesInput>
    where?: tipoEquipeWhereInput
  }

  export type tipoEquipeUpdateToOneWithWhereWithoutEquipesInput = {
    where?: tipoEquipeWhereInput
    data: XOR<tipoEquipeUpdateWithoutEquipesInput, tipoEquipeUncheckedUpdateWithoutEquipesInput>
  }

  export type tipoEquipeUpdateWithoutEquipesInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoEquipeUncheckedUpdateWithoutEquipesInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type equipeCreateWithoutRegioesInput = {
    descricao: string
    equipePessoas?: equipePessoasCreateNestedManyWithoutEquipeInput
    tipos?: equipeTipoEquipeCreateNestedManyWithoutEquipeInput
  }

  export type equipeUncheckedCreateWithoutRegioesInput = {
    id?: number
    descricao: string
    equipePessoas?: equipePessoasUncheckedCreateNestedManyWithoutEquipeInput
    tipos?: equipeTipoEquipeUncheckedCreateNestedManyWithoutEquipeInput
  }

  export type equipeCreateOrConnectWithoutRegioesInput = {
    where: equipeWhereUniqueInput
    create: XOR<equipeCreateWithoutRegioesInput, equipeUncheckedCreateWithoutRegioesInput>
  }

  export type regiaoCreateWithoutEquipesInput = {
    descricao: string
    macroRegiao?: boolean
    localidadeRegiao?: localidadeRegiaoCreateNestedManyWithoutRegiaoInput
  }

  export type regiaoUncheckedCreateWithoutEquipesInput = {
    id?: number
    descricao: string
    macroRegiao?: boolean
    localidadeRegiao?: localidadeRegiaoUncheckedCreateNestedManyWithoutRegiaoInput
  }

  export type regiaoCreateOrConnectWithoutEquipesInput = {
    where: regiaoWhereUniqueInput
    create: XOR<regiaoCreateWithoutEquipesInput, regiaoUncheckedCreateWithoutEquipesInput>
  }

  export type equipeUpsertWithoutRegioesInput = {
    update: XOR<equipeUpdateWithoutRegioesInput, equipeUncheckedUpdateWithoutRegioesInput>
    create: XOR<equipeCreateWithoutRegioesInput, equipeUncheckedCreateWithoutRegioesInput>
    where?: equipeWhereInput
  }

  export type equipeUpdateToOneWithWhereWithoutRegioesInput = {
    where?: equipeWhereInput
    data: XOR<equipeUpdateWithoutRegioesInput, equipeUncheckedUpdateWithoutRegioesInput>
  }

  export type equipeUpdateWithoutRegioesInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    equipePessoas?: equipePessoasUpdateManyWithoutEquipeNestedInput
    tipos?: equipeTipoEquipeUpdateManyWithoutEquipeNestedInput
  }

  export type equipeUncheckedUpdateWithoutRegioesInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    equipePessoas?: equipePessoasUncheckedUpdateManyWithoutEquipeNestedInput
    tipos?: equipeTipoEquipeUncheckedUpdateManyWithoutEquipeNestedInput
  }

  export type regiaoUpsertWithoutEquipesInput = {
    update: XOR<regiaoUpdateWithoutEquipesInput, regiaoUncheckedUpdateWithoutEquipesInput>
    create: XOR<regiaoCreateWithoutEquipesInput, regiaoUncheckedCreateWithoutEquipesInput>
    where?: regiaoWhereInput
  }

  export type regiaoUpdateToOneWithWhereWithoutEquipesInput = {
    where?: regiaoWhereInput
    data: XOR<regiaoUpdateWithoutEquipesInput, regiaoUncheckedUpdateWithoutEquipesInput>
  }

  export type regiaoUpdateWithoutEquipesInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    macroRegiao?: BoolFieldUpdateOperationsInput | boolean
    localidadeRegiao?: localidadeRegiaoUpdateManyWithoutRegiaoNestedInput
  }

  export type regiaoUncheckedUpdateWithoutEquipesInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    macroRegiao?: BoolFieldUpdateOperationsInput | boolean
    localidadeRegiao?: localidadeRegiaoUncheckedUpdateManyWithoutRegiaoNestedInput
  }

  export type equipeCreateWithoutEquipePessoasInput = {
    descricao: string
    regioes?: equipeRegiaoCreateNestedManyWithoutEquipeInput
    tipos?: equipeTipoEquipeCreateNestedManyWithoutEquipeInput
  }

  export type equipeUncheckedCreateWithoutEquipePessoasInput = {
    id?: number
    descricao: string
    regioes?: equipeRegiaoUncheckedCreateNestedManyWithoutEquipeInput
    tipos?: equipeTipoEquipeUncheckedCreateNestedManyWithoutEquipeInput
  }

  export type equipeCreateOrConnectWithoutEquipePessoasInput = {
    where: equipeWhereUniqueInput
    create: XOR<equipeCreateWithoutEquipePessoasInput, equipeUncheckedCreateWithoutEquipePessoasInput>
  }

  export type pessoaCreateWithoutEquipesInput = {
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    ativo?: boolean
    estadoCivil: estadoCivilCreateNestedOneWithoutPessoasInput
    escolaridade?: escolaridadeCreateNestedOneWithoutPessoasInput
    tipoPessoa?: tipoPessoaCreateNestedOneWithoutPessoaInput
    passaportes?: passaportePessoaCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaCreateNestedManyWithoutPessoaInput
  }

  export type pessoaUncheckedCreateWithoutEquipesInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
    passaportes?: passaportePessoaUncheckedCreateNestedManyWithoutPessoaInput
    contatos?: pessoaContatoUncheckedCreateNestedManyWithoutPessoaInput
    paroquias?: paroquiaPessoasUncheckedCreateNestedManyWithoutPessoaInput
    casamentosComoMarido?: pessoaCasalUncheckedCreateNestedManyWithoutMaridoInput
    casamentosComoMulher?: pessoaCasalUncheckedCreateNestedManyWithoutMulherInput
    enderecos?: pessoaEnderecoUncheckedCreateNestedManyWithoutPessoaInput
    pessoaCarisma?: pessoaCarismaUncheckedCreateNestedManyWithoutPessoaInput
  }

  export type pessoaCreateOrConnectWithoutEquipesInput = {
    where: pessoaWhereUniqueInput
    create: XOR<pessoaCreateWithoutEquipesInput, pessoaUncheckedCreateWithoutEquipesInput>
  }

  export type equipeUpsertWithoutEquipePessoasInput = {
    update: XOR<equipeUpdateWithoutEquipePessoasInput, equipeUncheckedUpdateWithoutEquipePessoasInput>
    create: XOR<equipeCreateWithoutEquipePessoasInput, equipeUncheckedCreateWithoutEquipePessoasInput>
    where?: equipeWhereInput
  }

  export type equipeUpdateToOneWithWhereWithoutEquipePessoasInput = {
    where?: equipeWhereInput
    data: XOR<equipeUpdateWithoutEquipePessoasInput, equipeUncheckedUpdateWithoutEquipePessoasInput>
  }

  export type equipeUpdateWithoutEquipePessoasInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    regioes?: equipeRegiaoUpdateManyWithoutEquipeNestedInput
    tipos?: equipeTipoEquipeUpdateManyWithoutEquipeNestedInput
  }

  export type equipeUncheckedUpdateWithoutEquipePessoasInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    regioes?: equipeRegiaoUncheckedUpdateManyWithoutEquipeNestedInput
    tipos?: equipeTipoEquipeUncheckedUpdateManyWithoutEquipeNestedInput
  }

  export type pessoaUpsertWithoutEquipesInput = {
    update: XOR<pessoaUpdateWithoutEquipesInput, pessoaUncheckedUpdateWithoutEquipesInput>
    create: XOR<pessoaCreateWithoutEquipesInput, pessoaUncheckedCreateWithoutEquipesInput>
    where?: pessoaWhereInput
  }

  export type pessoaUpdateToOneWithWhereWithoutEquipesInput = {
    where?: pessoaWhereInput
    data: XOR<pessoaUpdateWithoutEquipesInput, pessoaUncheckedUpdateWithoutEquipesInput>
  }

  export type pessoaUpdateWithoutEquipesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutEquipesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type dioceseCreateWithoutLocalidadeInput = {
    descricao: string
    tipoDiocese: tipoDioceseCreateNestedOneWithoutDiocesesInput
    endereco: enderecoCreateNestedOneWithoutDioceseInput
    paroquias?: paroquiaCreateNestedManyWithoutDioceseInput
  }

  export type dioceseUncheckedCreateWithoutLocalidadeInput = {
    id?: number
    tipoDioceseId: number
    descricao: string
    enderecoId: number
    paroquias?: paroquiaUncheckedCreateNestedManyWithoutDioceseInput
  }

  export type dioceseCreateOrConnectWithoutLocalidadeInput = {
    where: dioceseWhereUniqueInput
    create: XOR<dioceseCreateWithoutLocalidadeInput, dioceseUncheckedCreateWithoutLocalidadeInput>
  }

  export type tipoLocalidadeCreateWithoutLocalidadeInput = {
    descricao: string
  }

  export type tipoLocalidadeUncheckedCreateWithoutLocalidadeInput = {
    id?: number
    descricao: string
  }

  export type tipoLocalidadeCreateOrConnectWithoutLocalidadeInput = {
    where: tipoLocalidadeWhereUniqueInput
    create: XOR<tipoLocalidadeCreateWithoutLocalidadeInput, tipoLocalidadeUncheckedCreateWithoutLocalidadeInput>
  }

  export type enderecoCreateWithoutLocalidadeInput = {
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    paroquias?: paroquiaCreateNestedManyWithoutEnderecoInput
    pessoas?: pessoaEnderecoCreateNestedManyWithoutEnderecoInput
    diocese?: dioceseCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoUncheckedCreateWithoutLocalidadeInput = {
    id?: number
    cep: string
    logradouro: string
    cidade: string
    bairro: string
    numero: string
    UF: string
    pais?: string
    observacao?: string | null
    paroquias?: paroquiaUncheckedCreateNestedManyWithoutEnderecoInput
    pessoas?: pessoaEnderecoUncheckedCreateNestedManyWithoutEnderecoInput
    diocese?: dioceseUncheckedCreateNestedManyWithoutEnderecoInput
  }

  export type enderecoCreateOrConnectWithoutLocalidadeInput = {
    where: enderecoWhereUniqueInput
    create: XOR<enderecoCreateWithoutLocalidadeInput, enderecoUncheckedCreateWithoutLocalidadeInput>
  }

  export type localidadeRegiaoCreateWithoutLocalidadeInput = {
    regiao: regiaoCreateNestedOneWithoutLocalidadeRegiaoInput
  }

  export type localidadeRegiaoUncheckedCreateWithoutLocalidadeInput = {
    regiaoId: number
  }

  export type localidadeRegiaoCreateOrConnectWithoutLocalidadeInput = {
    where: localidadeRegiaoWhereUniqueInput
    create: XOR<localidadeRegiaoCreateWithoutLocalidadeInput, localidadeRegiaoUncheckedCreateWithoutLocalidadeInput>
  }

  export type localidadeRegiaoCreateManyLocalidadeInputEnvelope = {
    data: localidadeRegiaoCreateManyLocalidadeInput | localidadeRegiaoCreateManyLocalidadeInput[]
    skipDuplicates?: boolean
  }

  export type dioceseUpsertWithoutLocalidadeInput = {
    update: XOR<dioceseUpdateWithoutLocalidadeInput, dioceseUncheckedUpdateWithoutLocalidadeInput>
    create: XOR<dioceseCreateWithoutLocalidadeInput, dioceseUncheckedCreateWithoutLocalidadeInput>
    where?: dioceseWhereInput
  }

  export type dioceseUpdateToOneWithWhereWithoutLocalidadeInput = {
    where?: dioceseWhereInput
    data: XOR<dioceseUpdateWithoutLocalidadeInput, dioceseUncheckedUpdateWithoutLocalidadeInput>
  }

  export type dioceseUpdateWithoutLocalidadeInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    tipoDiocese?: tipoDioceseUpdateOneRequiredWithoutDiocesesNestedInput
    endereco?: enderecoUpdateOneRequiredWithoutDioceseNestedInput
    paroquias?: paroquiaUpdateManyWithoutDioceseNestedInput
  }

  export type dioceseUncheckedUpdateWithoutLocalidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoDioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    enderecoId?: IntFieldUpdateOperationsInput | number
    paroquias?: paroquiaUncheckedUpdateManyWithoutDioceseNestedInput
  }

  export type tipoLocalidadeUpsertWithoutLocalidadeInput = {
    update: XOR<tipoLocalidadeUpdateWithoutLocalidadeInput, tipoLocalidadeUncheckedUpdateWithoutLocalidadeInput>
    create: XOR<tipoLocalidadeCreateWithoutLocalidadeInput, tipoLocalidadeUncheckedCreateWithoutLocalidadeInput>
    where?: tipoLocalidadeWhereInput
  }

  export type tipoLocalidadeUpdateToOneWithWhereWithoutLocalidadeInput = {
    where?: tipoLocalidadeWhereInput
    data: XOR<tipoLocalidadeUpdateWithoutLocalidadeInput, tipoLocalidadeUncheckedUpdateWithoutLocalidadeInput>
  }

  export type tipoLocalidadeUpdateWithoutLocalidadeInput = {
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type tipoLocalidadeUncheckedUpdateWithoutLocalidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type enderecoUpsertWithoutLocalidadeInput = {
    update: XOR<enderecoUpdateWithoutLocalidadeInput, enderecoUncheckedUpdateWithoutLocalidadeInput>
    create: XOR<enderecoCreateWithoutLocalidadeInput, enderecoUncheckedCreateWithoutLocalidadeInput>
    where?: enderecoWhereInput
  }

  export type enderecoUpdateToOneWithWhereWithoutLocalidadeInput = {
    where?: enderecoWhereInput
    data: XOR<enderecoUpdateWithoutLocalidadeInput, enderecoUncheckedUpdateWithoutLocalidadeInput>
  }

  export type enderecoUpdateWithoutLocalidadeInput = {
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    paroquias?: paroquiaUpdateManyWithoutEnderecoNestedInput
    pessoas?: pessoaEnderecoUpdateManyWithoutEnderecoNestedInput
    diocese?: dioceseUpdateManyWithoutEnderecoNestedInput
  }

  export type enderecoUncheckedUpdateWithoutLocalidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    cep?: StringFieldUpdateOperationsInput | string
    logradouro?: StringFieldUpdateOperationsInput | string
    cidade?: StringFieldUpdateOperationsInput | string
    bairro?: StringFieldUpdateOperationsInput | string
    numero?: StringFieldUpdateOperationsInput | string
    UF?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    paroquias?: paroquiaUncheckedUpdateManyWithoutEnderecoNestedInput
    pessoas?: pessoaEnderecoUncheckedUpdateManyWithoutEnderecoNestedInput
    diocese?: dioceseUncheckedUpdateManyWithoutEnderecoNestedInput
  }

  export type localidadeRegiaoUpsertWithWhereUniqueWithoutLocalidadeInput = {
    where: localidadeRegiaoWhereUniqueInput
    update: XOR<localidadeRegiaoUpdateWithoutLocalidadeInput, localidadeRegiaoUncheckedUpdateWithoutLocalidadeInput>
    create: XOR<localidadeRegiaoCreateWithoutLocalidadeInput, localidadeRegiaoUncheckedCreateWithoutLocalidadeInput>
  }

  export type localidadeRegiaoUpdateWithWhereUniqueWithoutLocalidadeInput = {
    where: localidadeRegiaoWhereUniqueInput
    data: XOR<localidadeRegiaoUpdateWithoutLocalidadeInput, localidadeRegiaoUncheckedUpdateWithoutLocalidadeInput>
  }

  export type localidadeRegiaoUpdateManyWithWhereWithoutLocalidadeInput = {
    where: localidadeRegiaoScalarWhereInput
    data: XOR<localidadeRegiaoUpdateManyMutationInput, localidadeRegiaoUncheckedUpdateManyWithoutLocalidadeInput>
  }

  export type localidadeCreateWithoutLocalidadeRegiaoInput = {
    descricao: string
    observacao?: string | null
    diocese: dioceseCreateNestedOneWithoutLocalidadeInput
    tipoLocalidade: tipoLocalidadeCreateNestedOneWithoutLocalidadeInput
    endereco: enderecoCreateNestedOneWithoutLocalidadeInput
  }

  export type localidadeUncheckedCreateWithoutLocalidadeRegiaoInput = {
    id?: number
    descricao: string
    dioceseId: number
    tipoLocalidadeId: number
    observacao?: string | null
    enderecoId: number
  }

  export type localidadeCreateOrConnectWithoutLocalidadeRegiaoInput = {
    where: localidadeWhereUniqueInput
    create: XOR<localidadeCreateWithoutLocalidadeRegiaoInput, localidadeUncheckedCreateWithoutLocalidadeRegiaoInput>
  }

  export type regiaoCreateWithoutLocalidadeRegiaoInput = {
    descricao: string
    macroRegiao?: boolean
    equipes?: equipeRegiaoCreateNestedManyWithoutRegiaoInput
  }

  export type regiaoUncheckedCreateWithoutLocalidadeRegiaoInput = {
    id?: number
    descricao: string
    macroRegiao?: boolean
    equipes?: equipeRegiaoUncheckedCreateNestedManyWithoutRegiaoInput
  }

  export type regiaoCreateOrConnectWithoutLocalidadeRegiaoInput = {
    where: regiaoWhereUniqueInput
    create: XOR<regiaoCreateWithoutLocalidadeRegiaoInput, regiaoUncheckedCreateWithoutLocalidadeRegiaoInput>
  }

  export type localidadeUpsertWithoutLocalidadeRegiaoInput = {
    update: XOR<localidadeUpdateWithoutLocalidadeRegiaoInput, localidadeUncheckedUpdateWithoutLocalidadeRegiaoInput>
    create: XOR<localidadeCreateWithoutLocalidadeRegiaoInput, localidadeUncheckedCreateWithoutLocalidadeRegiaoInput>
    where?: localidadeWhereInput
  }

  export type localidadeUpdateToOneWithWhereWithoutLocalidadeRegiaoInput = {
    where?: localidadeWhereInput
    data: XOR<localidadeUpdateWithoutLocalidadeRegiaoInput, localidadeUncheckedUpdateWithoutLocalidadeRegiaoInput>
  }

  export type localidadeUpdateWithoutLocalidadeRegiaoInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    diocese?: dioceseUpdateOneRequiredWithoutLocalidadeNestedInput
    tipoLocalidade?: tipoLocalidadeUpdateOneRequiredWithoutLocalidadeNestedInput
    endereco?: enderecoUpdateOneRequiredWithoutLocalidadeNestedInput
  }

  export type localidadeUncheckedUpdateWithoutLocalidadeRegiaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dioceseId?: IntFieldUpdateOperationsInput | number
    tipoLocalidadeId?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoId?: IntFieldUpdateOperationsInput | number
  }

  export type regiaoUpsertWithoutLocalidadeRegiaoInput = {
    update: XOR<regiaoUpdateWithoutLocalidadeRegiaoInput, regiaoUncheckedUpdateWithoutLocalidadeRegiaoInput>
    create: XOR<regiaoCreateWithoutLocalidadeRegiaoInput, regiaoUncheckedCreateWithoutLocalidadeRegiaoInput>
    where?: regiaoWhereInput
  }

  export type regiaoUpdateToOneWithWhereWithoutLocalidadeRegiaoInput = {
    where?: regiaoWhereInput
    data: XOR<regiaoUpdateWithoutLocalidadeRegiaoInput, regiaoUncheckedUpdateWithoutLocalidadeRegiaoInput>
  }

  export type regiaoUpdateWithoutLocalidadeRegiaoInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    macroRegiao?: BoolFieldUpdateOperationsInput | boolean
    equipes?: equipeRegiaoUpdateManyWithoutRegiaoNestedInput
  }

  export type regiaoUncheckedUpdateWithoutLocalidadeRegiaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    macroRegiao?: BoolFieldUpdateOperationsInput | boolean
    equipes?: equipeRegiaoUncheckedUpdateManyWithoutRegiaoNestedInput
  }

  export type localidadeCreateWithoutTipoLocalidadeInput = {
    descricao: string
    observacao?: string | null
    diocese: dioceseCreateNestedOneWithoutLocalidadeInput
    endereco: enderecoCreateNestedOneWithoutLocalidadeInput
    localidadeRegiao?: localidadeRegiaoCreateNestedManyWithoutLocalidadeInput
  }

  export type localidadeUncheckedCreateWithoutTipoLocalidadeInput = {
    id?: number
    descricao: string
    dioceseId: number
    observacao?: string | null
    enderecoId: number
    localidadeRegiao?: localidadeRegiaoUncheckedCreateNestedManyWithoutLocalidadeInput
  }

  export type localidadeCreateOrConnectWithoutTipoLocalidadeInput = {
    where: localidadeWhereUniqueInput
    create: XOR<localidadeCreateWithoutTipoLocalidadeInput, localidadeUncheckedCreateWithoutTipoLocalidadeInput>
  }

  export type localidadeCreateManyTipoLocalidadeInputEnvelope = {
    data: localidadeCreateManyTipoLocalidadeInput | localidadeCreateManyTipoLocalidadeInput[]
    skipDuplicates?: boolean
  }

  export type localidadeUpsertWithWhereUniqueWithoutTipoLocalidadeInput = {
    where: localidadeWhereUniqueInput
    update: XOR<localidadeUpdateWithoutTipoLocalidadeInput, localidadeUncheckedUpdateWithoutTipoLocalidadeInput>
    create: XOR<localidadeCreateWithoutTipoLocalidadeInput, localidadeUncheckedCreateWithoutTipoLocalidadeInput>
  }

  export type localidadeUpdateWithWhereUniqueWithoutTipoLocalidadeInput = {
    where: localidadeWhereUniqueInput
    data: XOR<localidadeUpdateWithoutTipoLocalidadeInput, localidadeUncheckedUpdateWithoutTipoLocalidadeInput>
  }

  export type localidadeUpdateManyWithWhereWithoutTipoLocalidadeInput = {
    where: localidadeScalarWhereInput
    data: XOR<localidadeUpdateManyMutationInput, localidadeUncheckedUpdateManyWithoutTipoLocalidadeInput>
  }

  export type estadoCreateManyPaisInput = {
    id?: number
    nome: string
    sigla: string
    ativo?: boolean
  }

  export type estadoUpdateWithoutPaisInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    cidade?: cidadeUpdateManyWithoutEstadoNestedInput
  }

  export type estadoUncheckedUpdateWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    cidade?: cidadeUncheckedUpdateManyWithoutEstadoNestedInput
  }

  export type estadoUncheckedUpdateManyWithoutPaisInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sigla?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cidadeCreateManyEstadoInput = {
    id?: number
    nome: string
    ativo?: boolean
  }

  export type cidadeUpdateWithoutEstadoInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cidadeUncheckedUpdateWithoutEstadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type cidadeUncheckedUpdateManyWithoutEstadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type paroquiaCreateManyEnderecoInput = {
    id?: number
    dioceseId: number
    descricao: string
  }

  export type pessoaEnderecoCreateManyEnderecoInput = {
    pessoaId: number
  }

  export type localidadeCreateManyEnderecoInput = {
    id?: number
    descricao: string
    dioceseId: number
    tipoLocalidadeId: number
    observacao?: string | null
  }

  export type dioceseCreateManyEnderecoInput = {
    id?: number
    tipoDioceseId: number
    descricao: string
  }

  export type paroquiaUpdateWithoutEnderecoInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    diocese?: dioceseUpdateOneRequiredWithoutParoquiasNestedInput
    pessoas?: paroquiaPessoasUpdateManyWithoutParoquiaNestedInput
  }

  export type paroquiaUncheckedUpdateWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    dioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pessoas?: paroquiaPessoasUncheckedUpdateManyWithoutParoquiaNestedInput
  }

  export type paroquiaUncheckedUpdateManyWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    dioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaEnderecoUpdateWithoutEnderecoInput = {
    pessoa?: pessoaUpdateOneRequiredWithoutEnderecosNestedInput
  }

  export type pessoaEnderecoUncheckedUpdateWithoutEnderecoInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaEnderecoUncheckedUpdateManyWithoutEnderecoInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type localidadeUpdateWithoutEnderecoInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    diocese?: dioceseUpdateOneRequiredWithoutLocalidadeNestedInput
    tipoLocalidade?: tipoLocalidadeUpdateOneRequiredWithoutLocalidadeNestedInput
    localidadeRegiao?: localidadeRegiaoUpdateManyWithoutLocalidadeNestedInput
  }

  export type localidadeUncheckedUpdateWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dioceseId?: IntFieldUpdateOperationsInput | number
    tipoLocalidadeId?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    localidadeRegiao?: localidadeRegiaoUncheckedUpdateManyWithoutLocalidadeNestedInput
  }

  export type localidadeUncheckedUpdateManyWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dioceseId?: IntFieldUpdateOperationsInput | number
    tipoLocalidadeId?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dioceseUpdateWithoutEnderecoInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    tipoDiocese?: tipoDioceseUpdateOneRequiredWithoutDiocesesNestedInput
    paroquias?: paroquiaUpdateManyWithoutDioceseNestedInput
    localidade?: localidadeUpdateManyWithoutDioceseNestedInput
  }

  export type dioceseUncheckedUpdateWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoDioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    paroquias?: paroquiaUncheckedUpdateManyWithoutDioceseNestedInput
    localidade?: localidadeUncheckedUpdateManyWithoutDioceseNestedInput
  }

  export type dioceseUncheckedUpdateManyWithoutEnderecoInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoDioceseId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type pessoaCarismaCreateManyTipoCarismaInput = {
    pessoaId: number
  }

  export type pessoaCarismaUpdateWithoutTipoCarismaInput = {
    pessoa?: pessoaUpdateOneRequiredWithoutPessoaCarismaNestedInput
  }

  export type pessoaCarismaUncheckedUpdateWithoutTipoCarismaInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCarismaUncheckedUpdateManyWithoutTipoCarismaInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCreateManyEstadoCivilInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
    tipoPessoaId?: number
  }

  export type pessoaUpdateWithoutEstadoCivilInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutEstadoCivilInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateManyWithoutEstadoCivilInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCreateManyEscolaridadeInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    ativo?: boolean
    tipoPessoaId?: number
  }

  export type pessoaUpdateWithoutEscolaridadeInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    tipoPessoa?: tipoPessoaUpdateOneRequiredWithoutPessoaNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutEscolaridadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateManyWithoutEscolaridadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    tipoPessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type passaportePessoaCreateManyPessoaInput = {
    id?: number
    numero: string
    dataExpiracao: Date | string
    renovado?: boolean
    dataRenovacao?: Date | string | null
  }

  export type pessoaContatoCreateManyPessoaInput = {
    id?: number
    telefoneResidencial?: string | null
    telefoneCelular?: string | null
    observacao?: string | null
    ativo?: boolean
    email?: string | null
  }

  export type paroquiaPessoasCreateManyPessoaInput = {
    paroquiaId: number
  }

  export type pessoaCasalCreateManyMaridoInput = {
    id?: number
    pessoaMulherId: number
  }

  export type pessoaCasalCreateManyMulherInput = {
    id?: number
    pessoaMaridoId: number
  }

  export type pessoaEnderecoCreateManyPessoaInput = {
    enderecoId: number
  }

  export type equipePessoasCreateManyPessoaInput = {
    equipeId: number
  }

  export type pessoaCarismaCreateManyPessoaInput = {
    tipoCarismaId: number
  }

  export type passaportePessoaUpdateWithoutPessoaInput = {
    numero?: StringFieldUpdateOperationsInput | string
    dataExpiracao?: DateTimeFieldUpdateOperationsInput | Date | string
    renovado?: BoolFieldUpdateOperationsInput | boolean
    dataRenovacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type passaportePessoaUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    dataExpiracao?: DateTimeFieldUpdateOperationsInput | Date | string
    renovado?: BoolFieldUpdateOperationsInput | boolean
    dataRenovacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type passaportePessoaUncheckedUpdateManyWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    numero?: StringFieldUpdateOperationsInput | string
    dataExpiracao?: DateTimeFieldUpdateOperationsInput | Date | string
    renovado?: BoolFieldUpdateOperationsInput | boolean
    dataRenovacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type pessoaContatoUpdateWithoutPessoaInput = {
    telefoneResidencial?: NullableStringFieldUpdateOperationsInput | string | null
    telefoneCelular?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pessoaContatoUncheckedUpdateWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    telefoneResidencial?: NullableStringFieldUpdateOperationsInput | string | null
    telefoneCelular?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type pessoaContatoUncheckedUpdateManyWithoutPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    telefoneResidencial?: NullableStringFieldUpdateOperationsInput | string | null
    telefoneCelular?: NullableStringFieldUpdateOperationsInput | string | null
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paroquiaPessoasUpdateWithoutPessoaInput = {
    paroquia?: paroquiaUpdateOneRequiredWithoutPessoasNestedInput
  }

  export type paroquiaPessoasUncheckedUpdateWithoutPessoaInput = {
    paroquiaId?: IntFieldUpdateOperationsInput | number
  }

  export type paroquiaPessoasUncheckedUpdateManyWithoutPessoaInput = {
    paroquiaId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCasalUpdateWithoutMaridoInput = {
    mulher?: pessoaUpdateOneRequiredWithoutCasamentosComoMulherNestedInput
  }

  export type pessoaCasalUncheckedUpdateWithoutMaridoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoaMulherId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCasalUncheckedUpdateManyWithoutMaridoInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoaMulherId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCasalUpdateWithoutMulherInput = {
    marido?: pessoaUpdateOneRequiredWithoutCasamentosComoMaridoNestedInput
  }

  export type pessoaCasalUncheckedUpdateWithoutMulherInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoaMaridoId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCasalUncheckedUpdateManyWithoutMulherInput = {
    id?: IntFieldUpdateOperationsInput | number
    pessoaMaridoId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaEnderecoUpdateWithoutPessoaInput = {
    endereco?: enderecoUpdateOneRequiredWithoutPessoasNestedInput
  }

  export type pessoaEnderecoUncheckedUpdateWithoutPessoaInput = {
    enderecoId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaEnderecoUncheckedUpdateManyWithoutPessoaInput = {
    enderecoId?: IntFieldUpdateOperationsInput | number
  }

  export type equipePessoasUpdateWithoutPessoaInput = {
    equipe?: equipeUpdateOneRequiredWithoutEquipePessoasNestedInput
  }

  export type equipePessoasUncheckedUpdateWithoutPessoaInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
  }

  export type equipePessoasUncheckedUpdateManyWithoutPessoaInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCarismaUpdateWithoutPessoaInput = {
    tipoCarisma?: tipoCarismaUpdateOneRequiredWithoutPessoaCarismaNestedInput
  }

  export type pessoaCarismaUncheckedUpdateWithoutPessoaInput = {
    tipoCarismaId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCarismaUncheckedUpdateManyWithoutPessoaInput = {
    tipoCarismaId?: IntFieldUpdateOperationsInput | number
  }

  export type pessoaCreateManyTipoPessoaInput = {
    id?: number
    nome: string
    conhecidoPor?: string | null
    sexo?: $Enums.Sexo
    cpf?: string | null
    nacionalidade: string
    dataNascimento?: Date | string | null
    estadoCivilId: number
    foto?: string | null
    escolaridadeId?: number | null
    ativo?: boolean
  }

  export type pessoaUpdateWithoutTipoPessoaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    estadoCivil?: estadoCivilUpdateOneRequiredWithoutPessoasNestedInput
    escolaridade?: escolaridadeUpdateOneWithoutPessoasNestedInput
    passaportes?: passaportePessoaUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateWithoutTipoPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    passaportes?: passaportePessoaUncheckedUpdateManyWithoutPessoaNestedInput
    contatos?: pessoaContatoUncheckedUpdateManyWithoutPessoaNestedInput
    paroquias?: paroquiaPessoasUncheckedUpdateManyWithoutPessoaNestedInput
    casamentosComoMarido?: pessoaCasalUncheckedUpdateManyWithoutMaridoNestedInput
    casamentosComoMulher?: pessoaCasalUncheckedUpdateManyWithoutMulherNestedInput
    enderecos?: pessoaEnderecoUncheckedUpdateManyWithoutPessoaNestedInput
    equipes?: equipePessoasUncheckedUpdateManyWithoutPessoaNestedInput
    pessoaCarisma?: pessoaCarismaUncheckedUpdateManyWithoutPessoaNestedInput
  }

  export type pessoaUncheckedUpdateManyWithoutTipoPessoaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    conhecidoPor?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: EnumSexoFieldUpdateOperationsInput | $Enums.Sexo
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    nacionalidade?: StringFieldUpdateOperationsInput | string
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estadoCivilId?: IntFieldUpdateOperationsInput | number
    foto?: NullableStringFieldUpdateOperationsInput | string | null
    escolaridadeId?: NullableIntFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type dioceseCreateManyTipoDioceseInput = {
    id?: number
    descricao: string
    enderecoId: number
  }

  export type dioceseUpdateWithoutTipoDioceseInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    endereco?: enderecoUpdateOneRequiredWithoutDioceseNestedInput
    paroquias?: paroquiaUpdateManyWithoutDioceseNestedInput
    localidade?: localidadeUpdateManyWithoutDioceseNestedInput
  }

  export type dioceseUncheckedUpdateWithoutTipoDioceseInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    enderecoId?: IntFieldUpdateOperationsInput | number
    paroquias?: paroquiaUncheckedUpdateManyWithoutDioceseNestedInput
    localidade?: localidadeUncheckedUpdateManyWithoutDioceseNestedInput
  }

  export type dioceseUncheckedUpdateManyWithoutTipoDioceseInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    enderecoId?: IntFieldUpdateOperationsInput | number
  }

  export type paroquiaCreateManyDioceseInput = {
    id?: number
    enderecoId: number
    descricao: string
  }

  export type localidadeCreateManyDioceseInput = {
    id?: number
    descricao: string
    tipoLocalidadeId: number
    observacao?: string | null
    enderecoId: number
  }

  export type paroquiaUpdateWithoutDioceseInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    endereco?: enderecoUpdateOneRequiredWithoutParoquiasNestedInput
    pessoas?: paroquiaPessoasUpdateManyWithoutParoquiaNestedInput
  }

  export type paroquiaUncheckedUpdateWithoutDioceseInput = {
    id?: IntFieldUpdateOperationsInput | number
    enderecoId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    pessoas?: paroquiaPessoasUncheckedUpdateManyWithoutParoquiaNestedInput
  }

  export type paroquiaUncheckedUpdateManyWithoutDioceseInput = {
    id?: IntFieldUpdateOperationsInput | number
    enderecoId?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
  }

  export type localidadeUpdateWithoutDioceseInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    tipoLocalidade?: tipoLocalidadeUpdateOneRequiredWithoutLocalidadeNestedInput
    endereco?: enderecoUpdateOneRequiredWithoutLocalidadeNestedInput
    localidadeRegiao?: localidadeRegiaoUpdateManyWithoutLocalidadeNestedInput
  }

  export type localidadeUncheckedUpdateWithoutDioceseInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    tipoLocalidadeId?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoId?: IntFieldUpdateOperationsInput | number
    localidadeRegiao?: localidadeRegiaoUncheckedUpdateManyWithoutLocalidadeNestedInput
  }

  export type localidadeUncheckedUpdateManyWithoutDioceseInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    tipoLocalidadeId?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoId?: IntFieldUpdateOperationsInput | number
  }

  export type paroquiaPessoasCreateManyParoquiaInput = {
    pessoaId: number
  }

  export type paroquiaPessoasUpdateWithoutParoquiaInput = {
    pessoa?: pessoaUpdateOneRequiredWithoutParoquiasNestedInput
  }

  export type paroquiaPessoasUncheckedUpdateWithoutParoquiaInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type paroquiaPessoasUncheckedUpdateManyWithoutParoquiaInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeRegiaoCreateManyRegiaoInput = {
    equipeId: number
  }

  export type localidadeRegiaoCreateManyRegiaoInput = {
    localidadeId: number
  }

  export type equipeRegiaoUpdateWithoutRegiaoInput = {
    equipe?: equipeUpdateOneRequiredWithoutRegioesNestedInput
  }

  export type equipeRegiaoUncheckedUpdateWithoutRegiaoInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeRegiaoUncheckedUpdateManyWithoutRegiaoInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
  }

  export type localidadeRegiaoUpdateWithoutRegiaoInput = {
    localidade?: localidadeUpdateOneRequiredWithoutLocalidadeRegiaoNestedInput
  }

  export type localidadeRegiaoUncheckedUpdateWithoutRegiaoInput = {
    localidadeId?: IntFieldUpdateOperationsInput | number
  }

  export type localidadeRegiaoUncheckedUpdateManyWithoutRegiaoInput = {
    localidadeId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeTipoEquipeCreateManyTipoEquipeInput = {
    equipeId: number
  }

  export type equipeTipoEquipeUpdateWithoutTipoEquipeInput = {
    equipe?: equipeUpdateOneRequiredWithoutTiposNestedInput
  }

  export type equipeTipoEquipeUncheckedUpdateWithoutTipoEquipeInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeTipoEquipeUncheckedUpdateManyWithoutTipoEquipeInput = {
    equipeId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeRegiaoCreateManyEquipeInput = {
    regiaoId: number
  }

  export type equipePessoasCreateManyEquipeInput = {
    pessoaId: number
  }

  export type equipeTipoEquipeCreateManyEquipeInput = {
    tipoEquipeId: number
  }

  export type equipeRegiaoUpdateWithoutEquipeInput = {
    regiao?: regiaoUpdateOneRequiredWithoutEquipesNestedInput
  }

  export type equipeRegiaoUncheckedUpdateWithoutEquipeInput = {
    regiaoId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeRegiaoUncheckedUpdateManyWithoutEquipeInput = {
    regiaoId?: IntFieldUpdateOperationsInput | number
  }

  export type equipePessoasUpdateWithoutEquipeInput = {
    pessoa?: pessoaUpdateOneRequiredWithoutEquipesNestedInput
  }

  export type equipePessoasUncheckedUpdateWithoutEquipeInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type equipePessoasUncheckedUpdateManyWithoutEquipeInput = {
    pessoaId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeTipoEquipeUpdateWithoutEquipeInput = {
    tipoEquipe?: tipoEquipeUpdateOneRequiredWithoutEquipesNestedInput
  }

  export type equipeTipoEquipeUncheckedUpdateWithoutEquipeInput = {
    tipoEquipeId?: IntFieldUpdateOperationsInput | number
  }

  export type equipeTipoEquipeUncheckedUpdateManyWithoutEquipeInput = {
    tipoEquipeId?: IntFieldUpdateOperationsInput | number
  }

  export type localidadeRegiaoCreateManyLocalidadeInput = {
    regiaoId: number
  }

  export type localidadeRegiaoUpdateWithoutLocalidadeInput = {
    regiao?: regiaoUpdateOneRequiredWithoutLocalidadeRegiaoNestedInput
  }

  export type localidadeRegiaoUncheckedUpdateWithoutLocalidadeInput = {
    regiaoId?: IntFieldUpdateOperationsInput | number
  }

  export type localidadeRegiaoUncheckedUpdateManyWithoutLocalidadeInput = {
    regiaoId?: IntFieldUpdateOperationsInput | number
  }

  export type localidadeCreateManyTipoLocalidadeInput = {
    id?: number
    descricao: string
    dioceseId: number
    observacao?: string | null
    enderecoId: number
  }

  export type localidadeUpdateWithoutTipoLocalidadeInput = {
    descricao?: StringFieldUpdateOperationsInput | string
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    diocese?: dioceseUpdateOneRequiredWithoutLocalidadeNestedInput
    endereco?: enderecoUpdateOneRequiredWithoutLocalidadeNestedInput
    localidadeRegiao?: localidadeRegiaoUpdateManyWithoutLocalidadeNestedInput
  }

  export type localidadeUncheckedUpdateWithoutTipoLocalidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dioceseId?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoId?: IntFieldUpdateOperationsInput | number
    localidadeRegiao?: localidadeRegiaoUncheckedUpdateManyWithoutLocalidadeNestedInput
  }

  export type localidadeUncheckedUpdateManyWithoutTipoLocalidadeInput = {
    id?: IntFieldUpdateOperationsInput | number
    descricao?: StringFieldUpdateOperationsInput | string
    dioceseId?: IntFieldUpdateOperationsInput | number
    observacao?: NullableStringFieldUpdateOperationsInput | string | null
    enderecoId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}